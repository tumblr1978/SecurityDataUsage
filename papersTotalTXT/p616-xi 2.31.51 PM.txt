Instant and Robust Authentication and Key Agreement

among Mobile Devices

Wei Xi1, Chen Qian2, Jinsong Han1, Kun Zhao1, Sheng Zhong3, Xiang-Yang Li4, Jizhong Zhao1

1Xi‚Äôan Jiaotong University; 2University of California Santa Cruz;

3Nanjing University; 4University of Science and Technology of China;
{weixi.cs, hanjinsong, xiangyang.li}@gmail.com;cqian12@ucsc.edu;

zhongsheng@nju.edu.cn; {zhaokun2012, zjz}@mail.xjtu.edu.cn

ABSTRACT
Device-to-device communication is important to emerging
mobile applications such as Internet of Things and mobile
social networks. Authentication and key agreement among
multiple legitimate devices is the important Ô¨Årst step to
build a secure communication channel. Existing solutions
put the devices into physical proximity and use the common
radio environment as a proof of identities and the common
secret to agree on a same key. However they experience very
slow secret bit generation rate and high errors, requiring sev-
eral minutes to build a 256-bit key. In this work, we design
and implement an authentication and key agreement proto-
col for mobile devices, called The Dancing Signals (TDS),
being extremely fast and error-free. TDS uses channel state
information (CSI) as the common secret among legitimate
devices. It guarantees that only devices in a close physical
proximity can agree on a key and any device outside a cer-
tain distance gets nothing about the key. Compared with
existing solutions, TDS is very fast and robust, support-
s group key agreement, and can eÔ¨Äectively defend against
predictable channel attacks. We implement TDS using com-
modity oÔ¨Ä-the-shelf 802.11n devices and evaluate its perfor-
mance via extensive experiments. Results show that TDS
only takes a couple of seconds to make devices agree on a
256-bit secret key with high entropy.

Keywords
Group authentication; Key agreement; WiFi; CSI

1.

INTRODUCTION

With the rapid technology growth of mobile devices, wire-
less device-to-device communication has been playing im-

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-
tion on the Ô¨Årst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS‚Äô16, October 24-28, 2016, Vienna, Austria
c(cid:2) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978298

portant roles for many emerging applications including In-
ternet of Things (IoT) and mobile social networks. For ex-
ample, IoT appliances may communicate with each other
to collaboratively sense the physical world and make proper
reactions [19]. Mobile social applications fuel the need for
mobile devices such as smartphones to interact directly in
an ad-hoc mode to share various information such as texts,
pictures, and videos.

A fundamental problem of wireless device-to-device com-
munication is the vulnerability to various attacks such as
identity spooÔ¨Ång, eavesdropping, and man-in-the-middle at-
tacks [24] [15] [4]. Sensitive information such as health con-
ditions and personal data shared among IoT and Mobile so-
cial devices has become the targets of these attacks. Hence
authentication and key agreement among mobile devices is
the critical Ô¨Årst step to secure such interactions. It requires a
number of mobile devices to agree on a symmetric key with-
out prior shared secret, through an untrusted and unauthen-
ticated wireless channel. The key then helps to establish a
secure channel for these devices. Hence authentication and
key agreement are both required in building the secure chan-
nel. This process is also called as device pairing or grouping
in the literature.

Traditional public key encryption and DiÔ¨Ée-Hellman key
exchange [6] do not work for device-to-device communica-
tion in mobile networks due to the open nature of the wire-
less medium and lack of centralized trust management [16]
[8]. Recent eÔ¨Äorts have been made to device authentica-
tion and key agreement while reducing the amount of user
interactions such as manual key assignment and input [24]
[15] [23] [19]. The main idea of these methods is to put two
devices into physical proximity and use the common radio
environment as a proof of identities and the common secret
to generate a same key on diÔ¨Äerent devices. The main limi-
tations of these methods is slow speed of key generation and
high error rate. For example, Radiotelepathy [16] extracts
secret keys using the channel impulse response (CIR) in the
wireless channel and its key generation rate is only around
1 bit per second. ProxiMate can generate less than Ô¨Åve bit-
s per second in most scenarios [15], costing more than one
minute for two devices to agree on a 256-bit key. Holding
two devices in a physical proximity (5cm in the ProxiMate

616experiments [15]) for minutes before communication is in-
convenience in most applications. A recent work can pair
two IoT devices co-present in a long period of time [19].
This solution is good for wearable devices that are attached
to the same object or human being, but impractical for de-
vices that may move away from each other. Pinpoint [27]
can pair two devices and estimate secure channel leverag-
ing semi-symmetrical CIR to dispel reversed jamming noise.
However, this method can hardly expand to more than two
devices yet. Moreover, many existing key agreement meth-
ods assumes that two devices communicate through an au-
thenticated channel [2] [16] [15] [14] [28]. Without extra de-
vice authentication solutions, these methods are vulnerable
to various attacks such as a man-in-the-middle attack.

In this work, we design and implement an authentication
and key agreement protocol for mobile devices with instan-
t and robust key agreement. Our experiments using com-
modity oÔ¨Ä-the-shelf (COTS) wireless devices show secret bit
generation rates faster than existing methods by more than
an order of magnitude in various practical scenarios. The
key idea behind the speed improvement is a new key distri-
bution protocol. DiÔ¨Äerent from many existing methods that
use received signal strength (RSS) to extract secret bits [15],
we use channel state information (CSI) available from Or-
thogonal Frequency Division Multiplexing (OFDM) of the
current WiFi standard. DiÔ¨Äerent from RSS, CSI measure-
ment contains much richer information in a same period of
time. On the other hand, previous methods that use recip-
rocal quantization (directly converting each signal sample to
a bit) may introduce many mismatched bits for the two keys
generated on diÔ¨Äerent devices [2] [16] [15] [14] [28], requiring
additional information reconciliation process [3] to Ô¨Åx the
errors. Moreover, since CSI is very sensitive to location es-
pecially in indoor environment, the authentication distance
for all existing proximity-based methods (e.g., Amigo [24],
ProxiMate [15]) should be less than 0.1Œª (1.25cm@2.4GHz)
using CSI, which is not practical for WiFi devices. To over-
come these limitations, our solution uses substitution-based
key delivery instead of quantization-based key extraction,
which is highly robust for secret bit agreement. We name
this method as The Dancing Signals (TDS).1

Besides fast key generation, another unique feature of TD-
S is that the secret key can be an arbitrary bit string spec-
iÔ¨Åed by one of the devices, while in existing methods the
agreed key completely depends on common wireless chan-
nel information. This feature brings three important advan-
tages: i) TDS can always build a key with strong randomness
and avoid keys with low entropy [8]. ii) TDS can built a key
among more than two devices. In previous pairing methods,
it is hard for more than two devices to simultaneously gen-
erate a same key, since mismatched bits between every pair
of keys lead an unaÔ¨Äordable agreement overhead and signif-
icant risk of key leakage. TDS allows a key to be directly
delivered from one device to others, saving huge amount of
overhead from interactive agreement.
iii) TDS is very ro-
1The name was inspired by the story ‚ÄúThe Adventure of the
Dancing Men‚Äù written by Arthur Conan Doyle. In the story
Sherlock Holmes receives a paper with a sequence of dancing
men Ô¨Ågures from a client. He later realizes each dancing man
is a substitution of an English letter and cracks the code.

bust to the predictable channel attack [8]. In such an attack,
an adversary uses planned movements to cause desired and
predictable changes in the channel between the two devices
and further predict the key generated from the channel.

We summarize the advantages of TDS as follows:
‚Ä¢ TDS achieves both device authentication and key a-
greement. Compared with prior methods that only
focus on one of them such as [1] [23] [28], TDS is more
robust to various attacks.
‚Ä¢ The secret bit generation rate of TDS is faster than
existing solutions [24] [15] by over an order of mag-
nitude. Our implementation on COTS devices show
generation rates of hundreds bits/sec.
‚Ä¢ Previous device pairing protocols can only support two
‚Ä¢ TDS can be used to transmit any conÔ¨Ådential bit se-
quence speciÔ¨Åed by the sender, including self-generated
session keys, which avoids keys with low entropy.
‚Ä¢ TDS can eÔ¨Äectively defend against predictable channel

devices. TDS works well for more devices.

attacks.

The rest of this paper is organized as follows. Section 2
presents the system model and observations from our exper-
iments. Section 3 details the protocol design of TDS. We
provide the analysis for the security and eÔ¨Éciency of TDS
in Section 4. Section 5 shows the evaluation results based on
the implementation of TDS on oÔ¨Ä-the-shelf mobile devices.
We present the related work in Section 6 and conclude our
work in Section 7.

2. SYSTEM MODEL AND OBSERVATION
In this section, we Ô¨Årst deÔ¨Åne the system and security
model of TDS. We then use analysis and experiments to
demonstrate the feasibility and challenges of using CSI mea-
surement to make key agreement among multiple devices.
2.1 System and security model

We assume that multiple legitimate wireless devices, Al-
ice, Bob, and Calvin, are interested in securely exchanging
their private information. They are able to communicate
via the standard IEEE 802.11 protocols with OFDM, such
as WiFi. They have no prior shared secret. When per-
forming key agreement, the devices need to be placed by
their users in a physical proximity such that the distance
from any device to Alice is less than a authentication dis-
tance (0.4Œª ‚âà 5cm@2.4GHz where Œª is the wavelength).
A malicious device Eve is located beyond a safe distance
(Œª ‚âà 12.5cm for WiFi) to Alice. If Eve moves into the safe
distance, it will be easily seen by the users of Alice and
Bob. Eve can sense the wireless environment, inject new
traÔ¨Éc, and replay packets. Alice, Bob, Calvin and Eve can
hear a public wireless source Peter. Eve can perform var-
ious attacks including spooÔ¨Ång, eavesdropping, and man-
in-the-middle. In the most extreme case, Eve may control
Peter that Alice, Bob and Calvin are using for key agreemen-
t. Then Eve can turn the signal strength into any pattern
she desires. Eve has complete knowledge of the proposed
method and algorithms.

The goal of this system is to instantly make Alice, Bob,
and Calvin agree on a strong symmetric key without letting

6171
0.8

0.6

0.4

0.2

Indoor
Outdoor

i

n
e
c
i
f
f
e
o
c
 
n
o
i
t
a
e
r
r
o
C

l

0
‚àí0.2
 
0

(cid:16)(cid:14)(cid:21)(cid:76) (cid:76) (cid:17)(cid:14)(cid:21)(cid:76) (cid:18)(cid:76) (cid:18)(cid:14)(cid:21)(cid:76)

0

0

Distance

0.

1

e
t
a
r
 
h
c
t
a
m
s
M

i

0.

0.

0.

0.8

e
t
a
r
 
 
G
H
G
U
D
F
V
'

L

0.6

0.4

MismatchUDWH
'LVFDUGHG UDWH

0.2


$EDQGRQHG=RQH

2(cid:1)

3

0
4

i

s
e
m
7
 
k
c
e
h
C

 
f

o

 

#

250

200

150

100

50

0

RISDVVHV 5 
RISDVVHV 
RISDVVHV 

0 5 10 15 20 25 30 35 40

# of Error %its

e

t

a
R

 
l
l

a
c
e
R

1

0.8

0.6

0.4

0.2

0

5 times
6 times
7 times

0 5 10 15 20 25 30 35 40

# of Error Bits

Figure 1: Pearson corre-
lation coeÔ¨Écient decreas-
es with growing distance

Figure 2: Dilemma of mis-
match rate and discarded
rate

Figure 3: Mismatched
bits cause high cost in er-
ror correction

Information
Figure 4:
reconciliation fails more
seriously with increasing
error bits

Eve know about the key. We have the following security
requirements.
‚Ä¢ Authenticity. A device needs to ensure that it is mak-
ing key agreement with other legitimate devices. Any
spoofer will be detected.

‚Ä¢ ConÔ¨Ådentiality. Any information of the key should not

be exposed to Eve.

‚Ä¢ Integrity. The key should be consistent at all legiti-

mate devices.

We do not consider availability in this work. If Eve block
all WiFi signals, devices may not agree on any key.
2.2 Feasibility of CSI-based key generation

In this paper, we use CSI as the proof of authenticity and
source of common secret information. The intuition of us-
ing CSI is that it is a unique and correlated measurement
for devices around a particular physical location. CSI mea-
surements at diÔ¨Äerent devices are rapidly de-correlated with
distance between them.
In addition, CSI is unpredictable
due to its random property caused by the multipath eÔ¨Äect
of signal propagation. CSI is a much richer source of secret
information than the one of RSS, because it contains the
information of 56 subcarriers in each measurement sample.
We demonstrate the properties using experimental vali-
dation. We use two laptop computers Alice and Bob, each
equipped with COTS wireless NIC model Intel 5300 oper-
ating in the 802.11n 2.4GHz channel.2 They then collect
measurement results of the CSI amplitude values indepen-
dently from a public WiFi while varying their distance from
0.1Œª to 2.5Œª, where the wavelength Œª = 12.5cm for 2.4GHz.
Figure 1 shows the Pearson product-moment correlation co-
eÔ¨Écient of the CSI samples from the two devices. We found
that when the distance is smaller than 0.5Œª, the samples are
highly correlated. The correlation drops quickly with the
distance growth. When the distance > 2Œª, the samples are
uncorrelated.

The above properties of CSI are important for device au-
thentication and key agreement. Only if the samples from
diÔ¨Äerent devices nearby are similar, CSI can be a proof of

2We use laptops for the ease of programming. The method
can be applied to any devices with 802.11 NICs.

physical proximity. Only if the samples are rapidly de-
correlated with distance between the devices, CSI can be
a common secure information.
2.3 Challenges of CSI-based key generation

Suppose two devices, Alice and Bob both listen to a public
WiFi source. For each of them, the CSI amplitude value h(t)
at time t can be directly obtained from an existing API of
the Intel 5300 network card. To extract secret information
from two similar measurements of CSI amplitude values, a
simple approach is to determine a cut-oÔ¨Ä amplitude level
h and use 0 to represent samples smaller than h and 1 to
represent samples larger than h. For example, h can be 0.5
for CSI amplitude varying in [0, 1]. This method is called
reciprocal quantization.

Reciprocal quantization may cause mismatched bits at t-
wo devices. For example, if Alice gets a CSI value 0.53 for
a particular bit, Bob gets 0.48, and the cut-oÔ¨Ä is 0.5, then
they will have a diÔ¨Äerent bit. To reduce these mismatched
bits, existing quantization methods often use an abandoned
zone. For example, if the abandoned zone is [0.4, 0.6], then
only if a CSI value is less than 0.4 (or larger than 0.6), it
can be converted to a 0-bit (or 1-bit).

Selecting the size of the abandoned zone is a dilemma: if
the zone is small, mismatched bits still occur; if the zone
is large, too many CSI samples will be discarded, slowing
secret bit generation. Figure 2 shows the bit mismatch rate
versus the discarded bit rate by varying the abandoned zone
from 0 to 4œÉ, where œÉ is the standard deviation of the Gaus-
sian noise. We Ô¨Ånd that when the abandoned zone is smaller
than œÉ, the discarded rate is low but it causes more than 10%
mismatched bits. When the zone is large, e.g., 3œÉ, the mis-
match rate is negligible but more than 80% samples will be
discarded. To further demonstrate the harm of mismatched
bits, we use an existing method, information reconciliation
[3] [8], to Ô¨Åx mismatched bits by iterative parity checks.
Figure 3 shows that the rounds of parity checks increase sig-
niÔ¨Åcantly with growing mismatched bits, for generation of a
256-bit key. For 20 mismatched bits, it requires more than
70-150 parity check bits to correct them. Besides tremen-
dous communication and time cost, the number of secret
bits is also reduced from 256 to < 150 due to privacy am-
pliÔ¨Åcation [17]. Additionally, information reconciliation is a

618



















 











 











 











"

#

#	!#

























(cid:37)(cid:82)(cid:69)(cid:3)(cid:54)(cid:16)(cid:69)(cid:82)(cid:91)













(cid:36)(cid:79)(cid:76)(cid:70)(cid:72)(cid:3)(cid:54)(cid:16)(cid:69)(cid:82)(cid:91)













(cid:40)(cid:89)(cid:72)(cid:3)(cid:54)(cid:16)(cid:69)(cid:82)(cid:91)

(cid:37)(cid:82)(cid:69)(cid:3)
	

"


!"

























(cid:37)(cid:82)(cid:69)(cid:3)(cid:85)(cid:72)(cid:70)(cid:82)(cid:89)(cid:72)(cid:85)(cid:86)(cid:3)
(cid:87)(cid:75)(cid:72)(cid:3)(cid:78)(cid:72)(cid:92)(cid:29)(cid:3)(cid:19)(cid:3)(cid:20)(cid:3)(cid:20)(cid:3)(cid:19)(cid:3)(cid:17)(cid:17)(cid:17)
(cid:15)(cid:15)(cid:15)



(cid:86)
(cid:36)(cid:79)(cid:76)(cid:70)(cid:72)(cid:3)(cid:74)(cid:72)(cid:81)(cid:72)(cid:85)(cid:68)(cid:87)(cid:72)(cid:86)(cid:3)
(cid:86)(cid:86)(cid:86)(cid:86)
(cid:92)(cid:92) (cid:29)(cid:73)(cid:72)(cid:68)(cid:87)(cid:88)(cid:85)(cid:72)
(cid:68)(cid:3)(cid:85)(cid:68)(cid:81)(cid:71)(cid:82)(cid:80)(cid:3)(cid:78)(cid:72)(cid:92)(cid:3)(cid:29)(cid:3)
(cid:92) (cid:29)
(cid:3)(cid:3)

(cid:19)(cid:3)(cid:20)(cid:3)(cid:20)(cid:3)(cid:19)(cid:3)(cid:17)(cid:17)(cid:17)(cid:3)

























(cid:41)(cid:72)(cid:68)(cid:87)(cid:88)(cid:85)(cid:72)(cid:86)(cid:3244)

















(cid:40)(cid:89)(cid:72)(cid:3)(cid:74)(cid:82)(cid:87)(cid:3)(cid:81)(cid:82)(cid:87)(cid:75)(cid:76)(cid:81)(cid:74)(cid:4)
(cid:15)(cid:15)(cid:15)



Figure 5: Main steps of TDS: channel sampling, S-box generation, key generation, key delivery. The Ô¨Ånal
step information reconciliation is not shown.

probabilistic technique, it fails occasionally. Figure 4 shows
that recall rate of information reconciliation reduces with
growing mismatched bits, even a large number of passes is
chosen. Therefore 10% mismatched bits for a 256-bit key
would cause huge time/communication cost and secret bit
loss.

More importantly, in reciprocal quantization, the two de-
vices have no ability to decide which bits to generate.
In
some cases, the generated key may have low entropy [8]. In
addition, it has been observed that near-by subcarriers of
OFDM may have correlated CSI measurements [28], which
reduces the security level of the generated keys.

As a conclusion, directly converting CSI or RSS sample
values to secret bits does not work.
It is the reason that
some existing work, such as ProxiMate [15] has to use FM
and TV signals which have very long wavelengths, rather
than WiFi signals, to generate robust secret keys.

3. PROTOCOL DESIGN

We present the design of our protocol TDS in this section.

3.1 Basic idea of TDS

Instead of asking all devices to perform quantization sepa-
rately, we allow one device, say Alice, to decide an arbitrary
key and distribute it to other legitimate devices with con-
Ô¨Ådentiality. Since extracted key of Calvin are identical to
Bob‚Äôs, we use Alice, Bob and Eve to sketch our idea shown
in Figure 5, which includes the following steps:

1) Channel sampling. The users Ô¨Årst place Alice and
Bob and the distance between their NIC cards is < 5cm.
A user then starts the TDS program on Alice and makes
Alice an initiator. Alice sends a message to other devices
and ask them (including Alice) to start listening to a same
public WiFi source. Current WiFi standard uses orthogonal
frequency-division multiplexing (OFDM) and there are 56
orthogonal subcarrier signals to carry data on parallel data
streams. Hence at a same time, the CSI measurement of a
WiFi source includes up to 56 sample values from diÔ¨Äerent

sub-carriers. Figure 5 shows samples of amplitude values
from three sub-carriers of a same WiFi source. Note that
Alice and Bob have highly correlated sample values, but
Eve‚Äôs measurement is very diÔ¨Äerent to theirs.

2) S-box Generation. After obtaining enough number
of samples, Alice will ask other devices to synchronize the
sampled data. Then each device will construct an S-box,
which includes a number of blocks. Each block contains a
number of samples and represents a bit 0 or 1. Note blocks
are organized in pairs. In Figure 5 we show the Ô¨Årst four
pairs of blocks of each S-box, representing four 0-bits and
four 1-bits. Later we will introduce the mechanism that
guarantees every legitimate device will generate an S-box
in which the samples in the blocks are consistent to Alice‚Äôs
S-box.

3) Key generation. Alice may use any sophisticated
key generation method to determine a strong secret key with
high randomness and entropy. In the Figure 5 example, she
uses a key starting with 0110.

4) Key delivery. For every bit of the key, Alice select a
block from every pair to represent whether this bit is 0 or 1.
For example, in Figure 5 the Ô¨Årst four bits are 0110. Hence
Alice selects the Ô¨Årst 0-block, the second 1-block, the third
1-block and the fourth 0-block. Then Alice broadcasts these
blocks to other devices. Since Bob‚Äôs measurement is similar
to Alice‚Äôs, Bob can obtain a similar S-box. When Bob re-
ceives the blocks sent from Alice, it can easily recover these
blocks to a bit stream. Bob only needs to decide whether the
ith block is more similar to his ith 0-block or his ith 1-block.
Eve, which is out of the safe distance from Alice, cannot
obtain an S-box with any correlation to Alice‚Äôs. Even if Eve
can hear all blocks sent from Alice, she is not able to match
any block to a 0-bit or 1-bit.

5) Information reconciliation. Finally, Alice and Bob
need to ensure that they obtain a same key and correct the
mismatch bits, which are very few in TDS. TDS uses an in-
formation reconciliation method, as presented in prior work
[3, 28]. Note that the protocol has a threshold T such only

619t

i

n
e
c
i
f
f

e
o
c
 
n
o

i
t

l

a
e
r
r
o
C

1

0.5

0

-0.5

-1

1

10

5
25
CSI subcarrier index

15

20

0.03

y
t
i
l
i

b
a
b
o
r
P

0.02

0.01

30

0

1

80

40
Singular value 

120

%D
%E
%F







\
W
L
O
L

E
D
E
R
U
3

ŒîœÉA
ŒîœÉA




7KHGLIIHUHQFHRIVLQJXODUYDOXH









150

180

210

90

120

60

  40

  20

240

300

270

30

0

330

Figure 6: CSI correlations

Figure 7: Distributions of
ÀÜœÉ2

Figure 8: Distributions of
ŒîÀÜœÉ2

Figure 9: Feature distri-
butions of two group sets

a device with error bits fewer than T can start information
reconciliation with Alice.

3.2 Sampling and S-box generation

All devices measure the CSI samples simultaneously using
an existing synchronization protocol. Note that complete
synchronization is not necessary, as long as all three devices
can have a large number of CSI samples in common. For
example, Alice can send a sequence of samples and ask all
devices to construct their S-boxes after this sequence.

3.2.1 Block and group allocation
Block allocation divides all CSI measurement samples into
blocks representing 0 and 1 bits. Therefore if Alice wants
to deliver a 256-bit key, she should construct at least 256
pairs of blocks Ô¨Årst and then use a block from every pair to
present the bit value. The intuition to use a block of samples
rather than a single one is to reduce the mismatch rate. The
block size n inÔ¨Çuences the performance of key delivery. A
small n leads to unstable blocks whose features are prone to
the ambient noise, while a large n reduces the eÔ¨Éciency of
key delivery. Based on our empirical results, we select n = 6
in our implementation for WiFi.

For OFDM signals, each sample includes m subcarriers
and each subcarrier has one CSI value. Therefore, one block
has m ‚àó n CSI values, which are divided into two groups.
And then, the features of these two groups represent 0 and
1 respectively. Group allocation is challenging due to the
following two main requirements.

Reliability Requirement (R1): The features of two
groups in a same block, representing 0 and 1 respectively,
should be suÔ¨Éciently distinct to each other, to avoid mis-
matched bits.

Security Requirement (R2): The features from all 0-
groups and 1-groups should be identically distributed across
diÔ¨Äerent groups. Otherwise given a feature, an eavesdrop-
ping could improve its guess on the bit by studying the dis-
tributions of 0-groups and 1-groups.

We reuse each measurement sample in S-box generation to
improve the utilization of measurement results and reduce
channel measurement time. Assuming there are N samples,
we use the following construction method:

1. Every n successive samples are put into one block, for

i ‚àà {1 : (cid:5) N

n

(cid:6)}.

^∆µƒèƒêƒÇ∆å∆å≈ùƒû∆å∆ê
4
5

1

2

3

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

*D

*0

*E

*1

*F

2 ‚Äî 1

4 ‚Äî 2

6 ‚Äî 3

3 ‚Äî 2

6 ‚Äî 

9 ‚Äî 6

Figure 10: Group allocation

20 ‚Äî 10

30 ‚Äî 20

2. In addition, for j = 1 : (cid:5) N

(cid:6), the jth, (n + j)th, ¬∑¬∑¬∑ and

(cid:6) ‚àí1)n + j)th samples are put into one block.

n

(((cid:5) N

n

The number of blocks is about 2N/n. Using Intel 5300
NIC, each sample includes 30 CSI amplitude values from 30
subcarriers.3 Hence each block is a 30 √ó n matrix.

To represent 0 and 1, we divide a block into two groups. In
each block, we denote the measurements of the ith subcarri-
er as Si, a vector including n values. An intuitive solution is
to let G0 = {S1, S3, S5, .., S29} and G1 = {S2, S4, S6, .., S30},
where G0 represents 0 and G1 represents 1. We Ô¨Ånd that
this allocation does not satisfy the reliability requirement
R1. From our experiments, we Ô¨Ånd an important property
of CSI samples from diÔ¨Äerent subcarriers. The adjacent sub-
carriers have very strong CSI correlation, and the correlation
oscillates with increasing the diÔ¨Äerence of two subcarriers‚Äô
indexes. Figure 6 shows the correlation between two diÔ¨Äer-
ent subcarriers. The yellow curve plots the CSI correlation
between the 1st subcarrier and the xth subcarrier. The 1st
subcarrier has strongest correlation with 2nd subcarrier, and
has little correlation with 11th subcarrier. Red and green
curves plot the correlation about 15th and 30th subcarriers
to the xthh subcarrier respectively. The diÔ¨Äerence between
any pair of subcarriers that are with a Ô¨Åxed diÔ¨Äerence of in-
dexes is very close. For example, subcarrier pairs {2, 4} and
{7, 9} will have a similar diÔ¨Äerence, i.e., S2 ‚àí S4 ‚âà S7 ‚àí S9.
Given the above observations, the group allocation G0 =
{S1, S3, S5, .., S29} and G1 = {S2, S4, S6, .., S30} will result
in similar G0 and G1.
It is because S1 and S2 are very

3Technically there are 56 subcarriers (52 data subcarriers
and 4 pilots) for 802.11n, but the current CSI tool can only
provide 30 of them.

620close, S3 and S4 are close, and so on. As the consequence,
the groups for 0-bit and 1-bit are not distinct. Similar-
ly, the group allocation G0 = {S1, S2, .., S15} and G1 =
{S16, S17, .., S30} is also not acceptable, because S16 ‚àí S1 ‚âà
S17 ‚àí S2 ‚âà .. ‚âà S30 ‚àí S15.

We then attempt to select subcarriers with varying in-
tervals among them. For every block, we construct three
groups, Ga = {S1, S2, S3,¬∑¬∑¬∑ , S10}, Gb = {S2, S4,
¬∑¬∑¬∑ , S20}, and Gc = {S3, S6, S9,¬∑¬∑¬∑ , S30}. These three group-
s show signiÔ¨Åcant diÔ¨Äerence and then can be used to repre-
sent diÔ¨Äerent bit values.

3.2.2 Feature extraction
Each group Ga, Gb, or Gc is then an m √ó n matrix. In
our implementation m = 10, n = 6. To eÔ¨Éciently deliver the
secret key to other devices, Alice will send a feature repre-
senting the block of the bit rather than the entire matrix.
Due to the noise interference, CSI variations among Alice
and other close devices always exist. In TDS, we leverage
the singular value decomposition (SVD) to solve this issue.
SVD provides a convenient way to characterize a matrix.
Each group G is expressed as Gm√ón = Um√óm ÀÜŒ£m√ónV T
n√ón,
where the diagonal matrix ÀÜŒ£ is uniquely determined byG .
The diagonal elements of ÀÜŒ£, ÀÜœÉ1, ÀÜœÉ2, ..., ÀÜœÉn (assuming n ‚â§ m),
are called singular values. In TDS, we extract the feature
from ÀÜŒ£ to characterize each group.
It is well known that
large singular values preserve the internal properties of a
matrix in a low dimensional space [9]. We propose to use
the second and third largest singular values in each group,
denoted as ÀÜœÉ2 and ÀÜœÉ3, as the feature of the group that will be
broadcast by Alice instead of the whole matrix. We do not
use the largest singular values in each group because empir-
ical results show that they are hard to diÔ¨Äerentiate. After
receiving ÀÜœÉ2 and ÀÜœÉ3 from Alice, Bob will compare them with
the singular values of his G0 and G1 groups and determine
whether this bit is 0 or 1. The small singular values is mainly
due to noise in the data, which are discarded.

Unfortunately, the above features cannot satisfy the secu-
rity requirement. Figure 7 plots the distributions of singular
value ÀÜœÉ2 of three types of blocks Ga, Gb, and Gc. We Ô¨Ånd
that their distributions are distinct, although there is still
a large overlapped area. However, utilizing this knowledge,
an eavesdropper can improve its guess on the value of this
bit, given the singular value it received. For example if it
receives a large singular value ÀÜœÉ2, then it is more likely to
represent Gc.

3.2.3 Final feature computation
The Ô¨Ånal solution to select a feature that satisfying all
requirements speciÔ¨Åed in Subsection 3.2.1 is presented as
follows. For every block of samples constructed, we Ô¨Årst
compute Ga, Gb, and Gc and compute their 2nd and 3rd
largest singular values: ÀÜœÉa
2, ÀÜœÉb
3. We
let two diÔ¨Äerence values (ŒîÀÜœÉ0
3) to represent the bit 0
and (ŒîÀÜœÉ1
2, ŒîÀÜœÉ1
3) to represent the bit 1 as shown in Figure
2 ‚àí
10, where ŒîÀÜœÉ0
2 = ÀÜœÉb
3 ‚àí ÀÜœÉb
ÀÜœÉb
2, and ŒîÀÜœÉ1
3. Figure 8 shows the distributions
of ŒîÀÜœÉ0
2. We can Ô¨Ånd that their distributions are
almost identical. The distributions of ŒîÀÜœÉ0
3 are
also identical, which is not shown. In this way, the attacker

3 , ÀÜœÉb
2, ŒîÀÜœÉ0

3 and ŒîÀÜœÉ1

2 and ŒîÀÜœÉ1

2, and ÀÜœÉc

3 ‚àí ÀÜœÉa

2 ‚àí ÀÜœÉa

2 = ÀÜœÉc

2 , ŒîÀÜœÉ0

3 = ÀÜœÉb

3 , ŒîÀÜœÉ1

3 = ÀÜœÉc

2 , ÀÜœÉa

3, ÀÜœÉc

cannot improve its guess of a bit based on the feature sent
from Alice.
3.3 Key generation and delivery

Key generation. Alice, the initiator, is in charge of
generating a key with strong randomness, using any existing
algorithm. The bit string for the secret key should be (1)
suÔ¨Écient long, i.e., more than 128 bits in common, and (2)
statistically random.

Feature pairing. After computing the features for 0/1
bits and generating the key, TDS needs to perform feature
pairing, i.e., choosing one from features of 0-bit and one from
features of 1-bits and making them a pair to represent a bit.
The simplest solution is to make the two features computed
from a same group of samples to be a pair. However, one
disadvantage is that it is possible that in some pairs the
two features are close and hence make it easier to produce
mismatched bits. Hence this feature pairing step is to Ô¨Ånd an
optimal strategy of making the diÔ¨Äerence of feature values
for each 0/1 pair larger than a certain threshold Œ∏.

We take a paring algorithm based on Max-Weighted Bi-
partite Matching to solve this problem. We assemble all the
features extracted from G0 and G1 into two sets C 0
f and C 1
f
to represent 0 and 1 bits respectively. The above problem
can be formalized as a Max-Weighted Bipartite Matching
problem. Then we can leverage Kuhn-Munkras algorith-
m [10] to solve this problem, and map the 0 and 1 bits to
the features.
f √ó
We construct a complete bipartite graph G(C 0
f ) with weights w(eij) =|c 0
|. The feasible vertex
C 1
(cid:3)
labeling l is deÔ¨Åned as

‚àí c1
(cid:4)

f , C 1

f , C 0

(cid:2)

fj

fi

l(c0

fi ) = max w

c0
fi

, c1
fj

l(c1

fj ) = 0

‚àÄc0
‚àÄc1

fi

‚àà C 0
‚àà C 1

f

f

fj

The Equality Subgraph Gl is a spanning subgraph of G

which is deÔ¨Åned as

Gl = {(xi, yj)|Gl ‚äÜ G, w (xi, yj) = l (xi) +l (yi)}

(1)

where

(cid:5)

xi ‚àà X ‚äÜ C 0
yj ‚àà Y ‚äÜ C 1

f

f

The algorithm execution time is much shorter than CSI

measurement time.

b

c

and S‚àí1

Key delivery and information reconciliation. To
represent the sequence of generated bits Ka whose length is
l, Alice selects l features from l pairs in her S-box Sa. She
then sends the features to Bob and Calvin. Bob and Calvin
use their S-boxes S‚àí1
to decode the key. TDS uses
existing information reconciliation method [3] [28] to create
consistent keys on diÔ¨Äerence devices. After information rec-
onciliation, Bob‚Äôs key will be corrected to Alice‚Äôs. If there
are more than two devices, Alice will run information rec-
onciliation to every of them in order. Information reconcil-
iation includes an information-theoretically secure authen-
tication using universal hashing [17]. Secure authentication
can also defend against impersonation attack, in which an
attacker pretends to be Alice and send a sequence of feature
values, and substitution attack, in which an attacker replace
the correct feature values by other values. The process is

621Algorithm 1: KM based feature mapping
Input: C 0
Output: Perfect matching bipartite graph GL with

f ,C 1

f ,Œ∏;

maximum diÔ¨Äerence

1 Build Equality Subgraph GL via Equation (1);
2 Find the maximum matching graph Gl utilizing

3 for GL is not the perfect matching graph do
4
5
6

Hungarian algorithm [10];
S ‚Üê the free node in X;
H = hungarian trees of S;
f j|eij = (c0
T = {c1
S = S ‚à™ (X ‚à© H);
for ei,j is not an augmenting path do
f j(cid:2) , GL ‚Üê ei(cid:2),j(cid:2) ;

f j) ‚àà GL

f i /‚àà H};
c0

f i, c1

(cid:6)

end

S ‚Üê c0

f i(cid:2) , T ‚Üê c1

7
8
9
10 end
11 GD = {eij|eij ‚àà GL ‚àß eij < Œ∏};
12 GL = GL ‚àí GD;

called privacy ampliÔ¨Åcation [17]. Note that to preserve the
conÔ¨Ådentiality of the key, privacy ampliÔ¨Åcation will remove
some bits from the key after each round of parity check.
Hence in key generation, Alice can reserve some addition-
al bits for information reconciliation. For example, she will
generate 300 bits for a 256-bit secret key. Alice will termi-
nate information reconciliation after a speciÔ¨Åed number of
rounds. In fact, in our experiments, the bit error rate is very
low (< 0.01 for two devices within 4cm distance in outdoor
environments). Hence the cost of information reconciliation
is low.

4. ANALYSIS AND DISCUSSION

In this section, we discuss and analyze the security and

eÔ¨Éciency of TDS.
4.1 Security of TDS

The authenticity, conÔ¨Ådentiality, and integrity of TDS can
be guaranteed under the framework of information reconcil-
iation [3] [22]. In the cascade protocol [3], both Alice and
Bob have a version of a key and the two versions contain mis-
matched bits. They use parity checking via a public chan-
nel to correct the errors. The model completely describes
our protocol.
It has been shown that information recon-
ciliation is essentially source coding with side information.
The amount of information to be exchanged in optimal in-
formation reconciliation is the conditional Shannon entropy
and information reconciliation and privacy ampliÔ¨Åcation are
information-theoretically secure [22] [17]. We present the au-
thenticity and conÔ¨Ådentiality protection in other steps than
information reconciliation.

Authenticity. Eve, located out of the safe distance from
Alice, may want to pretend to be a legitimate device and
run information reconciliation. The authenticity is protect-
ed because Alice will only run information reconciliation for
a Ô¨Åxed number of rounds for every other device. Hence only
if the bit error rate is smaller than a reasonable threshold,
e.g., 7%, Eve can get the key obtained by Alice. According

to results in Section 5.3, the bit error rate of any device with
> 12cm distance from Alice is around 50%, the maximum
bit error rate. In addition, any bit exposed during informa-
tion reconciliation will be removed from the key. Hence Eve
cannot perform spooÔ¨Ång.

ConÔ¨Ådentiality. In addition to the above framework, we
need to demonstrate that the singular values broadcast by
Alice reveal no information about the secret bits. As shown
in Figure 8, the singular values of 0-blocks and 1-blocks have
identical distributions. Hence given two singular values, the
eavesdropper still cannot improve its guess on this bit.
4.2 Predictable channel attack

A signiÔ¨Åcant concern about reciprocal quantization is that
an adversary can use deliberately planned movements to
generate desired or predictable changes in the channel be-
tween the legitimate devices. Unfortunately prior works can-
not defend against such a predictable channel attack [8].

TDS does not use reciprocal quantization. The key of TD-
S is generated by Alice using sophisticated algorithms. Even
if the adversary performs deliberate actions, e.g., interfere
the channel, it cannot yield any predictable patten on gen-
erated key bits. We should guarantee that the key delivery
process is also resilient to the predictable channel attacks.
TDS uses S-box for key delivery, in which the features used
to represent secrete information should be unpredictable.
As we discussed above, the features representing 0s and 1s
are independent and identically distributed. After block al-
location, the measurements have been suÔ¨Éciently diÔ¨Äused
and confused, as to meet the Shannon‚Äôs diÔ¨Äusion and con-
fusion properties in conventional cryptography ciphers. In
this case, the adversary cannot generate a predictable pat-
tern over the measurements in TDS‚Äôs blocks, even if she is
able to manipulate predictable patterns in the channel by de-
liberate actions, such as blocking the channel periodically.
Therefore, TDS can eÔ¨Äectively defend against predictable
channel attacks. We will show our experimental study of
this point in Subsection 5.5.
4.3 Stability of KM based feature paring al-

gorithm

In Subsection 3.3, we have discussed the KM based feature
pairing algorithm, which can generate a maximum matching
graph.

In Algorithm 1, we discard all pairs whose diÔ¨Äerence is
less than Œ∏, which is about 5%.
In this section, we will
demonstrate that KM algorithm is stable, i.e., the remaining
graph excluding minimal edge is also a maximum matching
graph. We have no need to re-carry the Algorithm 1. Denote
the maximum weight of graph G before discarding to be
M , and the maximum weight after discarding edge ei0j0 ,
, to be M ‚àíw(ei0j0 ). Assuming that the maximum
named G(cid:2)
, we have M(cid:2) > M ‚àí w(ei0j0 ) ‚áí M <
weight of G(cid:2)
M(cid:2)
+w(ei0j0 ), i.e., there exists another matching weigh M(cid:2)
+
w(ei0j0 ) of G is larger than M . This result derived from that
assumption, obviously, is inconsistent with the fact that M
is the maximum weight of G. Hence, that assumption is
false and Algorithm 1 is stable.
4.4 Fault tolerance

is M(cid:2)

622Due to the presence of noises and manufacture variations,
there may be a diÔ¨Äerence of CSI measurements hi in the
ith sample, denoted as Œ¥i. When Œ¥ is larger than Œµ, ŒîÀÜœÉ
begins to incur mismatched bits, which leads to a wrong
information delivery. Using multiple samples in a block can
reduce the variance of the represented features. According
to Chebyshev inequality, we have P{|Œ¥ ‚àí E(Œ¥)| ‚â• Œµ} ‚â§ D(Œ¥)
Œµ2 .
Block-based information delivery can eÔ¨Éciently reduce the
variance of average Œ¥, and then reduce the secret bit error
rate.
TDS extracts the feature of block based on SVD. As afore-
mentioned in Section 3.2, the block size is 10 √ó n (typi-
(cid:7)Œ≤
cally n = 6). SVD can be expressed as G = U ÀÜŒ£V T =
i , where ÀÜœÉ is the singular value of G, and Ui,
Vi are the ith column vectors of U and V , respectively. The
is the ith sin-
power of noise isP N =
gular value of noise matrix. TDS uses the second or third
singular values ÀÜœÉ2 and ÀÜœÉ3 to represent the signal features
and discards the singular value smaller than ÀÜœÉ4 which are
mainly relevant to noises. Therefore, the noise is decreased
by

i )2 through SVD.

i=1 ÀÜœÉiUiV T

1 (œÉw

i )2, where œÉw
i

(cid:7)Œ≤

(cid:7)Œ≤

i=4 (œÉw

4.5

Information delivery rate

We use the number of delivered secret bits per sample as
the information delivery rate. In order to further improve
the information delivery rate, TDS can divide one block in-
to two orthogonal sets of samples to transfer two bits. In
Figure 6, we Ô¨Ånd that for a given subcarrier, the correla-
tions between it and other subcarriers vary gradually, and
there should be another subcarrier with the lowest correla-
tion coeÔ¨Écient, i.e. most uncorrelated to it. For example,
the correlation between the 1st subcarrier and the 13th sub-
carrier is almost zero. TDS divides all subcarriers two sets:
H1: ({1, 2,¬∑¬∑¬∑ , 10}, {1, 3,¬∑¬∑¬∑ , 19}, and {1, 4,¬∑¬∑¬∑ , 28}), and
H2: ({13, 14,¬∑¬∑¬∑ , 22}, {13, 15,¬∑¬∑¬∑ , 29, 1}, and{ 14, 17,
¬∑¬∑¬∑ , 29, 2,¬∑¬∑¬∑ , 11}). The distributions of ŒîÀÜœÉ in the two sets
are plotted in Figure 9. The blue and red points are the
ŒîÀÜœÉ0 and ŒîÀÜœÉ1 distributions in H1, while the black and green
points are the distributions in H2. These two sets are inde-
pendent. Their ŒîÀÜœÉ can be used to deliver two bits in one
block. Therefore, the delivery rate of TDS can be doubled.
In our system, we set n = 4 in mobile scenarios and n = 6
in static scenarios, and their delivery rate is 6
6 . That
is, each sample can conÔ¨Ådentially deliver 1.5 bits and 0.67
bit in mobile scenarios and static scenarios, respectively.

4 and 4

4.6 Distance constraint and multi-user key a-

greement

To agree on a shared secret key with reliability, all de-
vices need to be located close to each other. Therefore, the
authentication distance will impact the scalability of TDS.
TDS allows a key to be directly delivered from one device to
others, saving huge amount of overhead from interactive a-
greement. The requirement is that all devices are located in
the close proximity centered at the sender. When the num-
ber of legitimate devices increases, their distance between
each other may also increase due to space limit, which will
reduce the consistency of channel measurements due to fast
fading channel.

Table 1: Experiments scenarios

Index

A
B
C
D

State
Static
Static
Mobile
Mobile

Environment

Indoor
Outdoor
Indoor
Outdoor

Table 2: NIST statistical test results. To pass this
test, p-value must be greater than 0.01.

Test

Monobit Frequency
Longest Run of Ones

FFT

Approximate Entropy

Cumulative Sums (Fwd)
Cumulative Sums (Rev)

Block Frequency

Runs
Serial

A

0.611
0.724
0.553
0.708
0.530
0.787
0.725
0.734
0.421
0.590

B

0.757
0.660
0.848
0.897
0.776
0.749
0.819
0.723
0.401
0.530

C

0.900
0.861
0.757
0.899
0.905
0.955
0.874
0.883
0.841
0.913

D

0.784
0.883
0.752
0.719
0.681
0.919
0.977
0.846
0.885
0.642

In order to make TDS work well for many devices, e.g.,
more than three, we propose a new communication model
to beyond the space limitation.
Instead of using a public
wireless source, Alice and Bob ping each other to generate
symmetric random channel variations. Other legitimate de-
vices are located near Alice and Bob within authentication
distance to hear the communication between Alice and Bob.
This model can double the authentication space to support
key agreement for more users.

5.

IMPLEMENTATION AND EVALUATION
In this section, we present the prototype implementation,

experiment setup, and performance evaluation of TDS.
5.1 Methodology

We conduct extensive experiments with Ô¨Åve laptop com-
puters, named Alice, Bob, Calvin, Eve, and Peter. The
laptops are all equipped with commodity oÔ¨Ä-the-shelf wire-
less NICs model Intel 5300. Peter is conÔ¨Ågured as an AP.
The wireless connection among Ô¨Åve laptops operates in the
802.11n 2.4GHz channel. Antennas of Alice, Bob and Calvin
are located in less than 5cm (0.4Œª) distance, while Eve is
deployed at least 25cm (2Œª) away from Alice. As the AP,
Peter broadcasts beacons every 50ms. In two users mode,
Alice pings Bob every 50ms and receives Bob‚Äôs ACK after
1-5ms. Alice broadcasts Timing Synchronization Function
(TSF) timestamp to synchronize all legitimate devices with-
in 25 microseconds. Eve turns itself into the monitor mode
to be an eavesdropper.

We conduct our experiments in a large variety of envi-
ronmental settings and under diÔ¨Äerent scenarios as listed in
Table 1. In our experiments in static environments (A and
B), there is no line of sight between Alice and Bob, and all
the objects are keeping still.
In the other experiments in
mobile environments (C and D), with several intermediate

623F
D
C

1

0.8

0.6

0.4

0.2

0

"0" A
"1" A
"0" B
"1" B
"0" C
"1" C
"0" D
"1" D

-20 0

20 40 60 80

ŒîœÉ(cid:63)(cid:63)



(cid:63)
ŒîœÉ(cid:17)(cid:0)√≠ŒîœÉ(cid:16)
(cid:63)

Figure 11: Distribution
of ŒîÀÜœÉ0 and ŒîÀÜœÉ1

Figure 12: Distribution
of diÔ¨Äerences between
ŒîÀÜœÉ0 and ŒîÀÜœÉ1

objects, the presence or the absence of line of sight changes
with time. In diÔ¨Äerent scenarios, we use the following met-
rics for performance evaluation:

Bit generation rate is deÔ¨Åned as the number of secure bits
of the key over the overall time for key agreement. Note the
time is for the entire process including CSI measurement,
S-box construction, and key delivery.

Bit error rate is the number of mismatched bits over the

number of all bits generated.

Randomness and entropy is used to evaluate the quality
of keys. We measure the randomness of the keys generated
by TDS using the standard NIST test. We also compute the
entropy of the key generated.

All results are the average value from at least 20 indepen-

dent experiments.

50

0
<
œÉ
Œî

0

‚àí50
0

50

1
<
œÉ
Œî

0

‚àí50
0

50

50

100

Index

150

200

250

100

Index

150

200

250

Figure 13: The distribution of ŒîÀÜœÉ0 and ŒîÀÜœÉ1 for mul-
tiple users.

5.2 Randomness of key and block features

Since we assume Eve has complete information of the pro-
tocol, any non-random behavior in the bit sequences or block
features can be exploited by the adversary to reduce the
time-complexity of cracking the key.

Although Alice can generate an arbitrary key, the key may
also be slightly changed after privacy ampliÔ¨Åcation. We em-
ploy a widely used randomness test suit, NIST to verify the
randomness of the secret-bit generated by TDS. In this test,
we use 200 bit sequences generated from our experiments in
scenarios A, B, C, and D, and compute their p-values for 8
types of tests. According to the speciÔ¨Åcation in this suite, if
all p-values are greater than 0.05, the sequence is random.
We list the p-values of TDS in Table 2. From the results,

we Ô¨Ånd that the bit streams generated by TDS pass all the
tests with high values.

TDS uses ŒîÀÜœÉ to transmit secret information, ŒîÀÜœÉ0 and
ŒîÀÜœÉ1 is the feature of CSI measurements in one block used
to represent 0 and 1 respectively. They should have inde-
pendent and identical distribution to avoid information leak-
age. Figure 11 shows the distribution of ŒîÀÜœÉ0 and ŒîÀÜœÉ1 in
scenarios A, B, C, and D. The distributions in diÔ¨Äerent
scenarios are slightly diÔ¨Äerent. In the same scenario, ŒîÀÜœÉ0
and ŒîÀÜœÉ1 have extremely similar distributions. Therefore,
the adversary can hardly obtain any information from the
ŒîÀÜœÉ delivered in public wireless channels.

In addition, the diÔ¨Äerences between ŒîÀÜœÉ0 and ŒîÀÜœÉ1 for each
0/1 pair inÔ¨Çuence bit error rate. A large diÔ¨Äerentiation of
‚Äú0/1‚Äù for each bit will enhance the fault tolerance. We take a
paring algorithm based on Max-Weighted Bipartite Match-
ing to solve this problem. Figure 12 shows the distribution
of the diÔ¨Äerences between ŒîÀÜœÉ0 and ŒîÀÜœÉ1 for each 0/1 pair.
The diÔ¨Äerences for original 0/1 pair are nearly a linear dis-
tribution. There are about 9% pairs with the diÔ¨Äerences less
than 10. We introduce a Ô¨Åltered perfect matching method
to Ô¨Ålter the pairs with small diÔ¨Äerentiation.
5.3 How distance inÔ¨Çuences performance

Figure 14(a) shows the bit generation rate by varying the
distance between two devices (Alice and another receiver of
the key). We Ô¨Ånd that when the distance is smaller than
4cm, the bit generation rate is always higher than 100 bit-
s/sec. Hence it only takes a couple of seconds to get a
256-bit key. The bit generation rate in mobile scenarios
is higher than that in static scenarios. The bit generation
rate in outdoor environments is higher than that in indoor
environments.
It is because mobile and outdoor environ-
ments provide more channel diversity. Compared with an-
other method ProxiMate [15] that only generate a few bits
per second, the bit generation rate of TDS is higher by more
than an order of magnitude.

Figure 14(b) shows the bit error rate by varying the dis-
tance between devices, for ProxiMate and TDS. Even if the
distance of two device antennas is 1cm, the bit error rate
of ProxiMate is about 5%-10%. For TDS, when the dis-
tance is less than 3cm, the mismatch rate of TDS is 0 for
outdoor environments and < 0.015 for indoor environments.
When the distance is 5cm, the mismatch rate of TDS is still
smaller than 7%. We mark the authenticate distance and
safe distance in the Ô¨Ågure. Here the safe distance can be
set to 12.5cm but a user can easily check a much longer safe
distance such as 25cm or even 50cm. Out side of the safe dis-
tance, a device has bit error rate equal to 0.5, the maximum
bit error rate.

Figure 14(c) shows the parity check counts with increas-
ing the distance between devices, for ProxiMate and TDS.
The number of passes is 5. When the distance is more than
1cm, parity check counts of ProxiMate are larger than 130,
which might not work properly. For TDS, as long as the dis-
tance is less than 5cm, the parity check counts are less than
20 in both indoor and outdoor scenarios. The devices with-
in 5cm can achieve pairing without user intervention. For
large civilian or military transceivers, we may use external
antennas which can be easily placed in 5cm.

624200

150

100

50

)
c
e
s
/
s
t
i

b
(
 

t

e
a
r
‚àí

t
i

B

0

 

 

A
B
C
D

1 2 3 4 5 6 7 8 9 10

Alice‚àíBob distance (cm)

H

W

D
U

U
R
U
U
H


W
L

%

0.7
0.6

0.5

0.4

0.3

0.2

0.1

0

ProxiMate$
ProxiMate%

TDS$
TDS%

H
F
Q
D
W
V
G

L




Q
H
K

W

X
D

H
F
Q
D
W
V
G
H



L

I

D
V

s
t
n
u
o
c
 
k
c
e
h
c
 
y
t
i
r
a
P

100

50

150

0.03

y
t
l
i

b
a
b
o
r
P

0.02

0.01

ProxiMateB
ProxiMateA
TDSB
TDSA
8

10


œÉŒî(cid:0)
^

œÉŒî(cid:0)
^

ŒîœÉ^



Œî(cid:0)
œÉ^



1 2 3 4 5 6 7 8 9 1011121314

'HYLFHGLVWDQFHFP

0

 

2

4

Device distanceFP

6

(a) Bit generation rate of
TDS

(b) Bit error rate

(c) Rounds of parity checks

Figure 14: Key generation performance vs. distance for TDS & ProxiMate

0
‚àí40 ‚àí20 0 20 40 60 80 100

Feature value

Figure 15: Distribution-
s of the features without
and under attacks

5.4 Group key agreement

TDS supports group key agreement. For the situation
with more than two devices, devices adopt the new com-
munication model to deal with fast fading channel proposed
in Section 4.6. Figure 13 plots the distribution of ŒîÀÜœÉ0 and
ŒîÀÜœÉ1 for 4 users. Four colors of points represent four devices.
The points in the same column are ŒîÀÜœÉ0 or ŒîÀÜœÉ1 of four de-
vices for the same 0/1 pair. Two devices Alice and Bob are
30cm away from each other. Alice pings Bob every l00ms
and receives Bob‚Äôs ACK after 1-5ms. Calvin and Peter are
near to Alice and Bob within 4cm respectively. The ŒîÀÜœÉ0
and ŒîÀÜœÉ1 of four users are almost identical for the same bit,
which can be used to represent secret bits reliably among
the group.

(a)

I

S
C

40
30
20

(b)

(c)

(d)

)
1

/

0
(
s
t
i

B

/

)
1
0
(
s
t
i

B

)
1

/

0
(
s
t
i

B

1

0

1

0

1

0

20

40

60

80

100

120

140

160

180

200

20

40

60

80

100

120

140

160

180

200

20

40

60

80

100

120

140

160

180

200

20

40

60

80

100
Index

120

140

160

180

200

Figure 16: CSI measurements when an intermediate
object moving between Alice and Bob.

5.5 Robust against predictable channel attack
The attacker Eve can perform some deliberately planned
movements to block the LOS between Alice and Bob, such
that the bits extracted from the CSI measurements with
manipulated changes, in hope that it can predict the features
for 0 and 1 bits as well as the key.

Figure 16(a) shows that CSI measurements from the 1st
subcarrier display periodical changes under predictable chan-
nel attacks. The CSI values increase when Eve blocks LOS
or decrease when Eve moves away. Figure 16(b), (c) and (d)
plot the bits of the agreed key by reciprocal quantization,
TDS, and KEEP, respectively. The blue parts and white
parts represent ‚Äú1‚Äù and ‚Äú0‚Äù.

For reciprocal quantization, the generated bits present an
predictable pattern. When the channel is blocked, the bits

are generated as 0s, otherwise, they are 1s. In contrast, the
variations of extracted bits by KEEP and TDS are indepen-
dent of the blocking pattern. It is because TDS do not rely
on the channel condition to generate keys and KEEP ex-
tracts keys by randomly picking up discrete fragments from
all the subcarriers of OFDM. Therefore, an attacker can-
not infer the pattern of the secret bits by TDS based on his
interference pattern.

In addition, we should guarantee that the feature distri-
butions are also resilient to the predictable channel attack-
s. Figure 15 compares the distribution of delivering value
with/without predictable channel attack (denoted by ŒîÀÜœÉ(cid:2)
and ŒîÀÜœÉ, respectively). It reveals that the features represent-
ed 0s and 1s are almost identically distributed regardless of
predictable channel attack. This is because that the block
allocation suÔ¨Éciently diÔ¨Äuse and confuse the CSI measure-
ments. In this case, the adversary cannot generate a pre-
dictable pattern over those measurements, even if it is able
to manipulate predictable patterns in the channel by deliber-
ate actions, such as blocking the channel periodically. More
interesting, the distribution range of ŒîÀÜœÉ(cid:2)
grows wider, since
the predictable channel attack introduce more variance of
measurements. It increases the diÔ¨Äerence between ŒîÀÜœÉ(cid:2)0 and
ŒîÀÜœÉ(cid:2)1 for each bit, which improves fault-tolerance of S-box.
Therefore, TDS can eÔ¨Äectively defend against predictable
channel attacks.

5.6 Comparison of key extraction approaches
We compare TDS with existing key generation and agree-
ment approaches for mobile networks, including KEEP [28],
Mathur et al.
[16], ASBG [8], CGC [12]. Note these solu-
tions assume an authenticated channel between two devices.
Hence they are weaker in security than TDS. We align the
baseline of comparison as follows. In the scheme proposed
by Mathur et al., there are two parameters Œ± and m. We
set Œ± = 0.35 and m = 2 to ensure most fractions of mea-
surements are used for bit extraction. For ASBG, CGC, and
KEEP, we choose Œ± = 0.35 and fragment size is 50, where
the mismatch ratio is low. For TDS, we choose block size
Œ≤ = 6 in static scenarios and Œ≤ = 4 in mobile scenarios. The
distance between Alice and another device is within 4cm.

We compare the entropy of keys generated by diÔ¨Äerent ap-
proaches in Figure 17. The entropy can reÔ¨Çect the random-
ness of keys from the perspective of uncertainty. TDS and
KEEP have the highest entropy in all methods, and CGC
has the lowest. Figure 18 shows the bit error rates. In this

625y
p
o
r
t

n
E

1

0.8

0.6

0.4

0.2

0

0.04

e

t

0.03

a
r
 

h
c
t

a
m
s
M

i

0.02

0.01

A

B
C
6FHQDULRV

D

0

 

A

B
C
Scenarios

 




F
H
V

V
W
L

E



t

e
a
r
 
t
i

b

 
t

e
r
c
e
S

0

0

0

0

TDS
KEEP
ASBG
Mathur
CGC
D

40

30

20

10

0

s
t

n
u
o
c
 

n
o

i
t

a

l
i

c
n
o
c
e
r
 

n
o

i
t

a
m
r
o

f

n

I

A

B
C
Scenarios

D

A

B
C
Scenarios

D

Figure 17: Entropy of the
keys

Figure 18: Bit error rate

Figure 19: Secret bit gen-
eration rate

Figure 20:
reconciliation counts

Information

distance, TDS has no mismatched bit, while other methods
may cause around 2% to 4% mismatched bits. Figure 19
shows the bit generation rates. Obviously TDS has signiÔ¨Å-
cantly higher generation speed. Note the bit generation rate
of TDS is slower than previous results. It is because in this
set of experiments, Alice and Bob do not listen to a public
WiFi but use the communication among them for sampling.
This is the only model that the other protocols can work
but TDS is not restricted to it. Figure 20 shows the num-
ber of rounds for information reconciliation. Since there are
no mismatched bit, TDS only uses 4 times pass check to
guarantee the consistency of transmitted secret bits.

6. RELATED WORK

To ensure data conÔ¨Ådentiality, creating keys based on the
physical layer information of wireless channels is promising
due to its eÔ¨Éciency and security [18] [25] [5] [7] [26]. Most of
existing methods focus on pairwise key generation by mea-
suring the time-varying channel [11] [29] [21]. Exploiting
temporal and spatial variations of wireless channels, RSS
based techniques are widely used [16][20][8]. They tend to
transform the RSS values to a sequence of bits, and create
secrets based on the reconciled bits. However, RSS may vary
at diÔ¨Äerent receivers, so the key generation rate of RSS based
methods is low. For example, Radiotelepathy [16] extracts
secret keys using the channel impulse response (CIR) in the
wireless channel and its key generation rate is only around
1 bit per second. Pinpoint [27] can fast exchange informa-
tion exploiting CIR with reversed jamming noise between
two devices, yet with little scalability.

Contrast with RSS, CSI is much richer source of secret in-
formation. It can be obtained via the Orthogonal Frequency-
Division Multiplexing (OFDM). Liu et al. [14] theoretically
prove the feasibility of CSI and high key generation using
CSI. A practical CSI based key exaction system [12] has
been implemented which works in both static and mobile
environments. However, CSI measurements among adjacent
subcarriers have strong correlations, so the key generated
from nearby subcarriers also have correlation, which is vul-
nerable to key cracking attacks. To avoid such a risk, KEEP
[28] introduces a validation-recombination mechanism that
combines the information of all subcarriers and is resilient
to the key cracking attack.

In many applications, it is necessary to establish a col-
laborative key among a group of wireless devices. Key es-
tablishment concerning the shared group key is discussed in

[13]. In a group key establishment scheme, each node keeps
a matrix, which includes the values measured from all its
channels to its neighbors.

In summary, none of existing methods can achieve instant

and robust key agreement among multiple devices.

7. CONCLUSION

TDS is a device authentication and key agreement proto-
col that helps multiple devices to agree on a secret key in a
couple of seconds. Compared with prior solutions for mobile
networks, it has four important advantages: i) its key gen-
eration rate is faster by more than an order of magnitude;
ii) it supports more than two devices; iii) it can agree on an
arbitrary key with strong randomness; iv) it can eÔ¨Äective-
ly defend against predictable channel attacks. We conduct
rigorous analysis to show the feasibility and security of our
protocol. We also implement TDS in commodity oÔ¨Ä-the-
shelf WiFi devices. The experiment results demonstrate the
high eÔ¨Éciency and robustness of TDS. We believe the idea
of TDS can be extended in other communication scenarios.

8. ACKNOWLEDGMENTS

This work is supported by the National Natural Science
Foundation of China under Grant No. 61325013, 61190112,
61572396, and 61402359.

Chen Qian is supported by UC Santa Cruz Startup Grant

and National Science Foundation grant CNS-1464335.

Sheng Zhong is supported in part by the Jiangsu Province
Double Innovation Talent Program and in part by the Na-
tional Natural Science Foundation of China under Grant No.
61300235, 61321491, 61402223, and 61425024.

Xiang-Yang Li is partially supported by NSF ECCS-1247944,

NSF CMMI 1436786, NSF CNS 1526638, National Natural
Science Foundation of China under Grant No. 61520106007.

9. REFERENCES

[1] K. Argyraki, S. Diggavi, M. Duarte, C. Fragouli,

M. Gatzianas, and P. Kostopoulos. Creating secrets
out of erasures. In Proceedings of ACM MobiCom,
2013.

[2] B. Azimi-Sadjadi, A. Kiayias, A. Mercado, and

B. Yener. Robust key generation from signal envelopes
in wireless networks. In Proceedings of ACM CCS,
2007.

626[3] G. Brassard and L. Salvail. Secret-key reconciliation

by public discussion. In Proceedings of Advances in
Cryptology-EUROCRYPT, 1994.

[4] N. Cheng, X. Oscar Wang, W. Cheng, P. Mohapatra,
and A. Seneviratne. Characterizing privacy leakage of
public WiFi networks for users on travel. In
Proceedings of IEEE INFOCOM, pages 2769‚Äì2777.
IEEE, 2013.

[5] J. Croft, N. Patwari, and S. K. Kasera. Robust

uncorrelated bit extraction methodologies for wireless
sensors. In Proceedings of ACM/IEEE IPSN, pages
70‚Äì81. ACM, 2010.

[6] W. DiÔ¨Ée and M. Hellman. New directions in

cryptography. IEEE Transactions on Information
Theory, 1976.

from an unauthenticated wireless channel. In
Proceedings of ACM MobiCom, pages 128‚Äì139. ACM,
2008.

[17] U. M. Maurer and S. Wolf. Secret-Key Agreement
Over Unauthenticated Public Channels (cid:9)a(cid:6)lPart III:
Privacy AmpliÔ¨Åcation. IEEE Transactions on
Information Theory, 2003.

[18] R. Mehmood, J. W. Wallace, M. Jensen, et al. Key

establishment employing reconÔ¨Ågurable antennas:
Impact of antenna complexity. IEEE Transactions on
Wireless Communications, 13(11):6300‚Äì6310, 2014.

[19] M. Miettinen, N. Asokan, T. D. Nguyen, A. Sadeghi,

and M. Sobhani. Context-based zero-interaction
pairing and key evolution for advanced personal
devices. In Proceedings of ACM CCS. ACM, 2014.

[7] S. Gollakota and D. Katabi. Physical layer wireless

[20] N. Patwari, J. Croft, S. Jana, and S. K. Kasera.

security made fast and channel independent. In
Proceedings IEEE of INFOCOM, pages 1125‚Äì1133.
IEEE, 2011.

High-rate uncorrelated bit extraction for shared secret
key generation from channel measurements. IEEE
Transactions on Mobile Computing, 9(1):17‚Äì30, 2010.

[8] S. Jana, S. N. Premnath, M. Clark, S. K. Kasera,

[21] K. Ren, H. Su, and Q. Wang. Secret key generation

N. Patwari, and S. V. Krishnamurthy. On the
eÔ¨Äectiveness of secret key extraction from wireless
signal strength in real environments. In Proceedings of
ACM MobiCom, 2009.

[9] D. Kalman. A singularly valuable decomposition: the

SVD of a matrix.The college mathematics journal ,
27(1):2‚Äì23, 1996.

[10] H. W. Kuhn. The Hungarian Method for the

Assignment Problem. Naval Research Logistics,
52(1):7‚Äì21, 2005.

[11] L. Lai, Y. Liang, and H. V. Poor. A uniÔ¨Åed framework
for key agreement over wireless fading channels. IEEE
Transactions on Information Forensics and Security,
7(2):480‚Äì490, 2012.

[12] H. Liu, Y. Wang, J. Yang, and Y. Chen. Fast and

practical secret key extraction by exploiting channel
response. In Proceedings of IEEE INFOCOM, 2013.

exploiting channel characteristics in wireless
communications. IEEE Wireless Communications,
18(4):6‚Äì12, 2011.

[22] R. Renner and S. Wolf. Simple and tight bounds for
information reconciliation and privacy ampliÔ¨Åcation.
In Proceedings of ASIACRYPT, 2005.

[23] Z. Sun, A. Purohit, R. Bose, and P. Zheng. Spartacus:
Spatially-aware interaction for mobile devices through
energy-eÔ¨Écient audio sensing. In Proceedings of ACM
MobiSys, 2013.

[24] A. Varshavsky, A. Scannell, A. LaMarca, and

E. de Lara. Amigo: Proximity-based authentication of
mobile devices. In Proceedings of UbiComp, 2007.

[25] Q. Wang, H. Su, K. Ren, and K. Kim. Fast and

scalable secret key generation exploiting channel phase
randomness in wireless networks. In Proceedings of
IEEE INFOCOM, pages 1422‚Äì1430. IEEE, 2011.

[13] H. Liu, J. Yang, Y. Wang, and Y. Chen. Collaborative

[26] Q. Wang, K. Xu, and K. Ren. Cooperative Secret Key

secret key extraction leveraging received signal
strength in mobile wireless networks. In Proceedings of
IEEE INFOCOM, pages 927‚Äì935. IEEE, 2012.

Generation from Phase Estimation in Narrowband
Fading Channels. IEEE Journal on Selected Areas in
Communications, 30(9):1666 ‚Äì 1674, 2011.

[14] Y. Liu, S. C. Draper, and A. M. Sayeed. Exploiting

[27] T. Wang, Y. Liu, Q. Pei, and T. Hou.

channel diversity in secret key generation from
multipath fading randomness. IEEE Transactions on
Information Forensics and Security, 7(5):1484‚Äì1497,
2012.

Location-restricted services access control leveraging
pinpoint waveforming. In ACM Sigsac Conference on
Computer and Communications Security, pages
292‚Äì303, 2015.

[15] S. Mathur, R. Miller, A. Varshavsky, W. Trappe, and

[28] W. Xi, X.-Y. Li, C. Qian, J. Han, S. Tang, J. Zhao,

N. Mandayam. Proximate: proximity-based secure
pairing using ambient wireless signals. In Proceedings
of ACM MobiSys, pages 211‚Äì224. ACM, 2011.

[16] S. Mathur, W. Trappe, N. Mandayam, C. Ye, and

A. Reznik. Radio-telepathy: extracting a secret key

and K. Zhao. KEEP: Fast Secret Key Extraction
Protocol for D2D Communication.

[29] S. Xiao, W. Gong, and D. Towsley. Secure wireless

communication with dynamic secrets. In Proceedings
of IEEE INFOCOM, pages 1‚Äì9. IEEE, 2010.

627