Flexible and Scalable Digital Signatures in TPM 2.0

Liqun Chen
HP Laboratories
Bristol, UK

liqun.chen@hp.com

ABSTRACT
Trusted Platform Modules (TPM) are multipurpose hard-
ware chips, which provide support for various cryptographic
functions. Flexibility, scalability and high performance are
critical features for a TPM. In this paper, we present the new
method for implementing digital signatures that has been in-
cluded in TPM version 2.0. The core part of this method
is a single TPM signature primitive, which can be called by
diÔ¨Äerent software programmes, in order to implement sig-
nature schemes and cryptographic protocols with diÔ¨Äerent
security and privacy features. We prove security of the TPM
signature primitive under the static DiÔ¨Ée-Hellman assump-
tion and the random oracle model. We demonstrate how to
call this TPM signature primitive to implement anonymous
signatures (Direct Anonymous Attestation), pseudonym sys-
tems (U-Prove), and conventional signatures (the Schnorr
signature). To the best of our knowledge, this is the Ô¨Årst
signature primitive implemented in a limited hardware en-
vironment capable of supporting various signature schemes
without adding additional hardware complexity compared
to a hardware implementation of a conventional signature
scheme.

Categories and Subject Descriptors
K.6.5 [Management of Computing and Information
Systems]: Security and Protection

Keywords
TPM; Digital Signatures; Direct Anonymous Attestation

1.

INTRODUCTION

A Trusted Platform Module (TPM) is a hardware chip
used to provide veriÔ¨Åable attestation and integrity for a com-
puter platform and to also provide support for multiple cryp-
tographic functions necessary to implement data protection
in the platform. The implementation of these functions in
hardware has an advantage that it provides much better
tamper resistance than any software. But the disadvantage

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profi or commercial advantage and that copies bear this notice and the full cita-
tion on the firs page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior specifi permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS‚Äô13, November 4‚Äì8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11...$15.00.
http://dx.doi.org/10.1145/2508859.2516729.

Jiangtao Li

Intel Corporation

Portland, Oregon, USA
jiangtao.li@intel.com

of hardware implementation is that it usually costs more and
is less Ô¨Çexible than software implementation. Therefore, it
is essential to Ô¨Ånd a good balance between hardware and
software implementation, in order to achieve high security
using the minimum hardware resources.

TPMs can be made by any chip manufacturer, but to
be useful they must all obey standard protocols and use
a common interface. The speciÔ¨Åcation of these protocols
and interfaces has been developed by an industrial standards
body, namely the Trusted Computing Group (TCG). The
current version of the TPM speciÔ¨Åcation is 1.2 [30]. This
speciÔ¨Åcation is also available as the international standard
ISO/IEC 11889 [1]. TPMs implementing version 1.2 of the
standard have been embedded in hundreds of millions of
computing platforms.

TPM 1.2 only requires support for a small number of cryp-
tographic algorithms: SHA-1, HMAC, RSA signature and
encryption, AES1, one-time-pad with XOR for symmetric
encryption, and Direct Anonymous Attestation (DAA). As
the TPM becomes widely used, there is a need for more Ô¨Çex-
ible cryptographic algorithms being supported, because dif-
ferent countries and regions around the world have their own
standard cryptographic algorithms and therefore their own
diÔ¨Äering requirements for a cryptographic processor. With
a target of providing support for algorithm agility, the TCG
has developed a new version of TPM speciÔ¨Åcations (TPM
2.0), which is now available for public review [31].

One critical challenge when designing the new TPM spec-
iÔ¨Åcation is including multiple cryptographic functionalities
and Ô¨Çexibly selective cryptographic algorithms but ensuring
that the chip can be made cheaply and still have high perfor-
mance. In this paper, we describe how the digital signature
primitive in TPM 2.0 was developed.

This work is based on two observations: (1) In a complex
signature scheme, like DAA [5] and U-Prove [24], which we
aim to implement using TPM 2.0, the computation directly
using a private key is only a small part of the computa-
tion of the signature; (2) the computation using the private
key is a self-contained signature operation that can be used
by diÔ¨Äerent pieces of software to create diÔ¨Äerent/multiple
complicated signatures. Based on these two observations,
we designed a small signature primitive, which is imple-
mented within a TPM and can be called by a number of
other schemes and protocols. The starting point for this
work was the requirement that a TPM be able to support
three diÔ¨Äerent types of signature: conventional signatures,

1AES is optional for TPM 1.2 according on revision 116 of
the TPM 1.2 speciÔ¨Åcation, published on March 3, 2011.

37DAA signatures, and U-Prove signatures. All of them can be
based on Elliptic Curve Cryptography (ECC). Our goal was
to implement these signature schemes without more over-
head in hardware than implementing a conventional signa-
ture scheme, such as the Schnorr signature scheme [28].

In our scheme the signing functionality is protected by
the TPM, but the veriÔ¨Åcation function exists external to
the TPM. This is acceptable, because veriÔ¨Åcation does not
involve the private key and anybody is able to verify the
integrity of a signature for themselves. We transfer a major
part of the computation of the signing process to external
software and only keep a small core operation in the TPM.
The assurance of the scheme is not reduced by moving these
computations outside the TPM. The TPM is a principal
signer who holds the private key, the external software only
plays the role of a helper that does not have the key, and it
cannot forge a signature without the aid of the TPM.

The contributions of this paper are summarized as follows:
‚Ä¢ We design a new TPM signature primitive, denoted
by tpm.sign. It can be seen as a Schnorr type of signa-
ture scheme [28]. The special feature is that it has two
generators of a group - one is conventional and the
other is derived from a hash of an arbitrary integer.
Each generator is associated with a Schnorr signature.
The signing algorithm combines the two separated sig-
natures into one. We demonstrate how to implement
tpm.sign using a few simple TPM 2.0 commands. Most
of these commands are also used for other TPM func-
tions; as a result tpm.sign requires very little additional
TPM resources.

‚Ä¢ We conduct rigorous security analysis of tpm.sign. We
prove that tpm.sign is secure under the static DiÔ¨Ée-
Hallmen assumption in the random oracle model.

‚Ä¢ We present how to use tpm.sign to implement DAA
in TPM 2.0. Our implementation supports two diÔ¨Äer-
ent pairing-based DAA schemes using a single inter-
face. The DAA implementation no longer requires any
heavy, expensive and single purpose TPM commands
as used in TPM 1.2.

‚Ä¢ We present how to use tpm.sign to implement U-Prove
1.1 protocol in TPM 2.0. The U-Prove implementation
does not require any extra TPM resources, as it simply
reuses the TPM commands existing for DAA.

Although the proposed scheme was designed for TPM 2.0,
the central idea of the scheme, i.e. using a single hardware-
based signature to enable a variety of cryptographic pro-
tocols,
is not just useful for TPM, but can also beneÔ¨Åt
other applications; for example, DAA can be used to pro-
vide an anonymous announcement system in vehicular net-
works [15], and U-Prove can use a smartcard or mobile phone
for diÔ¨Äerent applications [24].
In the remainder of the paper, we will Ô¨Årst introduce the
TPM signature primitive, tpm.sign, in ¬ß2, including the se-
curity proof of this algorithm, which will be followed by
implementation details in TPM 2.0 in ¬ß3. After that we will
present the Ô¨Årst application of tpm.sign, which is DAA, in
¬ß4; our implementation supports two diÔ¨Äerent pairing-based
DAA schemes. We will further demonstrate that tpm.sign
can be used as the protected hardware device for Microsoft
U-Prove in ¬ß5. We will conclude our paper and discuss the
future work in ¬ß6.

2. THE TPM SIGNATURE PRIMITIVE
2.1 Functional Description

We Ô¨Årst describe the TPM signature primitive in TPM
2.0, denoted by tpm.sign. This is a Schnorr type of signa-
ture scheme, and has the following three procedures: key
generation, signing, and veriÔ¨Åcation. Only the key gener-
ation and signing procedures are implemented in TPM. In
the rest of the paper, we use the following notation: Let
G = (cid:2)g(cid:3) be a cyclic group of prime order p and g be a gen-
erator. Let H : {0, 1}‚àó ‚Üí Zp and HG : {0, 1}‚àó ‚Üí G be two
collision-resistent hash functions.
Key Generation This procedure selects a random x ‚Üê Z
‚àó
p
and computes y := gx. The secret key is x while the
public key is y.

Signing This procedure takes a message m ‚àà {0, 1}‚àó

, a
, and a group element P1 ‚àà G, and

string str ‚àà {0, 1}‚àó
calls the following two sub-procedures:
Commit Oracle (OC ) Given P1, str as input:

1. Verify that P1 ‚àà G.
2. If str = ‚àÖ, set P2 := 1 (the identity element
3. Choose a random integer r ‚Üê Zp.
4. Compute R1 := P r

of G), otherwise, compute P2 := HG(str).

2 , and K2 := P x
2

1 , R2 := P r

where x is the private key.

5. Output R1, R2, and K2.

Sign Oracle (OS) Given ch, m ‚àà {0, 1}‚àó

as input,

where ch = (R1, R2) for simplicity:2
1. Compute c := H(ch, m).
2. Compute s := r + cx mod p using r from the

commit oracle and delete r.

3. Output (c, s).

The signature on m is (P1, P2, R1, R2, K2, c, s). It is a
signature of knowledge

SPK{(x) :K 1 = P x

1 ‚àß K2 = P x

2 }(m).

VeriÔ¨Åcation This procedure takes the message m, the sig-
nature (P1, P2, R1, R2, K2, c, s), and K1 ‚àà G as input,
such that K1 = P x
It performs the
following steps:

1 and K2 = P x
2 .

1. If P1 = 1 and P2 = 1, return 0 (invalid).

2. Verify that H(R1, R2, m) =c.
3. Verify that R1 = P s

1 ¬∑ K

‚àíc
1

and R2 = P s

2 ¬∑ K

‚àíc
2 .

4. If any of the veriÔ¨Åcation steps fails, return 0 (in-

valid), otherwise return 1 (valid).

The veriÔ¨Åcation procedure relies on K1 = P x
1 and K2 =
P x
2 . If they are not guaranteed, then the signature can be
easily forged. In the TPM 2.0 implementation of U-Prove
and Schnorr signature, K1 is the public key y.
In DAA,
the discrete log between P1 and K1 can be veriÔ¨Åed by the
veriÔ¨Åer through other means. Note that K2 is a pseudonym
2In the TPM implementation of this oracle, ch could be a
hash of R1, R2, and other information.

38of TPM in the DAA and U-Prove schemes. If the same P2
is used, K2 is always the same for a private key x.

Observe that a special case of this signature algorithm
is the Schnorr signature. In the signing procedure, choose
P1 = g and str = ‚àÖ such that R1 = gr and R2 = K2 = 1.
In the veriÔ¨Åcation procedure, set P1 = g, K1 = y, and P2 =
K2 = 1. It is easy to see that R1 = gr = gs ¬∑ y
‚àíc
1
holds and the Schnorr signature can be veriÔ¨Åed successfully.
2.2 Security Notions and Proof

‚àíc = P s

1 ¬∑ K

To prove security of tpm.sign, we use the standard secu-
rity notion for digital signature schemes. We consider ex-
istential forgery where the goal of the adversary is to pro-
duce a valid signature on a message that he chooses. We
consider the chosen-message attack where the adversary is
given adaptive access to signatures on messages of his choice
while attempting to forge a signature. In the TPM 2.0 im-
plementation, the signing procedure is implemented using
two separate TPM commands, one for each sub-procedure.
Besides allowing the adversary to obtain signatures on the
messages of his choice, we allow him to directly query the
commit oracle OC and the sign oracle OS of his choice. For
example, the adversary can query OC a few times before
querying OS, or the adversary can modify ch to a diÔ¨Äerent
value before querying OS.

Definition 1

(Security Definition). The tpm.sign
scheme is secure if an existential forgery is computationally
impossible, if the adversary is given adaptive access to sig-
nature on messages of his choice and given adaptive access
to oracles OC and OS.

The security of our TPM 2.0 signature scheme depends

on the following static DiÔ¨Ée-Hellman (DH) problem.

Definition 2

(Static DH Oracle). Let G be a cyclic
‚àó
group of prime order p. Let x be a value in Z
p. Given any
P ‚àà G, the static DH oracle on x computes and outputs P x.
(Static DH Problem). Let G be a cyclic
group of prime order p. Given g, h ‚àà G such that h = gx, the
static DH problem is to compute x given access to a static
DH oracle on x.

Definition 3

Lemma 1

(The Forking Lemma). Let A be a proba-
bilistic polynomial time turning machine. Let Q and R be
the number of queries that A can ask to the random or-
acle and the number of queries A can ask to the signer,
respectively. Assume that within a time bound T , A pro-
duces a valid signature (m, œÉ1, h, œÉ2) with probability  ‚â•
10(R + 1)(R + Q)/2k. If the triples (œÉ1, h, œÉ2) can be simu-
lated without knowing the secret key, with an indistinguish-
able distribution probability, then there is another machine
which has control over the machine obtained from A replac-
ing interaction with the signer by simulation and produces
(cid:3)
two valid signatures (m, œÉ1, h, œÉ2) and (m, œÉ1, h
2) such
that h (cid:10)= h
(cid:3) ‚â§ 120686QT /.

in expected time T

, œÉ

(cid:3)

(cid:3)

Theorem 2. The tpm.sign scheme is secure under the se-
curity deÔ¨Ånition in DeÔ¨Ånition 1 in the random oracle model
under the static DH assumption.

Proof. Suppose there is an adversary A that breaks the
tpm.sign scheme above, i.e., A outputs a forged signature
(m, P1, P2, R1, R2, K2, c, s) after given access to signatures
on messages of its choices and access to oracles OC and OS.
We can construct an algorithm B which makes use of A to
solve the static DH assumption. B is given a pair (g, h = gx),
where B can access the static DH oracle on x in polynomial
time. That is, B can sends any P ‚àà G to the static DH
oracle and obtains P x back. The goal is for B to compute
the private key x. Algorithm B works as follows.
Key generation: B sets h as the public key and outputs it
to A and sets logg h as the corresponding private key
x, although B does not know x.
Signature Query: If A makes a signature query on m with
P1 and str as input, B computes P2 := HG(str) and
queries the static DH oracle with P1 and P2 and ob-
2 back. B chooses at ran-
tains K1 = P x
dom c and s and computes R1 := P s
and R2 :=
2 . B patches the random oracle such that c :=
2 ¬∑ K
‚àíc
P s
H(R1, R2, m). B outputs (m, P1, P2, R1, R2, K2, c, s)
as the signature. Observe that the distribution of this
simulated signature by B is the same as the distribu-
tion of a real tpm.sign signature.

1 and K2 = P x

1 ¬∑ K

‚àíc
1

The static DH assumption is that it is computationally
infeasible to solve the static DH problem. The static DH
assumption is a stronger assumption than the discrete log
assumption, as if one can solve the discrete log problem, then
he can solve the static DH problem as well. It is believed
in the cryptography community that the static DH problem
is a computationally hard problem. Several cryptographic
protocols rely on the static DH assumption, such as the basic
El Gamal encryption [19], Ford-Kaliski server-assisted key
generation protocol [21], and Chaum and van Antwerpen‚Äôs
Undeniable Signatures [12]. These protocols provide a static
DH oracle on the secret key to the adversary.

To prove security of the tpm.sign scheme, we Ô¨Årst re-
view the well-known forking lemma from Pointcheval and
Stern [26]. For a signature scheme based on three-pass
honest-veriÔ¨Åer zero-knowledge identiÔ¨Åcation protocol using
the Fiat and Shamir transformation [20], such as the Schnorr
signature [28], a signature of a message m is a triple (œÉ1, h, œÉ2),
where œÉ1 represents all successive ‚Äúcommitment‚Äù of the pro-
tocol, h = H(œÉ1, m) where H is a hash function, and œÉ2
represents all successive ‚Äúanswers‚Äù of the protocol.

Query on OC : If A makes a commit query on OC to B
with P1 and str as input, B computes P2 := HG(str)
and queries the static DH oracle with P1 and P2 and
2 , respectively. B
obtains K1 = P x
1 ¬∑
chooses at random c and s, and computes R1 = P s
2 . B outputs (R1, R2, K2). It
‚àíc
K
is easy to see that that this simulation of (R1, R2, K2)
is perfect.

1 and K2 = P x
2 ¬∑ K

and R2 = P s

‚àíc
1

Query on OS: If A makes a signing query on OS to B
with ch and m as input. B checks whether (ch, m) has
been queries before. If not, B sets c := H2(ch, m) and
outputs (c, s) where c and s were chosen in the com-
If (ch, m) has been queried before
mit oracle query.
and H2(ch, m) is diÔ¨Äerent from c in the corresponding
commitment query, B returns failure. Clearly, the sig-
nature (m, P1, P2, R1, R2, K2, c, s) generated from OC
and OS queries can be veriÔ¨Åed correctly by A. Fur-
thermore, the distribution of this simulated signature
by B is computationally indistinguishable with a real
tpm.sign signature.

39Forgery: After A makes the above queries, A outputs a
forged signature (m, P1, P2, R1, R2, K2, c, s) that can
be successfully veriÔ¨Åed. Using the forking lemma above
(Lemma 1), we can build another simulator B‚Äô such
that A outputs two valid tpm.sign signatures œÉ1 =
(m, P1, P2, R1, R2, K2, m, c, s) and œÉ2 = (m, P1, P2, R1,
R2, K2, c
1 . Since both signatures
can be veriÔ¨Åed, we have

). Let K1 = P x

, s

(cid:3)

(cid:3)

1 = P s
1 ,

(cid:2)
1 ,
(cid:2)
2 .

(cid:2)
1 = P s
(cid:2)
2 = P s

R1 ¬∑ K c
R1 ¬∑ K c
R2 ¬∑ K c
R2 ¬∑ K c
2 = P s
2 ,
and Œîs = s ‚àí s
Let Œîc = c ‚àí c
(cid:3)
(cid:3)
, we have K Œîc
1 = P Œîs
and K Œîc
2 = P Œîs
, where at least one of P1 and P2 is not
the identity element. The algorithm B‚Äô can compute
x := Œîs/Œîc where x = logP1 K1 = logP2 K2. In other
words, B‚Äô can compute the secret key x of the static
DH and break the static DH problem.

1

2

Observe that there is a loss of eÔ¨Éciency in the reduction, due
to possible failure in the query on OS. Since ch = (R1, R2), if
A follows the signing procedure, the chance of (ch, m) being
queried before is negligible. Therefore, under the static DH
assumption, the tpm.sign scheme is secure.

Although security of the tpm.sign scheme is proved under
the static DH assumption, in its implementation of TPM 2.0
there is no obvious way that an adversary can use the TPM
as a static DH oracle viaOC . This is because TPM computes
P2 = HG(str) rather than accepting any P2 value chosen by
the adversary. Whether security of tpm.sign can be proved
without the static DH assumption is an open question.

3.

IMPLEMENTATION OF tpm.sign

In this section, we present how the tpm.sign scheme is
implemented in TPM 2.0. We start with some relevant terms
and notation and then explain the commands that are used
to implement tpm.sign.
3.1 Terms and Notation

Throughout the paper, we use the notation shown in Ta-
ble 1. We now introduce a few terms, which will be used to
implement tpm.sign.

‚Ä¢ Key handle: If a key is associated with multiple com-
mands, the connection between these commands is pre-
sented as a key handle that uniquely identiÔ¨Åes the key.
A key handle is a 32-bit random value. The TPM as-
signs a key handle when a key is loaded into the TPM.
When the key is subsequently used in another com-
mand (or multiple commands), the handle is taken as
input for this command (or these commands). If more
than one key are involved in a command, all handles
of these keys are taken as input for the command.

‚Ä¢ Key name: The name of an asymmetric key is used for
identifying the key externally. It is a message digest
of the public portion of the key. It is usually used for
computing and verifying the integrity value of the key.
‚Ä¢ Key blob: For the reason of limiting TPM resources,
most TPM keys are not stored inside of the TPM.
Each key is stored outside of the TPM in a format
called a key blob, and it is associated with a parent

Notation
ek
epk/esk
tk
tpk/tsk
k.handle

k.name

kdf(s)
mack(m)

enck(m)
deck(c)
sigk(m)
(m)k
‚àí1
(c)
‚àó
k
(k)
enck1 (k2, m)
x(cid:12)y
x ‚Üê S
|x|

Descriptions
TPM endorsement key pair
public/private portion of ek
asymmetric key created by TPM
public/private portion of tk
handle of k used for identifying the key in-
ternally by a TPM
name of k used for identifying the key ex-
ternally
key derivation function using s as seed
message authentication code of m com-
puted using key k
encryption of m under public key k
decryption of c under private key k
signature of m signed under key k
encryption of m under symmetric key k
decryption of c under symmetric key k
key blob of k wrapped by another key
encryption blob of m under key k1 associ-
ated with key k2
concatenation of x and y
x chosen equally at random from a set S
bit size of x

Table 1: Notation used in this paper

key, say parentK, for the purpose of safe storage and
integrity check. For an asymmetric key pair, written
as tk = (tpk, tsk), the key blob includes the following
information: the private part of the key tsk encrypted
under the parent key, the public part of the key tpk,
and an integrity tag. The tag allows the TPM to verify
integrity and authenticity of the key and is achieved by
using a message authentication code (mac). Both the
encryption key sk and MAC key mk are derived from
parentK by using a key derivation function (kdf). In
the rest of this paper, a key blob of tk is denoted as
‚àó
(tk)
if we do not specify which key the parent key is.
The following is an example of a key blob of tk under
the parent key parentK:

(sk, mk) :=kdf (parentK),
‚àó
(tk)

:= (tsk)sk(cid:12)tpk(cid:12)macmk((tsk)sk(cid:12)tpk.name).

‚Ä¢ Encryption blob: Let k1 and k2 be two asymmetric
public keys of a TPM. To send a message m to the
TPM such that only the TPM possessing k1 and k2 can
release m to the host platform, we use the following
encryption blob which encrypts m. The encryption
blob has the following format
enck1 (k2, m) = (seed )k1(cid:12)(m)sk(cid:12)macmk((m)sk(cid:12)k2.name),
where seed is a random secret seed value, sk is a sym-
metric encryption key and mk is a message authentica-
tion key, both derived from seed . The encryption blob
is a KEM-DEM type of encryption over m. To release
the value m to the caller, the TPM must be satisÔ¨Åed
that both k1 and k2 have been loaded in the TPM.

3.2 The Relevant TPM Commands

All TPM functions are served by using a set of TPM com-
mands. Each command is speciÔ¨Åed by its input and output,

40and an operation between the input and output. Most of the
TPM commands have multiple options, regarding to diÔ¨Äer-
ent types of keys and applications. For simplicity, we only
explain these options which are related to the tpm.sign im-
plementation and its applications that will be discussed in
the later part of the paper. For the same reason, we may
also omit some input and output information if they are not
relevant to our purposes. The following TPM 2.0 commands
are used to implement the tpm.sign scheme.
3.2.1 Key Generation: TPM2 Create()
This command is used to generate a TPM asymmetric key
pair tk for tpm.sign. The command takes a handle of a parent
key (say parentK) and public parameters as input, creates a
fresh asymmetric key pair tk = (tpk, tsk), and outputs a
‚àó
wrapped key blob, denoted as (tk)
as described before. In
the remaining of the paper, we use

‚àó‚ÜêTPM2 Create()

(tk)

or

(tk)

‚àó‚ÜêCreate()

to denote this command and omit the information on how
tsk was encrypted by the parent key or which key is the
parent key. In the context of tpm.sign, to respond to this
command, the TPM performs the following steps:

1. TPM picks a random x ‚Üê Zp and computes y = gx,
where the values p and g are a part of the public pa-
rameters as described in Section 2.

2. TPM sets tpk := y, tsk := x, and tk := (tpk, tsk).

3. TPM wraps tk with the parent key and outputs a key

‚àó

blob (tk)

.

A variation of this command is TPM2 CreatePrimary(), in
which the private key tsk is derived from a primary seed of
the TPM using a key derivation function (kdf). A primary
seed is a secret key stored inside of the TPM. As a result,
the key tk is an alternative version of the primary seed. The
same primary seed can be used to create multiple keys. In
order to make each created key unique, some index value(s)
shall be used. For simplicity, in the remaining of this paper,
we will keep using TPM2 Create() only.
3.2.2 Load a Key into TPM: TPM2 Load()
When the TPM creates tk in TPM2 Create(), it does not
In order to use tk,
store a copy of this key internally.
the key has to be loaded into the TPM using the com-
mand TPM2 Load(). This command takes as input a parent
‚àó
key handle and a key blob (tk)
, which was created under
‚àó‚ÜêTPM2 Create(). The TPM veriÔ¨Åes integrity of the
(tk)
key. If the veriÔ¨Åcation succeeds, the TPM outputs a han-
dle (tk.handle) and the name (tk.name) for the key. In the
remaining part of the paper, we use

(tk.handle, tk.name)‚ÜêTPM2 Load((tk)
‚àó

)

or tk.handle‚ÜêLoad((tk)

‚àó

)

to denote this command. After TPM2 Load() has been called,
tk is now stored inside the TPM and can be used for future
operations.
3.2.3 Certify a TPM Key: TPM2 ActivateCredential()
To provision a certiÔ¨Åcate to the TPM key tk, the com-
mand TPM2 ActivateCredential() is used. Suppose that the
TPM has an asymmetric endorsement key pair ek, and an

authentic copy of the public portion of this key, epk, is acces-
sible to a CertiÔ¨Åcate Authority (CA). The TPM associated
computer platform sends tpk along with epk to the CA for
certiÔ¨Åcation. The CA checks that epk is a valid TPM en-
dorsement key, and then computes a certiÔ¨Åcate (say cert)
associated with tpk, generates a fresh symmetric encryption
key k, computes the encryption blob encepk(tpk, k) along
with the encrypted certiÔ¨Åcate (cert)k, and sends the encryp-
tion blob and encrypted certiÔ¨Åcate back to the platform.

The platform uses the TPM2 ActivateCredential() com-
mand to let the TPM decrypt and release the symmetric
key k, but the TPM will only respond to this command if
the TPM has the corresponding esk and the loaded tk. The
command has following input: a handle of ek, a handle of
tk, and an encryption blob encepk(tpk, k) of a secret key k.
The encryption blob has the following format

encepk(tpk, k) = (seed )epk(cid:12)(k)sk(cid:12)macmk((k)sk(cid:12)tk.name).

In the remaining part of the paper, we use

m‚ÜêTPM2 ActivateCredential(k1.handle, k2.handle, c)
or m‚ÜêActivateCredential(k1, k2, c)

to denote this command. In the content of tpm.sign m is the
symmetric key k, k1 is ek, k2 is tk and c is encepk(tpk, k).
Suppose that the TPM has both keys internally. To respond
to this command the TPM performs the following steps:

1. Decrypt (seed )k1 using k1 to obtain seed .
2. Derive sk and mk from seed , i.e., sk(cid:12)mk := kdf(seed ).
3. Retrieve k2.name and compute macmk((k)sk(cid:12)k2.name).
4. Check whether the computed mac value matches the

mac value in c.

5. If mismatch, return failure; otherwise, decrypt (k)sk

and output k.

3.2.4 Committing Process: TPM2 Commit()
As mentioned in Section 2, the signing procedure in tpm.sign

includes two phases: committing and signing. The commit-
ting process is achieved using the command TPM2 Commit().
This command is specially designed for a number of ap-
plications, including DAA (See Section 4) and U-Prove (See
Section 5). It causes the TPM to compute the Ô¨Årst part of
the tpm.sign signature operation.
It takes as input a key
handle of a signing key tk, a point P1 in G, a string ÀÜs, and
an integer ÀÜy , where ÀÜs and ÀÜy are used to construct another
point P2 in G, see below for details. The TPM outputs three
points R1, R2, K2, and a counter ctr to the host, where ctr
is used for identifying the random value r created by this
command. In the remaining part of the paper, we use

(R1, R2, K2, ctr )‚ÜêTPM2 Commit()
or (R1, R2, K2)‚ÜêCommit()

to denote this command. To respond this command the
TPM performs the following steps:

1. TPM computes ÀÜx := H(ÀÜs) where H is a collision-

resistant hash function, and sets P2 := (ÀÜx, ÀÜy).

2. TPM veriÔ¨Åes P1 and P2 are elements in G.
3. TPM chooses a random integer r ‚Üê Zp.

414. TPM computes R1 := P r

1 , R2 := P r

2 , and K2 := P x
2 .

5. TPM outputs R1, R2, K2 and ctr while keeping r in-

ternally.

Note that some input to this command can be empty. If
P1 is an empty Ô¨Åeld, then R1 is not computed. If s and ÀÜy
are empty, then R2 and K2 are not computed.

Signing Process: TPM2 Sign()

Note also that this command is slightly diÔ¨Äerent from
the description of tpm.sign in Section 2. In the command,
the value P2 is computed as P2 := (H(ÀÜs), ÀÜy), whereas in
the tpm.sign scheme, P2 := HG(str). This is because it
is expensive for TPM to implement a new hash function
HG. Given str, the host will compute ÀÜs an ÀÜy such that
HG(str) = (H(ÀÜs), ÀÜy), therefore the TPM does not need to
implement HG. Details can be found in Appendix A.
3.2.5
This command causes a TPM to sign a digest of a given
message, which is a hash output of the message. The com-
mand takes as input a handle of the signing key tk, a message
digest ch, and optionally a counter value ctr , and outputs a
signature œÉ on the message. The counter value ctr is only
needed when the sign command is called after executing a
commit command Commit(). Standard digital signature al-
gorithms can be used, such as RSA, EC-DSA, or EC-Schnorr
signatures. If a conventional signature scheme is used, then
there is no need to call the commit command. In the re-
maining part of the paper, we use

œÉ‚ÜêTPM2 Sign()

œÉ‚ÜêSign()

or

In the context of tpm.sign, the
to denote this command.
TPM responds this comment by performing the following
steps:

1. TPM computes c := H(ch, m), where m is the data

required to be signed.

2. TPM retrieves r from the commit command based on

the ctr value.

3. TPM computes s := r + c ¬∑ x mod p where x is the

private key tsk, and deletes r.

4. TPM outputs œÉ = (c, s).

In the description of Commit() and Sign(), we assume an
ideal implementation where the random value r created in
the commit command is stored inside the TPM. The value
r is deleted after the corresponding sign command has been
executed. However, for the resource-constrained TPM, such
implementation is too expensive. In the TPM 2.0 speciÔ¨Å-
cation, as suggested by David Wooten [32], the following
alternative method is used.

‚Ä¢ During each boot of TPM, a random seed value seed
is generated and stored. The TPM maintains a max-
imum counter value mctr (with initial value 0) and a
bit table T of N = 2n entries.

‚Ä¢ In each execution of the commit command, the TPM
increments mctr and sets ctr := mctr . The TPM de-
rives r from seed and ctr , i.e., r := kdf(seed , ctr ).
Let i be the least signiÔ¨Åcant n bits of ctr . The TPM
sets T [i] = 1. In the end of this command, the TPM
outputs ctr .

‚Ä¢ In the sign command with ctr as input, the TPM Ô¨Årst
veriÔ¨Åes that mctr ‚àí N < ctr ‚â§ mctr . Let i be the least
signiÔ¨Åcant n bits of ctr . The TPM then checks that
T [i] = 1. If all the veriÔ¨Åcation succeed, the TPM uses
the seed and ctr to re-generate r. The TPM then sets
T [i] = 0.

Using the above method, TPM does not need to save r for
each commit command. Observe that the TPM checks ctr ‚â§
mctr and makes sure the same ctr has not been used by the
sign command before, an attacker cannot query the future
ctr or re-use an old ctr value. In the rest of this paper, we
assume r is generated randomly instead of being derived for
the purpose of security analysis.

4. APPLICATION 1: DAA IN TPM 2.0

Direct anonymous attestation (DAA) is an anonymous
digital signature primitive, providing a balance between user
privacy and signer authentication in a reasonable way. In a
DAA scheme, there are issuers, signers and veriÔ¨Åers. The
role of an issuer is to verify legitimacy of signers and to is-
sue a unique DAA credential to each legitimate signer. A
signer proves possession of her credential to a veriÔ¨Åer by pro-
viding a DAA signature, which reveals neither of the DAA
credential nor the signer‚Äôs identity but allows the veriÔ¨Åer to
authenticate the signer.

The concept and Ô¨Årst concrete scheme of DAA were pro-
posed by Brickell, Camenisch, and Chen [5] for the purposes
of remote anonymous attestation of a trusted computing
platform. Security of their DAA scheme is based on the
Strong RSA problem.
In this paper, we call this scheme
RSA-DAA for short. This DAA scheme was designed as a
TPM function for the TCG and speciÔ¨Åed in the TPM speciÔ¨Å-
cation version 1.2 [30]. Since the Ô¨Årst introduction of DAA,
it has attracted lots of attention from both industry and
cryptographic researchers, e.g., [2, 3, 6, 7, 8, 9, 10, 13, 14,
16, 17, 22, 23, 27, 29].

Although the RSA-DAA scheme was adopted by the TCG
and included in the TPM 1.2 speciÔ¨Åcation ten years ago,
TPM vendors have never been happy with it. The major rea-
son is that the scheme is very expensive. In TPM 1.2 there
are two expensive and single purpose commands used to
implement the RSA-DAA scheme, namely DAA Join() and
DAA Sign(). The description of these two commands takes
about 10% space of the entire speciÔ¨Åcation of TPM 1.2. Fol-
lowing IBM software TPM 1.2 implementation, DAA takes
6.9% of total code space (see Section 4.6 for the details).
In the development of TPM 2.0, the functionality of DAA
is still required, as addressing privacy concerns is impor-
tant in a trusted computing environment. However, both
TPM users and vendors want a new DAA implementation
with minimum overhead and much higher eÔ¨Éciency than
the RSA-DAA scheme. This is one of the motivations of the
work described in this paper.

In this section, we demonstrate how to use the tpm.sign
scheme to implement DAA, which no longer requires any
heavy commands. We Ô¨Årst give a general description of
DAA, and then show that two existing pairing-based EC-
DAA schemes ([16, 10]) can be interpreted following this
description. After that, we demonstrate that the DAA Join
process and Sign process can be implemented using tpm.sign.
This application was the main motivation why we designed

42tpm.sign, and the result provides evidence that tpm.sign is a
Ô¨Çexible and scalable signature algorithm.
4.1 A General Description of DAA

As described in many DAA papers [5, 22, 9, 6, 17, 16, 10,
8], a DAA scheme involves a set of DAA issuers I, a set of
signers S and a set of veriÔ¨Åers V. Each signer comprises
a host platform and its associated TPM. A DAA scheme
DAA = (Setup, Join, Sign, Verify, Link) consists of the follow-
ing Ô¨Åve polynomial-time algorithms and protocols:

‚Ä¢ Setup: On input of a security parameter 1t, an issuer
i ‚àà I uses this randomized algorithm to produce its
secret key isk, public key ipk and the global public pa-
rameters param. param includes a list called RogueList
that contains rogue signers‚Äô secret keys. RogueList is
set as an empty list in Setup and will be updated ev-
ery time a rogue signer is discovered. Note that how to
Ô¨Ånd a rogue signer is out the scope of a DAA scheme.
We will assume that param are publicly known so that
we do not need to explicitly provide them as input to
other algorithms.

‚Ä¢ Join: This protocol is run between an issuer i ‚àà I and
a signer (t, h) ‚àà S, where t is a TPM and h is the
corresponding host. The protocol creates the TPM‚Äôs
secret key tsk and its DAA credential cre. The value
cre is a signature on tsk under isk and can be veriÔ¨Åed
under ipk. In this paper, we denote this signing and
veriÔ¨Åcation algorithms by i.sign and i.verify. The value
cre is given to both t and h, but the value tsk is known
to t only.

‚Ä¢ Sign: On input of tsk, cre, a basename bsn (the name
string of a veriÔ¨Åer v ‚àà V or a special symbol ‚ä•), a
message msg to be signed and optionally the veriÔ¨Åer‚Äôs
nonce nV for freshness, t and h run this protocol to
produce a DAA signature œÉ. More speciÔ¨Åcally, t cre-
ates a signature œÉt under tsk and h converts œÉt to œÉ
using cre. In this paper, we denote the TPM‚Äôs signing
algorithm and its corresponding veriÔ¨Åcation algorithm
by t.sign and t.verify.

‚Ä¢ Verify: On input of msg, bsn, and a candidate signa-
ture œÉ for msg and bsn. v ‚àà V uses this deterministic
algorithm to return either true (accept) or false (re-
ject). Note that if œÉ was created under a key listed in
RogueList, it will be rejected.

‚Ä¢ Link: On input of two signatures œÉ0 and œÉ1, v uses
this deterministic algorithm to return linked (linked),
unlinked (not linked) or ‚ä• (invalid signatures). Note
that, unlike Verify, the result of Link is not relied on
RogueList.

We now give a new interpretation of DAA, which will lead
us to implement two DAA schemes with the same TPM
algorithm, tpm.sign. In our interpretation, a DAA scheme
contains the following two underlying signature schemes that
intercommunicate to each other:

‚Ä¢ i.sign & i.verify: the DAA issuer‚Äôs signature and veri-
Ô¨Åcation algorithms. We use cre‚Üêi.sign(isk, tsk) to in-
dicate that a DAA credential cre is a signature on the
signed message tsk under the signing key isk. The cor-
rection of cre can be veriÔ¨Åed via accept‚Üêi.verify(ipk,

cre, tsk). This signature algorithm has the properties
of blinded signing and randomization. By these two
properties we mean the following:

‚Äì Given a commit value of tsk rather than tsk, the
issuer can create cre. This allows the issuer to
sign tsk without knowing this value.

‚Äì Given cre, one can randomize it to obtain another
satisfying accept‚Üêi.verify(ipk, cre
(cid:3)
,

(cid:3)
signature cre
tsk).

(cid:3)
‚Äì The issuer cannot tell whether cre

and cre are

signatures on the same tsk value or not.

‚Ä¢ t.sign & t.verify: the TPM‚Äôs signature and veriÔ¨Åcation
algorithms. We use œÉt‚Üêt.sign(tsk, bsn, (msg, nV )) to
indicate that a TPM part of the DAA signature is a sig-
nature on bsn, msg and nV under the TPM signing key
tsk. This signature has a property of user-controlled-
linkability, which has the following meanings:

‚Äì œÉt includes two parts œÉt = (œÉt,Œ±, œÉt,Œ≤).
‚Äì œÉt,Œ± is a deterministic signature on bsn under tsk.
If two signatures contains the same bsn and œÉt,Œ±
values, they show that these two signatures are
signed under the same tsk by the same TPM.

‚Äì œÉt,Œ≤ is a ‚Äúconventional‚Äù signature on (msg, nV ) un-
der tsk. Depending on a DAA scheme, œÉt,Œ≤ may
only available to the host h, not the VeriÔ¨Åer v.

A DAA signature is a proof of knowledge of two underlying
and œÉt,Œ±, in a signature format, denoted by:

signatures, cre

(cid:3)

SPK{(tsk, cre) : cre

(cid:3) ‚àß œÉt,Œ±}(msg, bsn, nV ).

Given the value cre and accessing to the TPM for t.sign,
the host is able to compute such a proof. However, with-
out accessing the TPM for t.sign, the host is not able to
do so. The tpm.sign algorithm described in Section 2 is an
implementation example of t.sign. In the next two subsec-
tions, we will explain how the LRSW-DAA scheme [16] and
SDH-DAA scheme [10] can be interpreted using the two un-
derlying signatures, i.sign and t.sign. As security of these
two DAA schemes have been analyzed in their original work
and we only suggest a new way to implement them, we do
not repeat the security proof of these two DAA schemes in
this paper. Our security analysis of tpm.sign in Section 2.2
proves that the host is not able to forge a tpm.sign signature;
this proof indicates that the new implementation does not
reduce security level of these two DAA schemes. This fol-
lows from the argument that except the host, from the view
point of any other entities of the DAA scheme (a DAA Is-
suer or a DAA VeriÔ¨Åer), a DAA signature created following
the TPM 2.0 implementation is identical to the one created
following the original schemes.
4.2 The LRSW-DAA Scheme

The above general description Ô¨Åts with the LRSW-DAA
scheme as follows (we keep the names of parameters as used
in [16]):

‚Ä¢ tsk = f and tpk = (P1, F ), where F = P f
1 .
‚Ä¢ cre = (A, B, C, D, u, v): as shown in the join protocol
of the DAA scheme in [8]; (A, B, C) is the CL sig-
nature [11] on f ; (u, v) is a Schnorr signature by the

43issuer; as a result, cre is a variety of the CL signature
on tpk, that allows the host to veriÔ¨Åes it without aid
of the TPM.

‚Ä¢ cre
(cid:3)

= (R, S, T, W, h, s): as shown in the sign/verify
protocol of the DAA scheme in [16]; (h, s) is a Schnorr
signature by the TPM. cre
is a blinded CL signature
on tsk.

(cid:3)

‚Ä¢ œÉt,Œ± = (J, K), where J is equivalent to P2 and K = J f

equivalent to K2 in tpm.sign.

‚Ä¢ œÉt,Œ≤ = (h, s).
‚Ä¢ SPK{(tsk, cre) :cre

(cid:3) ‚àß œÉt,Œ±}(msg, bsn, nV )

= (R, S, T, W, J, K, h, s).

4.3 The SDH-DAA Scheme

The above general description Ô¨Åts with the SDH-DAA
scheme as follows (again we keep the names of parameters
as used in [10]):

‚Ä¢ tsk = f and tpk = (h1, F ), where F = hf
1 .
‚Ä¢ cre = (A, x): cre is a signature on tpk (therefore on

tsk) that can be veriÔ¨Åed by, e(A, wgx

2 ) =e( g1F, g2).

‚Ä¢ cre
(cid:3)

holds e(T

= T = Aha
‚àíxhf

1 hax

(cid:3)
2: cre
2 , g2)e(h2, w)a = e(T, w)/e(g1, g2).

is a blind signature on tsk that

‚Ä¢ œÉt,Œ± = (J, K), where, similar to the LRSW-DAA scheme,
J is equivalent to P2 and K = J f equivalent to K2 in
tpm.sign.

‚Ä¢ œÉt,Œ≤ is only available to the host.
‚Ä¢ SPK{(tsk, cre) :cre

(cid:3) ‚àß œÉt,Œ±}(msg, bsn, nV )

= (J, K, T, c, sf , sx, sa, sb).

4.4 The TPM 2.0 DAA Join Process

There are two options for the TPM 2.0 join process. In the
Ô¨Årst option, the process is performed in the platform man-
ufacturing line, e.g., the DAA issuer is the Original Equip-
ment Manufacturer (OEM) of the platform. In this case, the
issuer knows that it is talking to a genuine TPM. The issuer
uses Create() to generate a DAA key, and then creates the
corresponding DAA credential for the TPM.

In the second option, the DAA join process is after the
platform has been shipped to an end user and the platform
has a certiÔ¨Åed manufacturing endorsement key, ek, which is
an asymmetric encryption key and its certiÔ¨Åcate is available
to the DAA issuer. This is a common situation. The Join
protocol, as shown in Figure 1, is run among a TPM t, the
corresponding host h and a DAA Issuer i. Suppose that the
host and the TPM know which key is a parent key and this
key is already available to the TPM. In our description, we
assume that this may be the TPM endorsement key ek. The
Join protocol has the following four steps. We refer each
step to its corresponding line numbers in Figure 1.

1. Create a DAA key (1-2). The host asks the TPM to
create a DAA key tk, by invoking Create(). The result
‚àó
is a key blob denoted by (tk)
wrapped by the parent
key.

2. Request a credential (2-7). The host contacts the is-
suer to request for a DAA credential by sending public
keys epk and tpk. The issuer validates epk and returns
back with an encryption blob a of a nonce c using epk
and tpk. The host loads the DAA key tk to the TPM
by using Load(). The host then asks the TPM to re-
lease the nonce c by using ActivateCredential(ek, tk, a),
in which the TPM veriÔ¨Åes the integrity of the cipher-
text a and returns the nonce c.

3. Prove key possession (8-11). The host asks the TPM
to sign the nonce c from the previous step by using
Sign(tk, c) on a conventional signature scheme. The
host then sends the signature œÉ and nonce c back to the
issuer. The issuer veriÔ¨Åes the nonce c from the previous
step and veriÔ¨Åes the signature. The issuer creates the
corresponding DAA credential cre = sigisk(tpk) using
its secret key isk and the TPM public key tpk. The
issuer then creates a session key k, an authentication
encryption of cre using k denoted as b, and creates an
encryption blob of k denoted as d. The issuer returns
back b and d.

4. Release the credential (11-12).

In order to ask the
TPM to release the session key k that was used to en-
crypt the credential cre, the host uses ActivateCredential
once again with input (ek, tk, d). After the host ob-
tains k from the TPM, it decrypts the credential cre
and veriÔ¨Åes its integrity.

4.5 The TPM 2.0 DAA Sign/Verify Process

The DAA Sign/Verify process involves three entities: a
TPM t, the TPM‚Äôs host h and a veriÔ¨Åer v. Suppose that
when the Sign/Verify protocol starts, these entities have al-
ready obtained the following necessary key materials and
other parameters. The TPM has a private storage key inter-
nally and this key is called a parent key, denoted by parentK.
The host has access to the DAA issuer‚Äôs public key ipk and a
‚àó
copy of the TPM‚Äôs DAA key blob (tk)
together with the as-
sociated credential cre. The veriÔ¨Åer has access to the DAA
issuer‚Äôs public key ipk and a list of rogue TPM‚Äôs private
keys RogueList. A DAA scheme allows the veriÔ¨Åer to detect
whether or not a given DAA signature was created by a key
in RogueList. Any signature signed by a key in RogueList will
be rejected. We assume that in advance the veriÔ¨Åer and host
have agreed a basename value bsn, a message msg and a ver-
iÔ¨Åer‚Äôs nonce nV , all of which will be signed in the protocol.
As shown in Figure 2, the Sign/Verify protocol has the fol-
lowing three steps. We refer each step to its corresponding
line numbers in Figure 2.

1. Pre-signing process (1). The host randomizes the cre-
dential cre to obtain cre‚Äô. As mentioned in Section 4.1,
given an arbitrary pair of cre and cre‚Äô values, Ô¨Ånding
whether or not they are associated to each other is
computationally infeasible. The host can make this
operation as pre-computation, since it is independent
to bsn, msg and nV .

2. Signing process (1-6). The host Ô¨Årst loads the key
‚àó
blob (tk)
into the TPM. The TPM decrypts the blob
using the parent key parentK and checks whether the
key is valid. If the check passes, the TPM creates a
key handle tk.handle and returns it to the host. The

44Host (h)
epk, ipk

Issuer (i)
isk, ipk, epk

tpk, epk-

a

If epk /‚àà Valid, return reject

Else c‚Üê{0, 1}|c|
a = encepk(tpk, c)

TPM (t)

esk

‚àó‚ÜêCreate()

(tk)

tk.handle‚ÜêLoad((tk)
‚àó

)

c‚ÜêActivateCredential(ek, tk, a)

w‚ÜêSign(tk, c)


request key

‚àó-

(tk)

(tk)

‚àó
tk.handle-
a

c -

c

w -

Entities
Keys

1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:

k‚ÜêActivateCredential(ek, tk, d)

d

k -

cre = (b)

‚àí1
k

c, w-

d, b

If c or w /‚àà Valid, return reject

Else k‚Üê{0, 1}|k|

, d = encepk(tpk, k)

cre = sigisk(tpk), b = (cre)k

Figure 1: The TPM 2.0 DAA Join protocol.

Entities

Keys
Be signed

TPM (t)
parentK

tk.handle‚ÜêLoad((tk)

‚àó

)

(R1, R2, K2)‚ÜêCommit(P1, ÀÜs, ÀÜy)

œÉt‚ÜêSign(tk, ch)

1:
2:
3:
4:
5:
6:
7:
8:
9:
10:

Host (h)
‚àó, cre, ipk
(tk)
msg, bsn, nV

cre

(cid:2)‚ÜêRandomize(cre)
Compute ÀÜs, ÀÜy

Compute ch

œÉ‚Üê(cre

(cid:2), œÉt)

œÉ -

(tk)

‚àó
tk.handle-
P1, ÀÜs, ÀÜy
R1, R2, K2-
ch

œÉt -

VeriÔ¨Åer (v)

ipk

msg, bsn, nV

If œÉ /‚àà Valid, return false

‚àÄf(cid:2) ‚àà RogueList

if (œÉ, f(cid:2), bsn) ‚àà Valid

return false
return true

Figure 2: The TPM 2.0 DAA Sign/Verify protocol.

host then computes the values ÀÜs and ÀÜy from bsn and
calls the Commit() command with the values ÀÜs, ÀÜy and
P1, where P1 is a part of ipk. The TPM responses
the command as Commit Oracle of tpm.sign described
in Section 2, and returns the values R1, R2 and K2.
The host then computes the value ch and calls the
Sign() command with this value as input. The TPM
responses the command as Sign Oracle of tpm.sign de-
scribed again in Section 2, and returns the value œÉt.
(cid:3)
The host packs the DAA signature œÉ from cre
and œÉt
and sends the signature to the veriÔ¨Åer.

3. Verifying process (6-10). The veriÔ¨Åer Ô¨Årst veriÔ¨Åes the
validation of the signature œÉ, and then checks whether
the signature was created by any key in RogueList. If
both of the veriÔ¨Åcations given an appropriate answer,
the TPM accepts the signature; otherwise rejects it.

4.6 Comparison with DAA in TPM 1.2

We compare our DAA schemes in TPM 2.0 with the DAA
scheme in TPM 1.2 with two aspects: code size and perfor-
mance. We shall show that our signature primitive achieves
signiÔ¨Åcant code and performance savings.

For code size, IBM software TPM 1.2 implementation3
takes 3.28MB code space, in which 225KB code is used for
DAA. In other words, DAA takes 6.9% of total code space.
On TPM 2.0 v0.98 software reference implementation re-
leased by Microsoft, TPM 2.0 takes 1.61MB code space, in
which only 7KB code is used for DAA. This is less than 0.5%
of the total code space.

As for performance, DAA join protocol in TPM 1.2 takes
9 modular exponentiations, where modulus is either 1632-
bit or 2048-bit, and exponents are more than 200-bit, with
two exponents larger than 2048-bit. DAA sign protocol in
TPM 1.2 takes 6 modular exponentiations and one of them
has exponent more than 2048-bit. In TPM 2.0, the most ex-
pensive operation in the DAA join protocol is a conventional
signature, including one scalar multiplication on an elliptic
curve. The DAA sign operations takes 3 scalar multiplica-
tions on an elliptic curve. According to [18], on an InÔ¨Åneon
TPM 1.2 chip (revision 1.2.3.16), DAA join takes 56.7 sec-
onds and DAA sign takes 37.7 seconds. We do not have
concrete DAA performance numbers on TPM 2.0, as TPM
2.0 chips are not publicly available yet. Based on prelimi-

3http://ibmswtpm.sourceforge.net/

45nary performance Ô¨Ågures from Nationz Technologies4 on a
discrete 40MHz TPM 2.0 chip, a scalar multiplication opera-
tion takes only 125ms on a 256-bit prime curve. We estimate
that DAA join or sign in TPM 2.0 takes less than 0.5 second.

5. APPLICATION 2: U-PROVE WITH TPM

AS A PROTECTED DEVICE

Microsoft U-Prove technology [24] is based on the Ste-
fan Brands pseudonym system [4] and uses the blind signa-
tures and zero-knowledge proofs as the fundamental building
blocks. Stefan Brands provided the Ô¨Årst description of the
U-Prove technology in 2000 [4]. Later Microsoft acquired the
technology and published U-Prove 1.1 protocol speciÔ¨Åcation,
which were updated to the current revision of U-Prove 1.1
protocol speciÔ¨Åcation (the 2nd version) that was published
in April 2013 [24].

In the U-Prove scheme, a U-Prove token is served as a
pseudonym for a prover. This token contains a number of
attributes of the prover certiÔ¨Åed by an issuer; and the at-
tributes can be selectively disclosed to a veriÔ¨Åer.

The U-Prove 1.1 speciÔ¨Åcation [24] suggests that a U-Prove
token can be optionally protected by a trusted hardware de-
vice such as a smartcard or a mobile phone. In that case,
the U-Prove token cannot be used by the prover without
the assistant of this device. The device can protect multi-
ple tokens issued by multiple issuers, but it is too costly to
implement all the prover algorithms in the trusted device.
U-Prove 1.1 speciÔ¨Åes how to split the prover functionality
between a trusted device and a prover platform.

U-Prove is not supported by TPM 1.2. Another motiva-
tion of this paper is to enable the U-Prove technology in
TPM 2.0 such that the TPM can be a trusted device for
U-Prove, using the same TPM signature primitive for DAA
without any additional overhead. In other words, U-Prove
is supported by TPM 2.0 with zero extra cost of the TPM
resources. In this section, we brieÔ¨Çy review the Microsoft
U-Prove technology [24] and describe how to use TPM 2.0
as a protected device for U-Prove 1.1.
5.1 Brief Review of U-Prove 1.1

In U-Prove, there is a U-Prove token served as a pseudonym
for the prover. This token contains a number of attributes of
the prover certiÔ¨Åed by the issuer which can be selectively dis-
closed to a veriÔ¨Åer. The prover can decide which attributes
to show and which attributes to hide. For each token, there
is a public key which aggregates all the information of the
token and a signature from the issuer over the public key to
certify the token. Let G = (cid:2)g(cid:3) be a cyclic group of prime
order p. The issuer public key is (g0, g1, . . . , gn, gt) ‚àà G and
the corresponding private key is y0 such that g0 = gy0 . Let
(A1, . . . , An) ‚àà {0, 1}‚àó
be n attributes of the prover, encoded
into the U-Prove token. The public key h ‚àà G of a U-Prove
token has the following form
h = (g0gx1

1 ¬∑¬∑¬∑ gxn

n gxt

where (x1, . . . , xn) ‚àà Zp are the corresponding hash values of
attributes (A1, . . . , An) respectively, xt is a hash value of the
issuer parameters, and Œ± ‚àà Zp is the secret key of the prover.
A U-Prove token is (h, œÉ), where œÉ is a blind signature on
the prover public key h issued by the issuer. There are two
protocols in U-Prove: issuing token and presenting token.
4Private communication with Nationz Technologies.

t )Œ±

In the issuing token protocol, both the prover and the
issuer agree on the attributes (A1, . . . , An) of the prover,
thus they agree on Œ≥ = (g0gx1
t ). In the end of the
issuing token protocol, the prover obtains a blind signature
œÉ on h = Œ≥Œ± such that the issuer does not know the secret Œ±.
The signature œÉ = (œÉz, œÉc, œÉr) is a signature of knowledge of
the following form

1 ¬∑¬∑¬∑ gxn

n gxt

SPK{(y0) :g 0 = gy0 ‚àß œÉz = hy0}.

In the presenting token protocol, the prover selectively
discloses a set of her attributes encoded in the public key to
a veriÔ¨Åer. The goal of this protocol is to prove the integrity
and authenticity of the disclosed attribute values. In addi-
tion, the prover may commit to the values encoded in some
attributes and prove that the commitments are computed
correctly. Let D ‚äÇ {1, . . . , n} be the indices of disclosed
attributes, U = {1, . . . , n} ‚àíD to the indices of undisclosed
attributes, and C ‚äÇ U be indices of committed attributes.
In this protocol, for each i ‚àà C, the prover chooses oi ran-
domly from Zp and computes a Pedersen commitment [25]
of xi as ci = gxi goi
1 . Then the prover computes the following
zero-knowledge proof of knowledge

SPK{(Œ±,{xi}i‚ààU ,{oi}i‚ààC ) :{c i = gxi goi

‚àß h = (g0gx1

1 }i‚ààC
1 ¬∑¬∑¬∑ gxn
n gxt

t )Œ±}(m).

The prover sends the U-Prove token (h, œÉ), disclosed at-
tributes {Ai}i‚ààD, commitments of attributes {ci}i‚ààC , and
the signature of knowledge to the veriÔ¨Åer. The veriÔ¨Åer veri-
Ô¨Åes the blind signature œÉ on h, computes {xi}i‚ààD from at-
tributes {Ai}i‚ààD, and veriÔ¨Åes the above signature of knowl-
edge.

5.2 Protocol Details of U-Prove 1.1

In U-Prove 1.1, a U-Prove token can be optionally pro-
tected by a hardware device such as a smart card. The pre-
senting token protocol requires both the token secret key Œ±
and the presence of the hardware device. Therefore, even if
the U-Prove token is stolen by an attacker, it cannot be used
unless the device is also physically captured by the attacker.
Let gd ‚àà G be the public device generator. Let xd ‚àà Zp be
the device private key andh d = gxd
d be the device public key.
The public key h of U-Prove token with device protection
has the following form:

h = (g0gx1

1 ¬∑¬∑¬∑ gxn

n gxt

t gxd

d )Œ±.

n gxt

1 ¬∑¬∑¬∑ gxn

1 ¬∑¬∑¬∑ gxn

t hd) = (g0gx1

The issuing token protocol requires no additional computa-
tion from the device as long as the device outputs the device
public key hd to the prover. The prover and the issuer can
run the issuing token protocol based on the following agreed
value: Œ≥ = (g0gx1
d ).
The presenting token protocol requires interaction of the
device as follows: The device optionally computes gs =
HG(str) whereH G : {0, 1}‚àó ‚Üí G is a collision-resistent hash
function outputting elements in G and Ps = gxd
s . The value
Ps is a pseudonym of the U-Prove token with regard to a
speciÔ¨Åc scope str. The purpose of the (gs, Ps) pair is similar
to (J, K) pair in DAA: used for checking linkability between
diÔ¨Äerent U-Prove tokens. For a veriÔ¨Åer with a speciÔ¨Åc scope
str, she can link two presenting token protocols from a de-
vice, even if two diÔ¨Äerent tokens are used. The device and

t gxd

n gxt

46the prover then jointly compute the signature of knowledge:

SPK{(Œ±, xd,{xi}i‚ààU ,{oi}i‚ààC ) : {ci = gxi goi
d )Œ± ‚àß Ps = gxd

‚àß h = (g0gx1

1 ¬∑¬∑¬∑ gxn

1 }i‚ààC
s }(m, md).

t gxd

n gxt

The device and the prover can compute the presenting token
protocol as follows:
1. The prover computes xi from Ai for i ‚àà {1, . . . , n},
and generates w0, wd ‚Üê Zp at random and wi ‚Üê Zp
at random for i ‚àà U .

2. The prover sends str to the device.

3. The device computes w

s (cid:10)= ‚àÖ, the device computes gs := HG(str), a
(cid:3)
p := gw
and Ps := gxd

s . The device returns ad, a

(cid:3)
p, and Ps.

If
(cid:2)
d
s ,

(cid:3)
d

(cid:2)
‚Üê Zp and ad := gw
d
d .

4. The prover computes

SPK{(Œ±,{xi}i‚ààU ,{oi}i‚ààC ) :{c i = gxi goi

1 }i‚ààC

t hd)Œ±}(m, md).
i‚ààU gwi

1 ¬∑¬∑¬∑ gxn
‚àß h = (g0gx1
n gxt
Q
i )gwd
as follows: Compute a = H(hw0 (
d ad) and
i ‚Üê Zp
p). For each i ‚àà C, choose oi, w
(cid:3)
(cid:3)
ap = H(gwd
(cid:2)
1 and ai := H(gwi gw
and compute ci := gxi goi
i
1 ). Com-
d := H(a, D,{xi}i‚ààD, C,{c i, ai}i‚ààC , ap, Ps, m),
(cid:3)
pute m
‚àí1 mod p. For each
c := H(md, m
i ‚àà U , compute ri := wi ‚àí cxi mod p. For each i ‚àà C,
compute r

(cid:3)
d) and r0 := w0 + cŒ±

i ‚àí coi mod p.
(cid:3)

(cid:3)
i := w

a

s

5. The prover sends md, m

(cid:3)
d to the device.

6. The device computes c := H(md, m

cxd mod p, and then outputs r
(cid:3)
d + wd mod p.

7. The prover computes rd := r

(cid:3)
d), and r

(cid:3)
d to the prover.

d := wd ‚àí
(cid:3)

The signature of the presenting token protocol is: ({Ai}i‚ààD, a,
(ap, Ps), r0,{ri}i‚ààU , rd,{ci, ai, r
i}i‚ààC ). In the next subsec-
(cid:3)
tion, we will discuss how to make use of a TPM implement-
ing the TPM 2.0 speciÔ¨Åcation as such a device.
5.3 Using TPM 2.0 as Protected Device

To enable TPM 2.0 as protected device for U-Prove, the
prover can compute the presenting token protocol as follows:

1. The prover runs the Ô¨Årst step of the presenting token

protocol in Section 5.2.

2. The prover loads the device key blob into the TPM and
calls the TPM2 Commit() command with (gd, ÀÜs, ÀÜy) as
input where HG(str) = (H(ÀÜs), ÀÜy). The prover obtains
(ad = R1, a

(cid:3)
p = R2, Ps = K2).

3. The prover runs Step 4 of the presenting token protocol

in Section 5.2.

m

4. The prover calls the TPM2 Sign() command with (md,

(cid:3)
d) as input and obtains (c, r
(cid:3)
d + wd mod p and outputs
the signature of the protocol ({Ai}i‚ààD, a,(a p, Ps), r0,
{ri}i‚ààU , rd,{ci, ai, r

5. The prover computes rd := r
i}i‚ààC ).
(cid:3)

(cid:3)
d = s).

Since both the TPM2 Commit() and TPM2 Sign() com-
mands have already been used to implement the two DAA
schemes as described in Section 4, the implementation of
U-Prove in TPM 2.0 does not require any extra TPM re-
sources.

6. CONCLUSION AND FUTURE WORK

We have presented a new digital signature primitive in
TPM 2.0 with provable security. The interesting and unique
property of this TPM signature primitive is that it can be
called by diÔ¨Äerent software programmes, in order to imple-
ment diÔ¨Äerent cryptographic schemes and protocols, such as
DAA, U-Prove, and Schnorr signatures.

Future work includes: (1) Explore other usages of this
TPM signature primitive. (2) Provide a more tight secu-
rity proof of the TPM signature primitive. In particular we
would like to see an answer of the question whether secu-
rity of this primitive can be proved without the static DH
assumption or without the random oracle model. (3) Con-
struct a new tpm.sign scheme which can be proved secure
under a weaker assumption but without adding much cost.

Acknowledgement
We thank Ernie Brickell, Chris Newton, Graeme Proudler,
Claire Vishik, Monty Wiseman and David Wooten for their
useful inputs and discussions. We also thank the TCG TPM
working group for their support to this work. We thank Fan
Qin and Liu Xin from Nationz Technologies for providing
the TPM 2.0 performance data. We appreciate Kevin Butler
and anonymous CCS reviewers for their helpful comments.

7. REFERENCES
[1] ISO/IEC 11889:2009 Information technology ‚Äì

Security techniques ‚Äì Trusted platform module.
[2] Michael Backes, Matteo MaÔ¨Äei, and Dominique

Unruh. Zero-knowledge in the applied pi-calculus and
automated veriÔ¨Åcation of the direct anonymous
attestation protocol. In Proceedings of IEEE
Symposium on Security and Privacy, pages 202‚Äì215.
IEEE Computer Society, 2008.

[3] D. Bernhard, G. Fuchsbauer, E. GhadaÔ¨Å, N. P. Smart,

and B. Warinschi. Anonymous attestation with
user-controlled linkability. International Journal of
Information Security, 12(3):219‚Äì249, 2013.

[4] Stefan A. Brands. Rethinking Public Key

Infrastructures and Digital CertiÔ¨Åcates: Building in
Privacy. MIT Press, August 2000.

[5] Ernie Brickell, Jan Camenisch, and Liqun Chen.

Direct anonymous attestation. In Proceedings of the
11th ACM Conference on Computer and
Communications Security, pages 132‚Äì145. ACM Press,
2004.

[6] Ernie Brickell, Liqun Chen, and Jiangtao Li. A new

direct anonymous attestation scheme from bilinear
maps. In Proceedings of 1st International Conference
on Trusted Computing, volume 4968 of LNCS, pages
166‚Äì178. Springer, 2008.

[7] Ernie Brickell, Liqun Chen, and Jiangtao Li.

SimpliÔ¨Åed security notions of direct anonymous
attestation and a concrete scheme from pairings.
International Journal of Information Security,
8(5):315‚Äì330, 2009.

[8] Ernie Brickell, Liqun Chen, and Jiangtao Li. A
(corrected) DAA scheme using batch proof and
veriÔ¨Åcation. In Proceedings of 3rd International
Conference on Trusted Systems, volume 7222 of
LNCS, pages 304‚Äì337. Springer, 2011.

47[9] Ernie Brickell and Jiangtao Li. Enhanced Privacy ID:
A direct anonymous attestation scheme with enhanced
revocation capabilities. In Proceedings of the 6th ACM
Workshop on Privacy in the Electronic Society, pages
21‚Äì30, October 2007.

[10] Ernie Brickell and Jiangtao Li. A pairing-based DAA

scheme further reducing TPM resources. In
Proceedings of 3rd International Conference on Trust
and Trustworthy Computing, volume 6101 of LNCS,
pages 181‚Äì195. Springer, 2010.

[11] Jan Camenisch and Anna Lysyanskaya. Signature
schemes and anonymous credentials from bilinear
maps. In Advances in Cryptology ‚Äî CRYPTO ‚Äô04,
volume 3152 of LNCS, pages 56‚Äì72. Springer, 2004.

[12] David Chaum and Hans Van Antwerpen. Undeniable

signatures. In Advances in Cryptology ‚Äî CRYPTO
‚Äô89, volume 435 of LNCS, pages 212‚Äì216. Springer,
1989.

[13] Liqun Chen. A DAA scheme using batch proof and
veriÔ¨Åcation. In Proceedings of the 3rd International
Conference on Trust and Trustworthy Computing,
volume 6101 of LNCS, pages 166‚Äì180. Springer, 2010.

[14] Liqun Chen, Paul Morrissey, and Nigel P. Smart.

Pairings in trusted computing. In Proceedings of the
2nd International Conference on Pairing-Based
Cryptography, volume 5209 of LNCS, pages 1‚Äì17.
Springer, 2008.

[15] Liqun Chen, Siaw-Lynn Ng, and Guilin Wang.

Threshold anonymous announcement in VANETs.
IEEE Journal on Selected Areas in Communications,
Special Issue on Vehicular Communications and
Networks, 2010.

[16] Liqun Chen, Dan Page, and Nigel P. Smart. On the

design and implementation of an eÔ¨Écient DAA
scheme. In Proceedings of the 9th Smart Card
Research and Advanced Application IFIP Conference.
Springer, 2010.

[17] Xiaofeng Chen and Dengguo Feng. Direct anonymous

attestation for next generation TPM. Journal of
Computers, 3(12):43‚Äì50, 2008.

[18] Kurt Dietrich. Anonymous client authentication for

transport layer security. In Communications and
Multimedia Security, volume 6109 of LNCS, pages
268‚Äì280, 2010.

[19] Taher El Gamal. A public key cryptosystem and a
signature scheme based on discrete logarithms. In
Advances in Cryptology ‚Äî CRYPTO ‚Äô84, volume 196
of LNCS, pages 10‚Äì18. Springer, 1985.

[20] Amos Fiat and Adi Shamir. How to prove yourself:

Practical solutions to identiÔ¨Åcation and signature
problems. In Advances in Cryptology ‚Äî CRYPTO ‚Äô86,
volume 263 of LNCS, pages 186‚Äì194. Springer, 1987.
[21] Warwick Ford and Burton S. Kaliski. Server-assisted

generation of a strong secret from a password. In
Proceedings of the IEEE 9th International Workshops
on Enabling Technologies: Infrastructure for
Collaborative Enterprises, pages 176‚Äì180, 2000.

[22] He Ge and Stephen R. Tate. A direct anonymous

attestation scheme for embedded devices. In
Proceeding of 10th International Conference on
Practice and Theory in Public Key Cryptography,
volume 4450 of LNCS, pages 16‚Äì30. Springer, 2007.

[23] Adrian Leung and Chris J. Mitchell. Ninja: Non

identity based, privacy preserving authentication for
ubiquitous environments. In Proceedings of 9th
International Conference on Ubiquitous Computing,
volume 4717 of LNCS, pages 73‚Äì90. Springer, 2007.
[24] Microsoft U-Prove Community Technology. U-Prove

cryptographic speciÔ¨Åcation version 1.1, 2013.
http://www.microsoft.com/u-prove.

[25] Torben P. Pedersen. Non-interactive and

information-theoretic secure veriÔ¨Åable secret sharing.
In Advances in Cryptology ‚Äî CRYPTO ‚Äô91, volume
576 of LNCS, pages 129‚Äì140. Springer, 1991.

[26] David Pointcheval and Jacques Stern. Security

arguments for digital signatures and blind signatures.
Journal of Cryptology, 13(3):361‚Äì396, 2000.

[27] Carsten Rudolph. Covert identity information in direct

anonymous attestation (DAA). In Proceedings of the
IFIP TC-11 22nd International Information Security
Conference (SEC), pages 443‚Äì448. Springer, 2007.

[28] Claus P. Schnorr. EÔ¨Écient identiÔ¨Åcation and

signatures for smart cards. Journal of Cryptology,
4(3):161‚Äì174, 1991.

[29] Ben Smyth, Mark Ryan, and Liqun Chen. Direct

anonymous attestation (DAA): Ensuring privacy with
corrupt administrators. In Proceedings of 4th European
Workshop on Security and Privacy in Ad-hoc and
Sensor Networks, volume 4572 of LNCS, pages
218‚Äì231. Springer, 2007.

[30] Trusted Computing Group. TCG TPM speciÔ¨Åcation
1.2, 2003. http://www.trustedcomputinggroup.org.
[31] Trusted Computing Group. TCG TPM speciÔ¨Åcation

2.0, 2013. http://www.trustedcomputinggroup.org/
resources/trusted_platform_module_
specifications_in_public_review.

[32] David Wooten. Private communications.

APPENDIX
A. COMPUTATION OF HG

We Ô¨Årst describe a method of constructing HG : {0, 1}‚àó ‚Üí
G, where G is an elliptic curve group E : y2 = x3 + ax + b
over Fq with cofactor = 1. Given a message m ‚àà {0, 1}‚àó
,
HG(m) can be computed as follows:

1. Set i := 0 be a 32-bit unsigned integer.

‚àö

2. Compute x := H(i, m).
3. Compute z := x3 + ax + b mod q.
4. Compute y :=
5. Set y := min(y, q ‚àí y).
6. Output the result as (x, y).

z mod q. If y does not exist, set i :=
i + 1, repeat step 2 if i < 232, otherwise, report failure.

The host platform can help the TPM compute HG(m),
yet the TPM can verify the computation as follows. Given
m, the host runs the above algorithm. For a successful exe-
cution, let ÀÜs := (i, m) and ÀÜy be the y value in the last step.
The host sends ÀÜs and ÀÜy to the TPM. The TPM computes
HG(m) := (H(ÀÜs), ÀÜy). This is the Ô¨Årst step of the TPM 2.0
commit command.

48