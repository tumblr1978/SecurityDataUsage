PRIVACY-PRESERVING 
LOGARITHMIC-TIME SEARCH ON 
ENCRYPTED DATA IN CLOUD 

1 

Yanbin Lu 
University of California, Irvine 
(NDSS’11, Feb 6) 

CLOUD DATABASE ENVIRONMENT 

Database transfer 

Database Owner 

User 

2 

PRIVACY REQUIREMENTS 

  Privacy requirements: 

  Cloud server learns no information about database 
  Cloud server learns no information about user query 
  Owner can exercise access control over user query 

  Personal data vault example: 

  Owner: Patient 
  Database: Heart beat rate 
  Cloud server: Amazon RDS 
  User: Cardiologist 

3 

PRIVACY-PRESERVING SOLUTION 

Encrypted Database 

Query 

Database 
Owner 

Search token 
decryption key 

Data User 

Decrypt 

4 

REQUIREMENTS 

  Sublinear search 

  Linear search is untolerable in massive data 

  Query result integrity 

  Prevent cloud server from cheating user 

  Provable database update 

  Prevent cloud server from cheating database owner 

5 

RELATED WORK 

  Order preserving encryption 

  Deterministic and not IND-CPA secure 
  Domain distribution is fixed 

  Bellare et al. [crypto’07] 

  Deterministic and not IND-CPA secure 
  Only equality search is supported 

  Predicate encryption 

  Useful in privacy-preserving cloud database 
  Linear complexity 

6 

PREDICATE ENCRYPTION 

  Setup(    ): output secret key SK. 

1k

  Encrypt(              ): encrypt message     under   
                                   attributes    with key SK.  

SK, I, m

m

I

  Key-extraction(   ): outputs key  

g

kg

  Decrypt(         ): decrypts iff  

kg, CI

g(I) = 1

7 

BUILDING BLOCKS 

  Range predicate encryption (RPE) 

  Ciphertext associated with point 
t
  Decryption key associated with a range  
Q
  Decryption works if 

t ∈ Q

  Inner-product predicate encryption (IPE) 

  Ciphertext associated with vector 
  Decryption key associated with vector  
￿v
  Decryption works if  

￿x

￿￿v, ￿x￿ = 0

8 

STRAWMAN RPE BUILDING FROM IPE  

  Encrypt(t): create                                          where 
                                   if i = t and              otherwise.  
                      Run IPE encryption. 

￿x = (x1, . . . , xi, . . . , xT )

xi = 0

xi = 1

  Extract(Q): create                                         where 
                                   if            and             otherwise. 
                       Run IPE key extraction. 

￿y = (y1, . . . , yi, . . . , yT )
i ∈ Q

yi = 0

y1 = 1

  Decrypt(            ):  Run IPE decryption. 

et, kQ

9 

EFFICIENT RANGE REPRESENTATION 

!#!

!"!

!##!

!#"!

!"#!

!""!

#
!###!

" $

!##"!

!#"#!

% &

!#""!

!"##!

'
!"#"!

(
!""#!

)
!"""!

  Any range can be covered by                       nodes. 
  Point path intersects with range representation 

2 · (log T − 1)

10 

EFFICIENT RANGE PREDICATE ENCRYPTION 

  Encrypting point t: 

(X − v) =

αiX i

log T￿i=0

    

P (X) = ￿v∈CP(t)

    

￿A = (α0, . . . , αlog T )

  Key extraction for range Q: 

    

￿Kx = (x0, . . . , xlog T ),∀x ∈ MCS(Q)

  Observation:  

    
￿A · ￿Kx = α0 · x0 + α1 · x1 + ··· + αlog T · xlog T = P (x)

11 

LOGARITHMIC-TIME SEARCH 

  Encrypting each node of B-tree 

  One RPE for search token 
  One RPE for real message 

  Search token extraction involves two rounds 

  One for left range 
  One for right range 
  Example: 

  Domain size [0-100] 
  Query range [10-20] 
  Left range [0-9], right range [21-100] 

12 

QUERY AUTHENTICATION 

  Authenticated data structure 

  Encrypted B-tree 
  Authenticated root 

  Query result verification 

  Left and right boundary to query range 
  Verification without leaking records out of range 

  Provable data update 

  Owner first verifies change path 
  Reconstructs and authenticates root 

13 

PERFORMANCE 

Total search time 

Search time per record 

14 

Thank you! 

15 

