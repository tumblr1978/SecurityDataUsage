Full Proof Cryptography: VeriÔ¨Åable Compilation of

EfÔ¨Åcient Zero-Knowledge Protocols‚àó

Jos√© Bacelar Almeida

HASLab - INESC TEC
Univ. do Minho, Portugal

jba@di.uminho.pt

Gilles Barthe

IMDEA Software Institute

Madrid, Spain

Manuel Barbosa

HASLab - INESC TEC
Univ. do Minho, Portugal
mbb@di.uminho.pt

Stephan Krenn‚Ä†

IST Austria

Klosterneuburg, Austria

Endre Bangerter

Bern Univ. of Appl. Sciences

Bern, Switzerland

endre.bangerter@bfh.ch

Santiago Zanella B√©guelin

Microsoft Research

Cambridge, UK

gilles.barthe@imdea.org

stephan.krenn@ist.ac.at

santiago@microsoft.com

ABSTRACT
Developers building cryptography into security-sensitive applica-
tions face a daunting task. Not only must they understand the se-
curity guarantees delivered by the constructions they choose, they
must also implement and combine them correctly and efÔ¨Åciently.
Cryptographic compilers free developers from this task by turn-
ing high-level speciÔ¨Åcations of security goals into efÔ¨Åcient imple-
mentations. Yet, trusting such tools is hard as they rely on com-
plex mathematical machinery and claim security properties that are
subtle and difÔ¨Åcult to verify. In this paper we present ZKCrypt,
an optimizing cryptographic compiler achieving an unprecedented
level of assurance without sacriÔ¨Åcing practicality for a comprehen-
sive class of cryptographic protocols, known as Zero-Knowledge
Proofs of Knowledge. The pipeline of ZKCrypt integrates purpose-
built veriÔ¨Åed compilers and verifying compilers producing formal
proofs in the CertiCrypt framework. By combining the guarantees
delivered by each stage, ZKCrypt provides assurance that the out-
put implementation securely realizes the abstract proof goal given
as input. We report on the main characteristics of ZKCrypt, high-
light new deÔ¨Ånitions and concepts at its foundations, and illustrate
its applicability through a representative example of an anonymous
credential system.

‚àóThis work was partially funded by National Funds through
the FCT - Funda√ß√£o para a Ci√™ncia e a Tecnologia (Portuguese
Foundation for Science and Technology) within project ENI-
AC/2224/2009, by ENIAC Joint Undertaking under grant agree-
ment number 120224, European Projects FP7-256980 NESSoS
and FP7-229599 AMAROUT, Spanish National project TIN2009-
14599 DESAFIOS 10, and Madrid Regional project S2009TIC-
1465 PROMETIDOS.
‚Ä†Most of this work was done while the author was at Bern Univer-
sity of Applied Sciences and University of Fribourg.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
CCS‚Äô12, October 16‚Äì18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.

Categories and Subject Descriptors
D.2 [Software Engineering]: Software/Program VeriÔ¨Åcation; D.3
[Programming Languages]: Processors‚ÄîCompilers

Keywords
Zero-knowledge, verifying compilation, cryptographic compiler

1.

INTRODUCTION

Zero-Knowledge Proofs of Knowledge (ZK-PoKs) [33, 34] are
two-party protocols in which a prover convinces a veriÔ¨Åer that it
knows a secret piece of information satisfying some property with-
out revealing anything except the correctness of this claim. ZK-
PoKs allow obtaining assurance on a prover‚Äôs honest behavior with-
out compromising privacy, and are used in a number of practical
systems, including Direct Anonymous Attestation (DAA) [15], a
privacy-enhancing mechanism for remote authentication of com-
puting platforms, the identity mixer [17], an anonymous credential
system for user-centric identity management, Off-the-Record mes-
saging [13,31], a protocol enabling deniability in instant messaging
protocols, and privacy-friendly smart metering [47], an emerging
technology for smart meters. However, more than 25 years after
their inception [32], the potential of ZK-PoKs has not yet been fully
realized, and many interesting applications of ZK-PoKs still only
exist at the speciÔ¨Åcation level. In our experience, one main hurdle
towards a larger use of ZK-PoKs is the difÔ¨Åculty of designing and
correctly implementing these protocols for custom proof goals.

Zero-knowledge compilers [6, 43] are domain-speciÔ¨Åc compil-
ers that automatically generate ZK-PoKs for a large class of proof
goals. They are a promising enabling technology for ZK-PoKs, be-
cause they allow developers to build cryptographic protocols that
use them, without deep expertise in cryptography, and without the
risk of introducing security Ô¨Çaws in their implementations. Zero-
knowledge compilers embed a sophisticated mathematical machin-
ery, and as a consequence implementing them correctly can be
difÔ¨Åcult‚Äîarguably more difÔ¨Åcult than implementing optimizing
compilers. Moreover, such compilers cannot be tested and de-
bugged because their purported correctness properties are formu-
lated in the style of provable security, and testing such properties is
out of reach of current methods. This leaves practitioners with no
other option than blindly trusting that the compiler is correct.
Contributions. We present ZKCrypt, a high-assurance zero-know-
ledge compiler that outputs formally veriÔ¨Åed and optimized imple-
mentations of ZK-PoKs for a comprehensive set of proof goals.

488.zk File

.psl File

Templates

Proof goal G

Resolution

Resolved goal 

Implementation

Gres

.pil File
Optimized 

implementation 

Iopt

Generation

.c or .java Files

C or Java 

implementation

CACE Compiler

CertiCrypt

Proof goal G

Automatic
VeriÔ¨Åcation

Translate, 
Recover and
correctness of

Gres wrt G

Resolved goal 

Gres

VeriÔ¨Åed

Compilation

Reference 

implementation Iref

Completeness, 

Proof of Knowledge 

and

Zero Knowledge of 

Iopt wrt Gres

Optimized 

implementation 

Iopt

Automatic
VeriÔ¨Åcation

Observational 
equivalence 
of Iopt vs Iref

Completeness, Proof of Knowledge and 

Zero Knowledge of Iopt wrt goal G

Figure 1: ZKCrypt architecture, depicting a verifying compiler that takes high-level proof goals G to optimized implementations
(top), relying on a veriÔ¨Åed compiler implemented in Coq/CertiCrypt (center). Full lines denote compilation steps and translation
over formalization boundary (i.e. the generation of code that can be fed into formal veriÔ¨Åcation tools), dashed lines denote formal
veriÔ¨Åcation guarantees. Rectangular boxes denote code in various (intermediate) languages either stored in Ô¨Åles or as data structures
in memory. Rounded rectangles represent the main theorems that are generated and formally veriÔ¨Åed by ZKCrypt and which jointly
yield the desired formal correctness and security guarantees.

We consider in particular Œ£-protocols [24] for proving knowl-
edge of pre-images under group homomorphisms, which underly
essentially all practically relevant applications of ZK-PoKs, in-
cluding those mentioned above and the identiÔ¨Åcation schemes by
Schnorr [49] and Guillou-Quisquater [36].

ZKCrypt achieves an unprecedented level of conÔ¨Ådence among
cryptographic compilers by leveraging and transposing to the realm
of cryptography two recent breakthroughs: veriÔ¨Åed compilation
[39], in which the correctness of a compiler is proved once and
for all, and verifying compilation [45, 52], in which the correctness
of the output of a compiler is proved for each run. SpeciÔ¨Åcally,
ZKCrypt implements a veriÔ¨Åed compiler that generates a reference
implementation, and a verifying compiler that outputs an optimized
implementation provably equivalent to the reference implementa-
tion. Taken together, the proofs output by the compilers establish
that the reference and optimized implementations satisfy the fol-
lowing properties1 (see ¬ß3 for formal deÔ¨Ånitions):

‚Ä¢ Completeness: an honest prover can always convince an hon-

est veriÔ¨Åer;

‚Ä¢ Proof of knowledge: a malicious prover not knowing the
secret cannot convince the veriÔ¨Åer, except with some small
probability;

‚Ä¢ Zero-knowledge: a veriÔ¨Åer following the protocol cannot

learn additional information about the secret.

The architecture of the compiler is shown in Figure 1. At the top
level, ZKCrypt is composed of a chain of compilation components
that generates C and Java implementations of ZK-PoKs; these im-
plementations can be turned into executable binaries using general-
purpose compilers. These top-level components are an extension
of the CACE compiler [2] with support for user-deÔ¨Åned templates
and high-level proof goals. At the bottom level, ZKCrypt generates
formal proofs in the CertiCrypt framework [8]. The compilation
component is independent of the veriÔ¨Åcation component.

The main compilation phases in ZKCrypt are the following:

1In the remainder of this paper, we refer to these three properties
as the (relevant) security properties of ZK-PoKs.

Resolution takes a user-friendly description of proof goal G and
outputs an equivalent goal Gres, where high-level range
restrictions are converted, using standard techniques, into
proofs of knowledge of pre-images under homomorphisms;
such pre-image proofs are atomic building blocks that cor-
respond to well known concrete instances of ZK-PoK pro-
tocols, which can be handled by subsequent compilation
phases. The correctness of resolution is captured by a trans-
formation that provably converts ZK-PoK protocols for Gres
into ZK-PoK protocols for G. The compiler implements both
the decomposition and the transformation, and we prove a set
of sufÔ¨Åcient conditions for correctness and security;

VeriÔ¨Åed compilation takes a resolved goal Gres and outputs a ref-
erence implementation Iref in the embedded language of Cer-
tiCrypt. A once-and-for-all proof of correctness guarantees
that this component only produces reference implementa-
tions that satisfy the relevant security properties, for all sup-
ported input goals. This result hinges on two contributions
of independent interest: a uniÔ¨Åed treatment of the proof of
knowledge property, and a formalization of statistical zero-
knowledge;

Implementation takes a resolved goal Gres and outputs an opti-
mized implementation Iopt. The correctness of this step is
established, in the style of verifying compilation, using an
equivalence checker proving semantic equivalence between
the reference and optimized implementations Iref and Iopt.

Generation takes the optimized implementation Iopt and produces
implementations of the protocol
in general-purpose lan-
guages. This component in the compiler is the same as that
presented in [2], and is not veriÔ¨Åed.

Combining the correctness results for each phase yields a proof that
the optimized implementation Iopt satisÔ¨Åes the security properties
of the original high-level goal G. This approach is the same as
veriÔ¨Åed compilers such as CompCert [39]. As in CompCert, it is
convenient to combine certiÔ¨Åed and certifying compilation, instead
of certifying the whole compiler chain. Our results show that these
techniques are also beneÔ¨Åcial for cryptographic compilers.

489New additions to the compiler. There are main two aspects in
which this work extends the CACE compiler [2]. Firstly, the ver-
iÔ¨Åcation back-end of ZKCrypt supports more proof goals: by ad-
dressing Œ£GSP-protocols and high-level goal resolution, we can ver-
ify implementations satisfying the needs of many practical appli-
cations. Secondly, in addition to soundness, ZKCrypt also for-
mally veriÔ¨Åes the completeness and HVZK properties, covering
all properties relevant to practical applications. Achieving these
extensions posed signiÔ¨Åcant challenges. The theoretical aspects
surrounding Œ£GSP-protocols are knottier compared to Œ£œÜ-protocols
addressed in [2, 11]. For example, reasoning about statistical dis-
tance and dealing with computational assumptions required to de-
velop a backend from scratch based on cryptography-speciÔ¨Åc ver-
iÔ¨Åcation tools. Indeed, using formal tools such as CertiCrypt as
backends for verifying the compilation of cryptographic protocols
is unprecedented.
Limitations. Although the veriÔ¨Åcation component of our compiler
is comprehensive, it currently has two limitations. First, ZKCrypt
delivers formal guarantees about the correctness of the optimized
implementation Iopt, but not for the last step in the compilation
chain, namely the generation of Java or C code. Although we con-
sider the veriÔ¨Åcation of this last compilation step as an important
direction for future development, we see this as an independent
line of work because the veriÔ¨Åcation goals involved at this level are
of a different nature to those presented in this paper. SpeciÔ¨Åcally,
the natural path to achieve correctness guarantees about binaries is
to extend ZKCrypt with formal veriÔ¨Åcation at the code generation
level, and then to use a high-assurance compiler from C or Java to
binaries. Given the characteristics of the programming language
used for the optimized implementations Iopt, the key step to adding
a formal veriÔ¨Åcation back-end for code generation is to build a cer-
tiÔ¨Åed number theory library that matches the one provided with
the CACE compiler. Compilation from C to binaries can then be
certiÔ¨Åed directly using state-of-the-art veriÔ¨Åed compilers, such as
CompCert [39]. Second, we do not prove completeness of veriÔ¨Å-
cation, i.e., that all CACE compiler programs can be veriÔ¨Åed by our
component. A reason for this is that there are some known sources
of incompleteness, as some of the proof goals that can be handled
by the CACE compiler are not yet supported. A more fundamental
reason is that certifying compilation techniques, as used by part of
the formal veriÔ¨Åcation back-end, are seldom proved complete; in-
stead, one validates the effectiveness of a technique by its ability to
cover a wide range of examples. As we will show, ZKCrypt sat-
isfactorily complies with this more practical view, as the class of
goals for which veriÔ¨Åcation is available is already broad enough to
cover most practical applications.
Paper organization. The applicability of ZKCrypt is illustrated in
¬ß2 through a use case from the identity mixer anonymous creden-
tial system [17]; ¬ß3 provides some necessary background material;
¬ß4‚Äì¬ß6 explain the resolution, veriÔ¨Åed compilation and implementa-
tion phases, respectively; ¬ß7 brieÔ¨Çy reports on further experimental
results. We conclude with a discussion of related work in ¬ß8 and
future research directions in ¬ß9.

2. USE CASE

Anonymous credential systems [22,23] are among the most prac-
tically relevant applications of ZK-PoKs; examples of prominent
realizations include the IBM identity mixer library (Idemix) [21],
the Microsoft U-Prove toolkit [44], as well as Trusted Platform
Modules (TPMs), which implement the Direct Anonymous Attes-
tation (DAA) protocol [15], and are widely built into consumer lap-
tops and PCs. In a further and coordinated effort to bring anony-

mous credential systems to practice, the ABC4Trust project [1] is
working to deliver open reference implementations of attribute-
based credential systems, and to integrate them into real-world
identity-management systems.

An anonymous credential system consists of a collection of pro-
tocols to issue, revoke, prove possession of credentials, etc. One
key feature for ensuring anonymity is that users can selectively
reveal certain identity attributes without disclosing anything else.
In the Idemix system [21] this goal is realized using Camenisch-
Lysyanskana (CL) signatures [18]. Informally, such a signature on
two messages m1, m2 consists of integers e, v and A ‚àà Z‚àó
n satisfy-
ing Z = Rm1
2 SvAe, where R1, R2, S, Z are public quadratic
residues modulo n, and n is a strong RSA modulus (i.e., n = pq
where p, q, (p ‚àí 1)/2 and (q ‚àí 1)/2 are all prime).

1 Rm2

Assume now that a user holds a signature on his name m1 and his
birthdate m2. Now, when authenticating to a server, the user may
be willing to reveal his name but not his birthdate. On the other
hand, he is required to show that he was born after some date b to
get student discount. To achieve authentication agreeably to both
parties, the user will reveal m1 and A, and then give a ZK-PoK
that he knows m2, e, v such that (e, v, A) is a valid CL-signature
on (m1, m2). Using the standard notation for ZK-PoK [20], this
goal G is formally stated as:

ZPKh (m2, v, e) :

Z
Rm1

1

= Rm2

2 SvAe ‚àß m2 ‚â• bi

(1)

The convention in the formulation above is that knowledge of all
values before the colon has to be proved, while all other values are
assumed to be publicly known. Note that the Ô¨Årst conjunct shows
possession of a valid CL-signature on m1, m2, and the second con-
junct shows that m2 ‚â• b, as required by the server policy.

ZKCrypt generates an optimized implementation of a ZK-PoK
and machine-checkable proofs that it satisÔ¨Åes the relevant security
properties. We give below an overview of the compilation process.

Resolution. ZKCrypt resolves the above proof goal G to the fol-
lowing goal Gres:

ZPKh (e, m2, v, r‚àÜ, u1, u2, u3, u4, r1, r2, r3, r4, Œ±) :

2 ‚àß T‚àÜZ b = Zm2 Sr‚àÜ ‚àß

= AeSvRm2

Z
Rm1

1

4

^i=1

Ti = Z ui Sri ‚àß T‚àÜ = T u1

1 T u2

2 T u3

3 T u4

4 SŒ±i

The Ô¨Årst conjunct is obtained by unfolding the deÔ¨Ånition of the CL
predicate, making explicit the groups elements Z and S used in
the signature. The remaining conjuncts are obtained by applying
Lipmaa‚Äôs technique [40] to resolve the goal m2 ‚â• b into equalities
between exponentiations of Z and S. This compilation step and
the formal veriÔ¨Åcation of its correctness are described in detail in
¬ß4. In short, we formalize the sufÔ¨Åcient conditions for correctness
based on a procedure Translate for turning a witness for G into a
witness for Gres and a procedure Recover for computing a witness
for Gres from a witness for G.

VeriÔ¨Åed compilation This phase outputs a reference implementa-
tion Iref in the embedded language of CertiCrypt. This is done in
two steps: Ô¨Årst, ZKCrypt extends the base language of CertiCrypt
by specifying and deÔ¨Åning the necessary algebraic constructions,
e.g., the underlying group with its operations and generators. Sec-
ond, the compiler instantiates a CertiCrypt module for Œ£-protocols
with the resolved goal Gres expressed using a single homomorphism

490Œ¶. In the use case we present, Œ¶ is deÔ¨Åned as:

Œ¶ (e, m2, v, r‚àÜ, u1, u2, u3, u4, r1, r2, r3, r4, Œ±)

.
=

i=1 T ui

(cid:0)AeSvRm2

2

i (cid:1)

, Zm2 Sr‚àÜ , Z u1 Sr1 , . . . , Z u4 Sr4 , SŒ± Q4

This instantiation yields a reference implementation Iref of a ZK-
PoK protocol, comprising four procedures that represent the com-
putations performed by each party during a run of a Œ£-protocol.
Each procedure consists of either a random assignment followed
by a deterministic assignment, or just a deterministic assignment.
The completeness, proof of knowledge, and honest veriÔ¨Åer zero-
knowledge (HVZK) properties of Iref are a direct consequence of
generic proofs in CertiCrypt.
Interestingly, statistical HVZK is
established using an approximate version of the Probabilistic Rela-
tional Hoare Logic of CertiCrypt, which has been recently devel-
oped for different purposes [9].
Implementation This phase outputs a representation Iopt that can
be used for code generation. Contrary to the reference implemen-
tation, Iopt does not adhere to a constrained shape; in particular,
it uses long sequences of instructions and branching statements.
Also, algebraic expressions are re-arranged in order to enable opti-
mizations during code generation. The equivalence of Iopt and Iref
is proved in two steps. First, ZKCrypt builds a representation of
Iopt in the embedded language of CertiCrypt. It then generates a
proof that Iopt satisÔ¨Åes the relevant security properties, by establish-
ing that each algorithm in the protocol is observationally equivalent
to the matching algorithm in the reference implementation.

By glueing together the correctness proofs of the different
phases, one obtains the end-to-end guarantee that Iopt is a correct
implementation of a ZK-PoK for G.

3. ZERO-KNOWLEDGE PROOFS

In the remainder, we denote deterministic assignments by y ‚Üê
f (x), and uniformly random assignments by x $‚Üê A, where A may
be a set or a randomized algorithm.

All ZK proofs generated by ZKCrypt are Œ£-protocols:

DEFINITION 1

(Œ£-PROTOCOL). Let R denote a binary rela-
tion, (x, w) ‚àà R, and let P1, P2, and V denote arbitrary algo-
.
= P(x, w) and a prob-
rithms. A protocol between a prover P
.
= V(x) is called a Œ£-
abilistic polynomial-time (PPT) veriÔ¨Åer V
protocol with challenge set C = {0, . . . , c+‚Äì1}, if it satisÔ¨Åes the
following conditions.

3-move form. The protocol is of the following form:

‚Ä¢ P sets (r, st) $‚Üê P1(x, w) and sends r to V;
‚Ä¢ V sends a random challenge c $‚Üê C to P. We refer to the

algorithm that samples the challenge as Vc;
‚Ä¢ P sends s ‚Üê P2(x, w, st, c) to the veriÔ¨Åer;
‚Ä¢ V accepts if V(x, r, c, s) = true, otherwise V rejects.

Completeness. For an honest prover P, the veriÔ¨Åer V accepts on

common input x, whenever (x, w) ‚àà R.

Every triple (r, c, s) for which V(x, r, c, s) = true is called an

accepting conversation.

Informally, a two-party protocol is a proof of knowledge if from
every successful (potentially malicious) prover P ‚àó, a witness can
be extracted within a certain time bound by a knowledge extractor
algorithm. For all practically relevant Œ£-protocols, the knowledge
extractor works in two phases. First, using rewinding black-box
access to P ‚àó, two accepting conversations (r, c, s) and (r, c‚Ä≤, s‚Ä≤)
are extracted. Then, in a second step, a witness is computed from
these conversations. The Ô¨Årst part of the knowledge extractor is

well-known to work for arbitrary Œ£-protocols [26]. ZKCrypt does
not include a formalization of the proof of this part of the knowl-
edge extractor, as this would imply formalizing rewinding argu-
ments and reasoning about expected polynomial time executions,
which are currently out of reach of formal veriÔ¨Åcation tools such as
CertiCrypt. The second phase of extraction only works only under
certain conditions, which are formalized next:

DEFINITION 2

(GENERALIZED SPECIAL SOUNDNESS).

A Œ£-protocol satisÔ¨Åes generalized special soundness for a relation
R‚Ä≤, if there is a PPT extractor that, on input a relation R $‚Üê R(1Œª),
a value x in the language deÔ¨Åned by R, and any two accepting con-
versations, (r, c, s) and (r, c‚Ä≤, s‚Ä≤) satisfying R‚Ä≤, computes a witness
w satisfying R(x, w) with overwhelming probability.

Observe that a Œ£-protocol satisfying this deÔ¨Ånition is a proof of
knowledge for R if the conversations extracted by the Ô¨Årst phase of
the knowledge extractor satisfy R‚Ä≤.

DeÔ¨Ånition 2 is a generalization of the classical notion of special
soundness found in the literature, e.g., Cramer [24], and enables a
uniform formalization of the proof of knowledge property for all
Œ£-protocols supported by ZKCrypt. Following this approach we
extend the modularization of the proof of knowledge property that
is well-known for other Œ£-protocols, so that we can treat Œ£GSP-
protocols in a similar way.

Roughly, the special extractor algorithm can only recover a valid
witness if the accepting conversations display speciÔ¨Åc properties
captured by relation R‚Ä≤. Furthermore, in some cases, the existence
of an algorithm that is able to extract these conversations relies on a
computational assumption. To account for this, following Damg√•rd
and Fujisaki [27], we allow relation R to be sampled using an efÔ¨Å-
cient algorithm R. We will detail R and R‚Ä≤ for each concrete in-
stance of a Œ£-protocol later2. The implication for our formalization
approach is that the soundness of the protocols veriÔ¨Åed by ZKCrypt
is guaranteed, provided that the relations are sampled from the dis-
tribution generated by the prescribed algorithm R.

The proof of knowledge property ensures a veriÔ¨Åer that a con-
vincing prover indeed knows the secret. On the other hand, the
veriÔ¨Åer should not be able to deduce any information about this
witness. This is captured by the zero-knowledge property. In the
following, we denote by viewP
V (x) the random variable describing
the content of the random tape of V and the messages V receives
from P during a successful protocol run on common input x.

DEFINITION 3

(HONEST VERIFIER ZERO KNOWLEDGE).

A protocol (P, V) is perfectly (resp. statistically) honest-veriÔ¨Åer
zero-knowledge (HVZK), if there exists a PPT simulator S such
that the distribution ensembles {S(x)}x and {viewP
V (x)}x are
perfectly (resp. statistically) indistinguishable, for all inputs x in
the language of R.

Note that this deÔ¨Ånition only gives guarantees against veriÔ¨Åers
that do not deviate from the protocol speciÔ¨Åcation. Security against
arbitrarily behaving veriÔ¨Åers can be realized using the Fiat-Shamir
heuristic [29] to make the protocol non-interactive, which is also
supported by our compiler (although, as we will explain later, this
is currently outside of the scope of the veriÔ¨Åcation back-end).
The Œ£GSP-protocol. Most practical applications of ZK-PoKs are
proofs for pre-images under a group homomorphism œÜ : G ‚Üí H.
Depending on whether G is Ô¨Ånite or G ‚âÉ Z, (typically) either the
Œ£œÜ-, the Œ£exp-, or the Œ£GSP-protocol is used [2]. In the following
2For the completeness and zero-knowledge properties, we quantify
over all relations R in the range of R.

491we recapitulate the Œ£GSP-protocol, which is central for understand-
ing the remainder, as it is used for the running example. All the
mentioned techniques are also incorporated in ZKCrypt.

The so called Generalized Schnorr Protocol (Œ£GSP-protocol) can
be used to prove knowledge of pre-images under arbitrary exponen-
tiation homomorphisms, in particular including such with a hidden-
order co-domain. That is, it can be used for mappings of the form:

œÜ : Zm ‚Üí H : (w1, . . . , wm) 7‚Üí  m
Yi=1

gwi
1i , . . . ,

gwi

ui! .

m

Yi=1

In the protocol, an upper bound Ti on the absolute value of each
wi needs to be known. These values can be chosen arbitrarily
large, and required to assert that the protocol is (statistically) zero-
knowledge for wi ‚àà [‚àíTi, Ti]. The protocol Ô¨Çow and the parties‚Äô
algorithms are given in Figure 2, where ‚Ñì is a security parameter.

P(x, (w1, . . . , wm))

V(x)

$‚Üê[‚àí2Tic+2‚Ñì, 2Tic+2‚Ñì], 1 ‚â§ i ‚â§ m

ki
r ‚Üê œÜ(k1, . . . , km)

-

r

c



c $‚Üê C = {0, . . . , c+ ‚àí 1}

si ‚Üê ki + c(wi + Ti), 1 ‚â§ i ‚â§ m
s1, . . . , sm

-

= œÜ(s1 ‚àí cT1, . . . , sm ‚àí cTm)
?
‚àà [‚àí2Tic+2‚Ñì, 2Tic+2‚Ñì + 2Ti(c+ ‚àí 1)], 1 ‚â§ i ‚â§ m

rxc ?

si

Figure 2: Protocol Ô¨Çow of the Œ£GSP-protocol.

The Œ£GSP-protocol is statistically HVZK for arbitrary values of

c+ (the simulation error is upper-bounded by m/2‚Ñì).

Concerning generalized special soundness, the relation genera-
tor R picks a group H in which the generalized strong RSA as-
sumption [30] holds (i.e., given x $‚Üê H, it is hard to Ô¨Ånd (w, e) ‚àà
H √ó Z \ {‚àí1, 0, 1} such that x = we), and deÔ¨Ånes:

R(x, (¬µ, w))

.
= x = ¬µœÜ(w) ‚àß ¬µd = 1,

Here, œÜ is as before, the gij are generators of a large subgroup of
H with hidden order such that all relative discrete logarithms (i.e.,
all loggij
guv) are unknown to P, and d is the product of all primes
smaller than c+ dividing ord H.

The relation R‚Ä≤ is deÔ¨Åned as follows:

R‚Ä≤((r, c, s), (r, c‚Ä≤, s‚Ä≤))

.
= (c ‚àí c‚Ä≤)|(s ‚àí s‚Ä≤) .

It can be shown [27] that the conversations extracted in the Ô¨Årst step
of the knowledge extractor satisfy R‚Ä≤ with overwhelming probabil-
ity, given that H satisÔ¨Åes the generalized RSA assumption and œÜ
is deÔ¨Åned as above. Thus, the Œ£GSP-protocol satisÔ¨Åes DeÔ¨Ånition 2
and is a ZK-PoK for R‚Ä≤.

For instance, if n = pq is sampled as a strong RSA modulus,
H = Z‚àó
n and the gij all generate the quadratic residues modulo
n, we get d = 4 and knowledge of a pre-image is proved up to a
fourth root of unity.

In practice one often has to prove
Combination of proof goals.
knowledge of multiple, or one out of a set of secret values in one
step. This can be achieved by so-called And- and Or-compositions
[25]. To support our description of the Idemix example in the rest
of the paper we only require And-compositions of Œ£GSP-protocols
for homomorphisms œÜ1, . . . , œÜn. This can be realized by running a
single Œ£GSP-protocol for the homomorphism œÜ = œÜ1 √ó ¬∑ ¬∑ ¬∑ √ó œÜn.

4. GOAL RESOLUTION

ZKCrypt generates implementations for arbitrary Boolean And-
and Or-compositions of pre-image proofs under homomorphisms
and claims on the size of secrets. That is, besides claims on the
knowledge of pre-images also terms of the form w ‚àà [L, R] for
secret w and public L, R ‚àà Z are supported natively.

The Ô¨Årst compilation step consists of rewriting all semantic ex-
pressions to pre-image proofs, i.e., every term w ‚àà [L, R] is rewrit-
ten to a proof speciÔ¨Åcation of the following form [38, 40]:

ZPKh(w, r, w1, . . . , w8, r1, . . . , r8, rw, rL, rR) :

8

xw = gwhrw ‚àß

xi = gwi hri ‚àß

^i=1

8

Yi=5

xwi

i hrwi .

(2)

xwg‚àíL =

i hrL ‚àß gRx‚àí1
xwi

w =

4

Yi=1

Here, g and h are both random generators of a group of hidden
order (e.g., the quadratic residues modulo a strong RSA modulus
n). Further, logg h and logh g must be hard to compute. If such a
group is already used in the original proof goal, it may be reused.

4.1 A Cryptographic Perspective

We next describe how ZKCrypt deals with the formal veriÔ¨Åca-

tion of the goal translation stage.

The starting point in the goal resolution procedure is a (high-
level) goal G associated to a relation generation algorithm R, i.e.,
we aim to construct a Œ£-protocol for proving (in zero-knowledge)
knowledge of a witness w for a public input x such that R(x, w)
holds, for R sampled from R. The resolution procedure Ô¨Årst deÔ¨Ånes
a generator for a (lower-level) family of relations Rres associated
with a resolved goal Gres and then deÔ¨Ånes a translation algorithm
Translate(R, x, w) which, on input a relation R and a pair (x, w),
produces the description of a relation Rres and a pair (x‚Ä≤, w‚Ä≤). The
following properties must be satisÔ¨Åed by the Translate algorithm:

1. Completeness. On a valid input (R, x, w), i.e., where R
is in the range of R and R(x, w) holds, Translate outputs
triples (Rres, x‚Ä≤, w‚Ä≤) such that Rres is in the range of Rres,
and Rres(x‚Ä≤, w‚Ä≤) holds.

2. Soundness. There is an efÔ¨Åcient algorithm Recover such
that for all PPT adversaries A the following holds for
R $‚Üê R, (x, w) ‚àà R and (Rres, x‚Ä≤, w‚Ä≤) $‚Üê A(R, x, w):
if (Rres, x‚Ä≤) are in the range of Translate(R, x, w) and
Rres(x‚Ä≤, w‚Ä≤) holds, Recover(Rres, x‚Ä≤, w‚Ä≤) outputs Àúw such that
R(x, Àúw) holds with overwhelming probability.

3. Public veriÔ¨Åability. The public outputs of Translate, i.e.,
Rres and x‚Ä≤, can efÔ¨Åciently be checked to be in the correct
range for all valid public inputs (R, x).

4. Simulatability. There exists an efÔ¨Åcient simulator S which,
on input R sampled from R and x in the language that it de-
Ô¨Ånes, outputs (Rres, x‚Ä≤) with a distribution identical (or sta-
tistically close) to that produced by Translate(R, x, w) for a
valid witness w.

Intuitively, public veriÔ¨Åability allows the veriÔ¨Åer to check that
the prover provides a valid output of Translate, and hence rely on
the soundness of this algorithm. Simulatability is necessary for
the HVZK property, as simulating traces for the complete protocol
implies simulating the public outputs of Translate.

Now, to construct a protocol for goal G, one Ô¨Årst generates de-
scriptions of algorithms P‚Ä≤
2 and V‚Ä≤ of a Œ£-protocol for Gres, and
then deÔ¨Ånes the procedures for the high-level protocol as follows:

1, P‚Ä≤

492‚Ä¢ P1(x, w) runs Translate(R, x, w) to get (Rres, x‚Ä≤, w‚Ä≤), and

P‚Ä≤

1(x‚Ä≤, w‚Ä≤) to get (r‚Ä≤, st‚Ä≤), and returns

(r, st) = ((Rres, x‚Ä≤, r‚Ä≤), (Rres, x‚Ä≤, w‚Ä≤, st‚Ä≤)).

‚Ä¢ P2(x, w, c, st) recovers (Rres, x‚Ä≤, w‚Ä≤, st‚Ä≤) from st.
2(x‚Ä≤, w‚Ä≤, st‚Ä≤, c) to get s‚Ä≤ and returns s = s‚Ä≤.

runs P‚Ä≤

It then

‚Ä¢ V(x, r, c, s) recovers (Rres, x‚Ä≤, r‚Ä≤) from r and checks that
Rres and x are in the correct range w.r.t. R and x. Then it
runs V‚Ä≤(x‚Ä≤, r‚Ä≤, c, s) and returns the result.

The correctness and security of the resulting protocol is established
in the following theorem.

THEOREM 1. Assume that algorithms P‚Ä≤

2 and V‚Ä≤ yield a
Œ£-protocol for Rres, which is complete, HVZK and satisÔ¨Åes gen-
eralized special soundness for relation R‚Ä≤
res. Then, if Translate
satisÔ¨Åes the four properties listed above, algorithms P1, P2 and V
yield a Œ£-protocol for R, which is complete, HVZK and satisÔ¨Åes
generalized special soundness for relation

1, P‚Ä≤

R‚Ä≤((Rres, x‚Ä≤, r‚Ä≤), c, s), (Rres, x‚Ä≤, r‚Ä≤), ÀÜc, ÀÜs)) = R‚Ä≤

res((r‚Ä≤, c, s), (r, ÀÜc, ÀÜs))

This result permits identifying the proof obligations that sufÔ¨Åce to
formally verify that the resulting protocol is correct and secure.
First of all, one needs to show that the low-level protocol is itself
correct and secure for the relation generator Rres (in ZKCrypt this
maps to the formal veriÔ¨Åcation of subsequent compilation steps,
which we discuss later). Secondly, one needs to show that the
Translate procedure has all properties described in the theorem.
Idemix goal resolution. To make things more concrete, let us go
back to the goal resolution performed by ZKCrypt and recast the
rewriting performed for a term of the form w ‚â• b in the theoret-
ical framework above (an upper bound on w can be treated anal-
ogously). This matches the resolution of the proof goal in our
Idemix running example. From ¬ß2, and using x = Z/Rm1
, we
can rewrite the relation corresponding to goal G as

1

R(x, w)

.
= x = AeSvRm2

2 ‚àß m2 ‚â• b

(3)

Here, we have w = (e, m2, v). Similarly, using Y1 = T‚àÜZ b, the
relation associated with resolved goal Gres is:

Rres(x‚Ä≤, w‚Ä≤)

.
= x = AeSvRm2

2 ‚àß Y1 = Zm2 Sr‚àÜ ‚àß

Ti = Z ui Sri ‚àß T‚àÜ = gu1

1 gu2

2 gu3

3 gu4

4 SŒ±

(4)

4

^i=1

Here w‚Ä≤ = (e, m2, v, r‚àÜ, u1, u2, u3, u4, r1, r2, r3, r4, Œ±) and
x‚Ä≤ = (x, Y1, T1, T2, T3, T4, T‚àÜ). We observe that implicit in the
deÔ¨Ånition of these goals are the relation generators R and Rres that
produce descriptions of the (hidden order) groups and generators
that are used in the protocol. Furthermore, note that the resolved
goal Gres can be handled by the Œ£GSP protocol, for which ZKCrypt
can generate an implementation of a ZK-PoK protocol which is
proven to display the relevant security properties.

Figures 3 and 4 provide the pseudo-code of the Translate and
Recover algorithms for the Idemix example. Observe the dual
role of the Ti values in Gres: these values appear both as generators
in Rres, and as images in x‚Ä≤. As we will see, this is essential to
guarantee that witnesses for the original goal G can be recovered.
We will now discuss how we prove that these algorithms satisfy
the hypotheses of Theorem 1, from which we can conclude that
resolution is correct.

Translate(R, x, w):

Parse (A, S, R2, Z) ‚Üê R
Parse (e, m2, v) ‚Üê w
Find (u1, u2, u3, u4) s.t. m2 ‚àí b = u2
$‚Üê[0..2|n|2‚Ñì], for i = ‚àÜ, 1, 2, 3, 4
ri

1 + u2

2 + u2

3 + u2

4

Œ± ‚Üê r‚àÜ ‚àíP4

i=1 uiri

4 SŒ±

3 T u4

2 T u3

1 T u2

Ti ‚Üê Z ui Sri , for i = 1, 2, 3, 4
T‚àÜ ‚Üê T u1
Y1 ‚Üê T‚àÜZ b
(g1, g2, g3, g4) ‚Üê (T1, T2, T3, T4)
x‚Ä≤ ‚Üê (x, Y1, T1, T2, T3, T4, T‚àÜ)
w‚Ä≤ ‚Üê (e, m2, v, r‚àÜ, u1, u2, u3, u4, r1, r2, r3, r4, Œ±)
return (Rres, x‚Ä≤, w‚Ä≤)

Figure 3: Translate algorithm for Idemix example. Relations
R and Rres are as in (3) and (4).

Recover(Rres, x‚Ä≤, w‚Ä≤):

(e, m2, v, r‚àÜ, u1, u2, u3, u4, r1, r2, r3, r4, Œ±) ‚Üê w‚Ä≤
w ‚Üê (e, m2, v)
return w

Figure 4: Recover algorithm for Idemix example

4.2 A Formal VeriÔ¨Åcation Perspective

We will continue to rely on the Idemix example to illustrate our
approach to verifying the goal translation step. We Ô¨Årst show how
we use EasyCrypt [10] to prove that the Translate algorithm from
Figure 3 satisÔ¨Åes the completeness and soundness properties. We
then discuss how the simulatability and public veriÔ¨Åability proper-
ties are handled with a once-and-for-all proof for supported goals.
Completeness of Translate. The idea underlying the complete-
ness property is the following. Assume a prover knows w ‚â• b.
Then, by Lagrange‚Äôs Four Square Theorem [38], she can Ô¨Ånd in-
i . By choosing
i=1 uiri she
can now clearly perform the above proof. Formally verifying this
property using EasyCrypt is achieved by proving that the follow-
ing experiment always returns true for all R in the range of R and
all pairs (x, w) such that R(x, w) holds:

tegers u1, . . . , u4 such that m ‚àí b = P4
r‚àÜ, r1, . . . , r4 at random, and deÔ¨Åning Œ± = r‚àÜ ‚àíP4

i=1 u2

(Rres, x‚Ä≤, w‚Ä≤) $‚Üê Translate(R, x, w); return Rres(x‚Ä≤, w‚Ä≤)

The Translate algorithm is represented in EasyCrypt in a form
very close to its description in Figure 3, with the sole difference that
the decomposition of m2 ‚àí b as a sum of four squares is computed
by applying a function assumed to correctly implement Lagrange‚Äôs
decomposition. The proof itself is written as a series of game tran-
sitions, where the initial experiment is gradually transformed until
it is reduced to the trivial program that simply returns true. All
transitions are proved automatically by the tool.
Soundness of Translate. A detailed speciÔ¨Åcation of the Recover
.
algorithm for the Idemix example is given in Figure 4. Let m‚Ä≤
=
2 ‚â• b and, by the deÔ¨Ånition of Rres associ-
ated with Gres, we have that Z = AeSvRm1
2 . The correctness
of Recover thus hinges on the fact that R computationally guaran-
tees m2 = m‚Ä≤

2, down to the following assumption:

i + b. Clearly m‚Ä≤

P4

1 Rm2

i=1 u2

2

DEFINITION 4

(UNIQUE REPRESENTATION ASSUMPTION).
Let H be as before, and let Z and S be generators of H.
If a
PPT algorithm outputs (a, b), (a‚Ä≤, b‚Ä≤) ‚àà Z √ó Z such that
Z aSb = Z a‚Ä≤
then, with overwhelming probability, we have
that a = a‚Ä≤ ‚àß b = b‚Ä≤.

Sb‚Ä≤

Any witness w‚Ä≤ given to Recover, satisfying Rres(x‚Ä≤, w‚Ä≤), for pub-
licly validated Rres and x‚Ä≤, can be expressed in the following form:

Zm2 ‚àíbSr‚àÜ = Zm‚Ä≤

2‚àíbSŒ±+P4

i=1 riui

493If m2 6= m‚Ä≤
2, the input witness would provide two alternative repre-
sentations for the same value under generators Z and S, contradict-
ing the unique representation assumption. Thus, necessarily with
overwhelming probability m2 = m‚Ä≤
2.

Formally, if the group parameters are generated in a particular
way, the unique representation assumption can be shown to hold in
n, down to the hardness of factoring the modulus n [19],
H = Z‚àó
e.g. when n is sampled as a strong RSA modulus. The Idemix
speciÔ¨Åcation incorporates this method into its parameter generation
procedure. We note that this computational assumption is used im-
plicitly throughout relevant literature when dealing with such trans-
formations. We believe that forcing such assumptions to be stated
explicitly is one of the advantages of using mechanized support to
validate security proofs for cryptographic protocols.

The correctness of this algorithm is again formally veriÔ¨Åed in
EasyCrypt. The proof is more intricate than in the case of Trans-
late, since we now must take into account the unique representation
assumption. The proof is quantiÔ¨Åed for all relations R in the range
of R, and all x and w such that R(x, w) holds. Consistently with
the deÔ¨Ånition of the soundness property, we begin by deÔ¨Åning the
following experiment in EasyCrypt:

(Rres, x‚Ä≤, w‚Ä≤) $‚Üê A(R, x, w);
w‚àó ‚Üê Recover(Rres, x‚Ä≤, w‚Ä≤);
if ¬¨Rres(x‚Ä≤, w‚Ä≤) ‚à® ¬¨pubVerify(R, x, Rres, x‚Ä≤) then return ‚ä•
else return R(x, w‚àó)

Here, an adversary (i.e., a malicious prover) A is given such an
input (R, x, w), and outputs a tuple (Rres, x‚Ä≤, w‚Ä≤). The Recover
algorithm is then called to produce a high-level witness. The ex-
periment output expresses that the event in which the adversary
produces a valid tuple (Rres, x‚Ä≤, w‚Ä≤) must imply that Recover suc-
ceeds in obtaining a valid high-level witness w‚àó. This is expressed
as a disjunction where either the adversary fails to produce publicly
veriÔ¨Åable Rres, x‚Ä≤ and a witness w‚Ä≤ such that Rres(x‚Ä≤, w‚Ä≤) holds,
or Recover must succeed. Public veriÔ¨Åability is captured by a
predicate pubVerify imposing that Y1 = T‚àÜZ b, and gi = Ti for
i = 1, 2, 3, 4.

The proof establishes that this experiment is identical to the triv-
ial program that always returns true, conditioning on a failure
event that occurs when both Rres(x‚Ä≤, w‚Ä≤) and pubVerif(Rres, x‚Ä≤)
hold, but the witness w‚Ä≤ satisÔ¨Åes the following Boolean test:

i=1 u2

i + b ‚à® r‚àÜ 6=P4

i=1 riui + Œ±

m2 6=P4

Intuitively, this failure condition can be triggered only if the ad-
versary was able to recover a low level witness which contradicts
the unique representation assumption: in the proof we show that
the probability of failure is bounded by the probability that an ad-
versary B Ô¨Ånds two different representations for the same group
element under generators Z and S. On the other hand, condition-
ing on the event that failure does not occur, and through a series of
transformations involving algebraic manipulations, we show that
Recover always succeeds. Again, the validity of all transforma-
tions is handled automatically by EasyCrypt.
Integration and automation The above approach to formally ver-
ifying the goal resolution procedure was not integrated in earlier
versions of ZKCrypt. This meant that user intervention was re-
quired to deal with this compilation step, and hence the natural
back-end to use was EasyCrypt. This was not a major limitation
because in many practical scenarios, including Idemix, the output
of goal resolution is the speciÔ¨Åcation of the proof goal. Neverthe-
less, the latest release of ZKCrypt has been extended with an extra
component that deals with this compilation step without user inter-
vention. Formal veriÔ¨Åcation of this phase is handled in two steps:

1. Given a high-level goal G, a certiÔ¨Åed goal resolution module
implemented in Coq generates a description of a reference
low-level goal Gref
res and a description of the translation and re-
covery procedures. A once-and-for-all proof in Coq guaran-
tees that translation is complete and sound for the reference
low-level goal. This is done using essentially the same for-
malization approach as described above, extended to handle
the general case of Œ£GSP-type goals where each pre-image
can be bounded with an arbitrary interval.

2. The resolved goal produced by the CACE compiler Gres is
then proven to be equivalent to Gref
res. This establishes that
the goal resolution step carried out by the CACE compiler is
indeed correct. The optimized implementation produced by
the CACE compiler is generated from Gres, as described in
the following Sections. This equivalence therefore provides
guarantees of correctness and security of the generated opti-
mized protocol with respect to the original high-level goal.

Public veriÔ¨Åability and simulatability. We now brieÔ¨Çy discuss why
the resolution procedure used in Idemix can be easily shown to sat-
isfy public veriÔ¨Åability and simulatability. This argument extends
to all instances of the resolution step implemented in ZKCrypt.

Looking at (4), one can immediately see that the public outputs
of Translate can be validated to be in the correct range assuming
that group membership can be efÔ¨Åciently checked, and given the
Ô¨Åxed structure of the low-level relation. For simulatability we see
that the description (Rres, x‚Ä≤) output by Translate comprises the
values of the images x‚Ä≤ = (x, Y1, T1, T2, T3, T4, T‚àÜ) and genera-
tors (g1, g2, g3, g4) = (T1, T2, T3, T4). Since x and Y1 are fully
determined by public inputs and (T1, T2, T3, T4, T‚àÜ), all that re-
mains to show is that the latter values can be efÔ¨Åciently simulated.
Observing that the domain of ri is sufÔ¨Åciently large for the distribu-
tion of Sri (i ‚àà {1, 2, 3, 4, ‚àÜ}) to be statistically close to uniform
in hSi, we conclude that the variables Ti are also statistically close
to uniform (note that Z and S are both generators of the same group
of hidden order). It follows that these values can be trivially simu-
lated by sampling uniformly random elements in the target group.

5. VERIFIED COMPILATION

At the core of the formal veriÔ¨Åcation tool of ZKCrypt sits a ver-
iÔ¨Åed compiler that generates correct and secure reference imple-
mentations of ZK-PoK for the following class of resolved proof
goals produced by the front end of the compiler:

(i) Atomic goals consisting of pre-image proofs under a homo-
morphism with a Ô¨Ånite domain using the Œ£œÜ-protocol, includ-
ing product homomorphisms where the co-domain is a tuple
of images in the range of the group operation.

(ii) Atomic goals consisting of pre-image proofs under an expo-
nentiation homomorphism in a hidden-order group using the
Œ£GSP-protocol, including product homomorphisms where the
co-domain is a tuple of images in the range of the group op-
eration. In particular, these include goals resulting from the
resolution of interval proofs as described in ¬ß4.

(iii) Arbitrary, possibly nested, AND- and OR-compositions of

proof goals as in point (i).

We stress that, although the code generation component of
ZKCrypt addresses an even broader set of proof goals, this class
was selected to cover essentially all practical applications. Indeed,
although we do not support compositions of Œ£GSP-protocol, this
is only a restriction for OR-compositions, which are rarely used

494P1hGresi(x, w):

$‚Üê stTypehGresi

stP
r ‚Üê Prover1hGresi(x, w, stP )
return (r, stP )

VchGresi():

c $‚Üê cTypehGresi
return c

P2hGresi(x, w, c, stP ):

VhGresi(x, r, c, s):

s ‚Üê Prover2hGresi(x, w, c, stP )
return s

a ‚Üê VeriÔ¨ÅerhGresi(x, r, c, s)
return a

Figure 5: Descriptions of reference implementations.

in practice. Flat AND-compositions can be achieved with product
homomorphisms.

Given a resolved proof goal Gres, the veriÔ¨Åed compiler is able
to generate a description of a reference implementation for a suit-
able Œ£-protocol, consisting of CertiCrypt programs corresponding
to algorithms P1, P2, V and Vc. The generated descriptions of
these algorithms follow a carefully designed structure, tailored to
facilitate the formal proof that, for any goal, the (therefore) veriÔ¨Åed
compiler produces correct and secure reference implementations.

The challenge here was to Ô¨Ånd the best balance between the
level of abstraction at which the formalization is performed in Cer-
tiCrypt, and our goal to give formal veriÔ¨Åcation guarantees over
the optimized implementations generated by ZKCrypt. On the
one hand, proving that the reference implementations meet the pre-
scribed correctness and security requirements is much easier if one
can reason abstractly about homomorphisms, group operations, etc.
On the other hand, we wish to prove observational equivalence to
programs produced by ZKCrypt in what is essentially pseudo-code
of an imperative language very close to common programming
languages. We achieve a compromise between these two aspects,
which enables us to reach both objectives simultaneously.

Concretely, we construct each algorithm as shown in Figure 5,
where we introduce annotations between angle brackets as in
XhGresi to make explicit the goal G an object X corresponds to.

Note that all algorithms have at most two statements: a random
assignment that samples all necessary random values up-front, and
a deterministic assignment that computes the output in terms of the
input of the algorithm and the sampled random values. For exam-
ple, in algorithm P1hGresi, the Ô¨Årst operation corresponds to sam-
pling a tuple uniformly at random from the set stTypehGresi, which
corresponds to a Cartesian product of sets derived from the proof
goal Gres. The second statement consists of a single assignment
that evaluates a function of the inputs of the algorithm and the ran-
domly sampled tuple; this is typically a huge expression performing
all the necessary parsing and algebraic computations. More pre-
cisely, functions Prover1hGresi, Prover2hGresi and VeriÔ¨ÅerhGresi
may map to arbitrarily complex CertiCrypt expressions.

We observe that by restricting the reference implementation of
protocols to the form shown in Figure 5 we do not lose general-
ity. Indeed, this form is achievable for all goals, including those
comprising arbitrary (possibly nested) Boolean compositions of
atomic goals, which is a non-trivial aspect of the formalization ap-
proach adopted in ZKCrypt. Intuitively, for atomic goals, the com-
putations performed by the reference implementation correspond
to those described in ¬ß3 for the Œ£œÜ- and Œ£GSP- protocols. For
Boolean combinations of Œ£œÜ-protocols, the reference implemen-
tation is generated recursively by unfolding the inductively deÔ¨Åned
proof goal according to the standard procedures for Boolean com-
position described in ¬ß3. This is made possible by our approach
to isolating random sampling operations from other computations.
For illustrative purposes we present a short excerpt of the deÔ¨Åni-
tion of the prover function Prover1 in Listing 1. The excerpt corre-
sponds to the case of Boolean compositions of proof goals that can
be handled using the Œ£œÜ-protocol, and takes as input a pair (x, w)

and the value stP comprising all values randomly sampled by the
P1hGresi algorithm. The base case maps to a concrete homomor-
phism, whereas recursive calls construct homomorphisms for And
and Or combinations.

Listing 1: DeÔ¨Ånition of algorithm Prover1 in Coq.

F i x p o i n t p r o v e r _ p h i g :

( DomType g ) ‚Üí e x p r
( TGtype ( RandTG g ) ) ‚Üí e x p r

e x p r
e x p r
match g w i t h
| Hom ( PhiHom A B h ) ‚áí f u n w x ‚áí phiHom h
| And g1 g2 ‚áí f u n w x ps ‚áí

( CodomType g ) ‚Üí

( CodomType g )

: =

( p r o v e r _ p h i
p r o v e r _ p h i

( F s t w)
( Snd w)

( F s t x )
( Snd x )

( F s t ps )
( Snd ps )

|
)

| Or g1 g2 ‚áí f u n w x ps ‚áí

IF I s L (w) THEN
( p r o v e r _ p h i

( P r o j L w)

( F s t x )

( F s t

( Snd ps ) )

|

s i m _ p h i

( Snd x )

( F s t ps )

( Snd ( Snd ps ) )

ELSE
(

s i m _ p h i
p r o v e r _ p h i

( F s t x )

( F s t ps )

( P r o j r w)

( F s t
( Snd x )

( Snd ps ) )

( Snd ( Snd ps ) )

)

)

|

end

In addition to the descriptions of reference implementations for
the algorithms of Œ£-protocols, the compiler also generates the aux-
iliary algorithms that are required to establish security. In particu-
lar, for each goal, the compiler generates deÔ¨Ånitions of a suitable
simulator and special extractor that can be used in the theorem
statements that capture the zero-knowledge and proof of knowl-
edge properties. The ability to generate suitable simulators is also
an essential part of generating ZK-PoK protocols for Or compo-
sitions of Œ£œÜ-protocols. Indeed, the deÔ¨Ånitions of algorithms P1
and P2 explicitly rely on the simulator descriptions as part of their
code, as can be seen in the snippet in Listing 1: in Or-compositions,
the prover uses as a sub-procedure the simulator of the protocol for
which it does not know a witness.

We discuss next how we prove the correctness and security prop-

erties of reference implementations for all supported proof goals.
Completeness. Completeness of reference implementations is
given by the CertiCrypt theorem below.

THEOREM 2

(COMPLETENESS). For all supported goals
Gres, and all pairs (x, w) satisfying the associated relation, we
prove

c $‚Üê VchGresi();
(r, stP ) $‚Üê P1hGresi(x, w);
s ‚Üê P2hGresi(x, w, c, stP );
a ‚Üê VhGresi(x, r, c, s)

‚âà{a}

0

a ‚Üê true

Intuitively, this formalization states that in an honest execution, the
veriÔ¨Åer always will accept. Observe that, also in the protocol def-
inition, the challenge generation is hoisted to the beginning of the
protocol, as this facilitates proving equivalence claims. This is a
valid transformation because we only have to prove that properties
hold for an honest veriÔ¨Åer that does not deviate from the protocol.
The proof of this theorem requires combined reasoning about the
algebraic manipulations performed by the protocol parties. This is
particularly challenging in the case of goals based on Œ£œÜ, for which
the proof is by induction on the structure of the goal, dealing with
the recursive deÔ¨Ånitions of the algorithms themselves. For exam-
ple, in Or-compositions one needs to deal with the rearrangement
of recursive calls, by establishing intermediate results of the form:

(r, c, s, a) $‚Üê ProtocolhG1 ‚à® G2i(x, Œπ1(w1)) ‚âà{r,c,s,a}
(r1, c1, s1, a1) $‚Üê ProtocolhG1i(œÄ1(x), w1);
c $‚Üê cTypehGresi; c2 ‚Üê c ‚àí c1;
(r2, c2, s2, a2) $‚Üê ShG2i(œÄ2(x), c2);
r ‚Üê (r1, r2); a ‚Üê a1 ‚àß a2

0

495This result states that the behavior of the protocol, when run on the
prover side with the witnesses corresponding to goal G1 is identical
to that of another procedure which explicitly relies on a protocol for
goal G1 and a simulator for goal G2. The proof of this equivalence
must then make use of the recursive deÔ¨Ånition of the protocol (itself
based on the prover and veriÔ¨Åer algorithms presented in Figure 5)
and of the simulator, and requires proving that the needed code
rearrangements do not modify the semantics of the experiments.
HVZK. Honest veriÔ¨Åer ZK of reference implementations is given
by the CertiCrypt theorem below.

THEOREM 3

(HVZK). For all supported goals Gres, and for
all pairs (x, w) satisfying the relation associated with Gres, we
prove the following statistical equivalence:

c $‚Üê VchGresi();
(r, stP ) $‚Üê P1hGresi(x, w);
s ‚Üê P2hGresi(x, w, c, stP );
a ‚Üê VhGresi(x, r, c, s)

‚âà{r,c,s}
«´hGresi

(r, c, s) $‚Üê ShGresi(x)

Here, ShGresi is the simulator algorithm generated by ZKCrypt
for goal Gres. The concrete value of the statistical distance between
the distributions depends on the goal. For the particular case of
Œ£œÜ-protocols and Boolean combinations thereof, this is actually
0, and so proving this property corresponds to showing that the
distributions are identical, implying perfect HVZK. In this case,
the type of reasoning required to construct the proof is very similar
to that described for completeness.

On the contrary, proving the zero knowledge property of Œ£GSP-
protocols constitutes a signiÔ¨Åcant challenge because it requires rea-
soning about statistical distance. Given any Œ£GSP goal Gres deÔ¨Åned
over a homomorphism where the co-domain is a tuple of arbitrary
size m, we bound the statistical distance in the statement above by
«´hGresi = m/2‚Ñì, where ‚Ñì is a concrete security parameter given
as input to the compiler along with the goal speciÔ¨Åcation (see ¬ß3).
Establishing this result for arbitrary homomorphisms required rea-
soning about the number of points contained in hypercubes in Zm,
and proving the upper bound using Bernoulli‚Äôs inequality.
Proof of Knowledge. The following CertiCrypt theorem ensures
that all generated reference implementations satisfy the General-
ized Special Soundness introduced in ¬ß3.

THEOREM 4

every

(PROOF OF KNOWLEDGE). For

sup-
ported valid goals Gres,
for all (x, w) satisfying the relation
associated with Gres, and for any two accepting conversations
(r, c, s) and (r, c‚Ä≤, s‚Ä≤) satisfying relation R‚Ä≤hGresi,

RhGresi(x, EhGresi(r, c, c‚Ä≤, s, s‚Ä≤)) = true .

The theorem statement nicely matches DeÔ¨Ånition 2, where re-
lation R‚Ä≤hGresi expresses the restriction on traces described in ¬ß3
for either Œ£œÜ- or Œ£GSP- protocols, and EhGresi denotes the knowl-
edge extractor generated by the compiler. However, the theorem
includes an additional validity restriction on proof goals that we
now explain. Referring to ¬ß3, recall that for c+ > 2 both the
Œ£œÜ-protocol and the Œ£GSP-protocol can only be proven to satisfy
DeÔ¨Ånition 2 if the underlying homomorphisms satisfy an addi-
tional property. Our notion of proof goal validity captures these ex-
tra restrictions. Concretely, the validity requirement for Œ£œÜ goals
implies that all prime factors of special exponents for homomor-
phisms are greater than c+. For the Œ£GSP-protocol, the validity re-
quirement is as follows. Recall, from ¬ß3 that R typically samples
an RSA modulus n and deÔ¨Ånes a relation R as

R(x, (¬µ, w))

.
= x = ¬µœÜ(w) ‚àß ¬µd = 1

(mod n)

Here, d is the product of the primes dividing the order of the mul-
tiplicative group modulo n, which are less than or equal to c+. We
require for validity that d satisÔ¨Åes this property.

Proving this theorem in CertiCrypt posed a different sort of chal-
lenge when compared to the previous ones, as it is not formulated in
the form of a program equivalence statement. Essentially, it trans-
lates into a proof goal formulated over the semantics of the un-
derlying algebraic constructions. Here we make critical use of the
extensive Coq library that is included in ZKCrypt and that was de-
veloped to support the semantics of the data types included in the
necessary CertiCrypt extensions. In turn, this library makes inten-
sive use of SSReÔ¨Çect [35] and its comprehensive Coq library on
algebraic and number theoretic results.

6.

IMPLEMENTATION

To establish our ultimate veriÔ¨Åcation goal, we translate the opti-
mized implementations of protocols generated by ZKCrypt to the
language of CertiCrypt. By taking advantage of the convenient
notation that ZKCrypt automatically sets up in CertiCrypt, this
translation step is straightforward and essentially corresponds to
pretty-printing the output implementation Ô¨Åles. Our strategy to for-
mally verify these optimized implementations is to Ô¨Årst establish
an intermediate result stating that these are correct with respect to
a reference implementation. More precisely, we establish that each
of the algorithms in the implementation Ô¨Åle, namely P1, P2, V, and
Vc, are observationally equivalent to the corresponding algorithms
in the reference implementation. These results are formalized in
CertiCrypt by lemmas that typically look as the one below.

LEMMA 1

(CORRECTNESS OF P1). For all (x, w) in the do-
main of relation R, associated with resolved goal Gres, the following
equivalence holds:

(r, stP ) $‚Üê P1(x, w) ‚âà{r,stP }

0

(r, stP ) $‚Üê Pref

1 hGresi(x, w)

Here Pref
1

refers to the reference implementation for algorithm
P1. Equivalence is formalized by imposing that, for any possi-
ble Ô¨Åxed input, the outputs of both algorithms are identically dis-
tributed. Several differences between the reference and optimized
implementations make proving these lemmas non trivial:

1. The reference implementation is expressed at a slightly
higher level of abstraction than the optimized implementa-
tion. In particular, the reference implementation expresses
homomorphism computations as native operations in the
CertiCrypt language, whereas these are expanded as lower-
level operations over the underlying algebraic groups in the
optimized protocol implementation.

2. The reference implementation typically uses different lan-
guage constructions than the optimized protocol.
In par-
ticular, the reference implementation uses a minimum num-
ber of statements and local variables, in exchange for more
elaborate expressions. For example, expressions in the ref-
erence implementation pack program variables into product
data types, and contain conditional expressions in order to
eliminate the need for if-then-else statements.

3. The ZK-compiler implementation may rearrange algebraic
expressions to enable the generation of optimized implemen-
tations by the lower-level code generators or back-ends.

Listing 2 shows an example observational equivalence proof goal
as it appears in CertiCrypt, extracted from the deniable authenti-
cation example included in the next section. The reference and
optimized implementations sit at the bottom and top, respectively.

496These differences between the two implementations that we have
described above are clearly visible in the code.

Listing 2: Equivalence proof goal in CertiCrypt.

EqObs {x , w} { r , s t , x ,w}

[ i f

I s L (w)

t h e n [

r 1
‚Üê Gs ;
$
t 1 ‚Üê [ g ]
t 2 ‚Üê [ h ]

[
e l s e
c1
‚Üê c s ;
$
t 1 ‚Üê [ g ]
F s t
t 2 ‚Üê [ h ]

[ ^H]
[ ^H]

( [ G t o _ n a t ]
( [ G t o _ n a t ]

r 1 ) ;
r 1 )

]

s1
‚Üê Gs ;
$
[ ^H]
( F s t _x )
[ ^H]

( [ G t o _ n a t ]

s1 )

[ / H]

[ ^H]

( [ c t o _ n a t ] c1 ) ;

( [ G t o _ n a t ]

s1 )

[ / H]

Snd ( F s t _x )

[ ^H]

( [ c t o _ n a t ] c1 )

] ;

I f

! I s L (w)
‚Üê Gs ;
r 2
$
[
e l s e
c2
‚Üê c s ;
$
t 3 ‚Üê [ g ]

t h e n [

t 3 ‚Üê [ g ]

[ ^H]

( [ G t o _ n a t ]

r 2 )

]

s2
‚Üê Gs ;
$
[ ^H]

( [ G t o _ n a t ]

s2 )

[ / H]

Snd _x [ ^H]

( [ c t o _ n a t ] c2 )

] ;

r ‚Üê ( ( t 1 |
s t ‚Üê IF I s L (w) THEN ( c2 | ( r 1 | s2 ) )
ELSE ( c1 | ( s1 | r 2 ) ) ;

t 3 ) ;

t 2 )

|

]

[ s t

‚Üê E . Dprod c s
$

( E . Dprod Gs Gs ) ;

r ‚Üê IF I s L (w) THEN

( [ p h i ] F s t
( Snd s t )
[ p s i ] Snd ( Snd s t )
Snd _x [ ^H]

|
[ / H]
( [ c t o _ n a t ]

( F s t

s t ) ) )

ELSE

( ( F s t

( [ p h i ] F s t

( Snd s t ) )

[ / H]

[ ^H]

( F s t _x )

F s t
Snd ( [ p h i ] F s t
Snd ( F s t _x )
[ p s i ] Snd ( Snd s t )

[ ^H]

( [ c t o _ n a t ]
)

]

( F s t

s t ) ) )

|

( [ c t o _ n a t ]

( F s t

s t ) )

|

( Snd s t ) )

[ / H]

Pleasingly, our automation approach performed well in handling
such equivalence proofs, both for this example and for the ones
described in ¬ß7. SpeciÔ¨Åcally, we have found that tactics already
implemented in CertiCrypt are ideally suited to reduce proof goals
as the one in Listing 2 to lower-level veriÔ¨Åcation conditions over the
semantics of operators used to implement the algorithms. Thanks
to this, the problem of automation becomes one of constructing
Coq tactics that can solve these lower level goals. To do this, we
combine the powerful decision procedures ring and omega built
into Coq with customized tactics that handle patterns observed in
a comprehensive set of practical examples.
Combining the results. Once the equivalence lemmas above are es-
tablished, generic proof scripts are used to discharge the proof obli-
gations associated with completeness, HVZK, and generalized spe-
cial soundness of optimized implementations. The theorem state-
ments are identical to those in ¬ß5 for the reference implementations
produced by ZKCrypt, but their proofs are essentially different. We
rely on a general lemma stating that any given algorithms P1, P2,
V, and Vc, observationally equivalent to the respective algorithms
in a reference implementation, lead to a protocol whose transcripts
are distributed exactly as in the reference implementation.

Proving the completeness and honest veriÔ¨Åer zero knowledge
properties of the optimized protocol then amounts to arguing that
these results are directly implied by the identical distributions dis-
played by reference and optimized protocol implementations. For
the soundness property, one appeals directly to the correctness of
the optimized V2 algorithm, which implies that an accepting trace
for the optimized protocol is a valid input to the knowledge extrac-
tor that is proven to exist for the reference implementation.

7. MORE EXPERIMENTS AND RESULTS
Besides the running example presented in the previous sections,
we also tested and veriÔ¨Åed the functionality of ZKCrypt based on

a representative set of proof goals of academic and practical inter-
est. We brieÔ¨Çy report on some of these applications to illustrate
the capabilities of ZKCrypt. We provide benchmarking results in
Table 1 in terms of lines of code of the implementations output
by the compiler and veriÔ¨Åcation time of formal proofs. We note
that the formal veriÔ¨Åcation component of ZKCrypt described in
this paper was developed in a way that is totally non-intrusive to
the original CACE compiler that generates the executable imple-
mentations, and hence the efÔ¨Åciency of the generated C- and Java-
implementations remains unaffected.
Electronic Cash. Electronic payment systems realize fully digi-
tal analogues of classical cash systems involving bills and coins.
Besides high security and privacy guarantees, real-world usability
requires that they work off-line, i.e., the bank must not be required
to participate in transactions. One of the Ô¨Årst schemes satisfying
this condition was suggested by Brands [14]. All phases of his
scheme use ZK-PoKs as sub-protocols. For instance, when with-
drawing money from a bank account, a user has to prove its identity
by proving possession of a secret key. The respective proof goal is
given as follows:

ZPKh (u1, u2) : I = gu1

1 gu2

2 i.

Here, I, g1, g2 ‚àà Z‚àó
p such that ord g1 = ord g2 = q, where q|(p ‚àí
1) and p, q ‚àà P. The secrets u1, u2 are elements of Zq. This proof
goal can be realized by a single instance of the Œ£œÜ-protocol.
Deniable Authentication. Any Œ£-protocol can be transformed into
a non-interactive protocol using the Fiat-Shamir heuristic [29]. The
idea is to substitute the veriÔ¨Åer‚Äôs Ô¨Årst algorithm by a cryptographic
hash function: Instead of relying on V to choose the challenge c
uniformly at random, the prover computes c itself as c ‚Üê H(r),
where r is the commitment computed in its Ô¨Årst step. It then com-
putes its response s as in the original protocol. Upon receiving
(r, c, s), the veriÔ¨Åer checks whether the triple is an accepting con-
versation, and whether c = H(r).3

Clearly, proofs obtained in this way are not deniable. Namely,
the veriÔ¨Åer can convince a third party that it knows the prover‚Äôs
secret by just forwarding (r, c, s). This problem can be solved by
migrating to designated veriÔ¨Åer ZK proofs: assume a public key
infrastructure, where each party deposits a public key. The prover
then shows that it either knows the secret key for its own public key,
or the secret key of the veriÔ¨Åer. The resulting authentication scheme
is deniable, as V could simulate proofs using its own secret key.

To make things concrete, we brieÔ¨Çy recap the scheme of Wang
and Song [51] here. A party A holds a secret key xA ‚àà Zq, and pub-
lishes the corresponding public key yA = (y1A, y2A) = (gxA, hxA ),
where q ‚àà P and g, h are elements of Z‚àó
p with order q. Now, au-
thenticating P towards V boils down to the following proof goal:

ZPKh (xP , xV ) : (y1P = gxP ‚àß y2P = hxP ) ‚à® y1V = gxVi.

As the order q of g, h is known, this proof goal can be realized
using the Œ£œÜ-protocol and Boolean compositions [25].
Ring Signatures. A ring signature scheme allows a set of parties to
sign documents on behalf of the whole group [48], without reveal-
ing the identities of the signers. Such schemes are often realized
by modifying the Fiat-Shamir transformation as follows: instead of
setting c ‚Üê H(r), the prover sets c ‚Üê H(r, m), hashing the pair
(m, r) where m is the message to be signed.

In a very basic scenario one wants to allow each member of the
group to issue signatures on behalf of the group. Let therefore be
3Currently,
the Fiat-Shamir heuristic is implemented at code-
generation, so formal veriÔ¨Åcation only covers the original protocol.

497TYPE COMPOSITIONS HLL (LOC)
23
Œ£œÜ
Electronic Cash
31
Deniable Authentication Œ£œÜ
37
Œ£œÜ
Ring Signatures
23
Œ£GSP
Identity Mixer

None
And, Or
Or
And

PIL (LOC) CertiCrypt (LOC) VERIFICATION
< 2m
< 3m
< 4m
< 25m

1288
1383
1384
1515

59
89
110
134

Table 1: Benchmark results for representative applications of ZKCrypt. The Ô¨Årst two columns describe the type and complexity
of the protocol required to realize the proof goal. ZK, PIL and CertiCrypt denote the lines of code of the high-level input Ô¨Åle, the
generated protocol and the formal proof. VERIFICATION denotes the duration of generating and verifying the proofs in CertiCrypt.

given a PKI containing public keys (yA, eA) ‚àà Z‚àó
nA √ó Z for strong
RSA moduli nA, and let each party A hold its secret key xA sat-
isfying yA = xeA
A . For simplicity, assume further that the group
consists of only three parties. Then the proof goal is given by:

1 ‚à® y2 = xe2

2 ‚à® y3 = xe3

3 i.

ZPKh (x1, x2, x3) : y1 = xe1

Again, as the domain of each mapping x 7‚Üí xei is Ô¨Ånite, realization
is done using the Œ£œÜ-protocol and Boolean compositions [25].
Summary. Our experimental results illustrate that ZKCrypt is Ô¨Çex-
ible enough to generate and verify implementations for a large set
of proof goals occurring in practically relevant applications. We ob-
serve that, although proof veriÔ¨Åcation is performed automatically,
the performance of the developed Coq/Certicrypt tactics degrades
signiÔ¨Åcantly for proof goals based on the Œ£GSP-protocol. This is
due to the complexity of the formalization of the underlying alge-
braic structures, which involve the deÔ¨Ånition of product homomor-
phisms with a large number of inputs and outputs.

8. RELATED WORK

Cryptographic compilers for ZK-PoK were studied before in two
different lines of work; in the setting of the CACE project [2, 5, 6,
16] and for e-cash applications [43].

The CACE compiler is a certifying compiler that generates efÔ¨Å-
cient implementations of zero-knowledge protocols. The compiler
takes moderately abstract speciÔ¨Åcations of proof goals as input and
generates C or Java implementations. The core compilation steps
(i.e., all but the backends) are certifying in the sense that they gener-
ate an Isabelle [46] proof of the existence of a knowledge extractor
guaranteeing special soundness. However, neither the fundamental
zero-knowledge property nor completeness are addressed by the
compiler, and the veriÔ¨Åcation component only supports a very lim-
ited set of proof goals, not including the Œ£GSP-protocol. ZKCrypt
builds on the compilation functionality of the CACE compiler,
adding a new front-end and a completely reengineered veriÔ¨Åcation
component. Moreover, it solves several minor bugs, some of which
were uncovered as a direct consequence of the new formal veriÔ¨Åca-
tion back-end development.

The ZKPDL compiler generates efÔ¨Åcient distributed implemen-
tations of ZK-PoKs from high-level goals [43]. It has been used to
build a realistic e-cash library. ZKPDL offers a level of abstraction
similar to ours, but foregoes any attempt to verify the generated
code and supports a more restricted set of proof goals.

Besides tools for ZK-PoK, a large variety of other domain spe-
ciÔ¨Åc compilers exists, e.g., Fairplay [42], VIFF [28] and the tool
described in [41] for generating implementations of secure two-
party computations. Also, generic cryptographic compilers of-
fering differently abstract input languages have been proposed,
e.g., [4, 7, 37, 50]. However, none of those tools supports formal
veriÔ¨Åcation.

A number of works have considered applications of formal ver-
iÔ¨Åcation to ZK-PoK. Barthe et al. [11] use CertiCrypt to prove
soundness, completeness, and zero-knowledge of Œ£œÜ-protocols and

simple And/Or-compositions thereof. Although these results were
constructed by hand and needed to be extended for a wider range of
proof goals and arbitrary Boolean compositions, they are at the gen-
esis of the formal veriÔ¨Åcation infrastructure of ZKCrypt. Backes et
al. [3] propose a method for checking that zero-knowledge proofs
are adequately used, and apply their method to the DAA protocol.

9. CONCLUSIONS

ZKCrypt is an experimental high-assurance zero-knowledge
compiler that applies state-of-the-art approaches in veriÔ¨Åed and
verifying compilation to the realm of cryptography.
It achieves
an unprecedented level of conÔ¨Ådence among cryptographic com-
pilers. The veriÔ¨Åcation infrastructure of ZKCrypt is based on the
CertiCrypt platform, and relies on a set of carefully isolated con-
cepts, including a new uniÔ¨Åed approach to special soundness and
a novel formal treatment of goal resolution as a compilation step.
We demonstrated that the compiler and the veriÔ¨Åcation component
are able to handle a large number of applications using ZK-PoKs.
There are plenty of avenues for future research in the Ô¨Åeld of
cryptographic compilation and veriÔ¨Åcation in general, and for the
class of ZK-PoKs in particular. One future task is to verify the last
stage of the compiler chain, code generation, to cover the entire
compilation process. An interesting question is how far veriÔ¨Åed
compilation can be extended beyond ZK-PoKs.

10. REFERENCES

[1] ABC4TRUST EU PROJECT. OfÔ¨Åcial Website.

https://abc4trust.eu/, 2011.

[2] ALMEIDA, J. B., BANGERTER, E., BARBOSA, M.,

KRENN, S., SADEGHI, A.-R., AND SCHNEIDER, T. A
Certifying Compiler for Zero-Knowledge Proofs of
Knowledge Based on Œ£-Protocols. In ESORICS ‚Äô10 (2010),
vol. 6345 of LNCS, Springer.

[3] BACKES, M., HRITCU, C., AND MAFFEI, M.

Type-Checking Zero-Knowledge. In ACM CCS 08 (2008),
ACM, pp. 357‚Äì370.

[4] BAIN, A., MITCHELL, J. C., SHARMA, R., STEFAN, D.,

AND ZIMMERMAN, J. A Domain-SpeciÔ¨Åc Language for
Computing on Encrypted Data (Invited Talk). In FSTTCS
2011 (2011), vol. 13 of LIPIcs, Schloss Dagstuhl, pp. 6‚Äì24.

[5] BANGERTER, E., BARZAN, S., KRENN, S., SADEGHI,

A.-R., SCHNEIDER, T., AND TSAY, J.-K. Bringing
zero-knowledge proofs of knowledge to practice. In SPW 09
(2009).

[6] BANGERTER, E., BRINER, T., HENEKA, W., KRENN, S.,

SADEGHI, A.-R., AND SCHNEIDER, T. Automatic
generation of Œ£-protocols. In EuroPKI 09 (2009).
[7] BANGERTER, E., KRENN, S., SEIFRIZ, M., AND

ULTES-NITSCHE, U. cPLC - A Cryptographic Programming
Language and Compiler. In ISSA 2011 (2011), IEEE.

498[8] BARTHE, G., GR√âGOIRE, B., AND B√âGUELIN, S. Formal

certiÔ¨Åcation of code-based cryptographic proofs. In POPL 09
(2009), pp. 90‚Äì101.

[9] BARTHE, G., GR√âGOIRE, B., HERAUD, S., OLMEDO, F.,

AND ZANELLA B√âGUELIN, S. VeriÔ¨Åed indifferentiable
hashing into elliptic curves. In POST 2012 (Heidelberg,
2012), LNCS, Springer.

[10] BARTHE, G., GR√âGOIRE, B., HERAUD, S., AND

ZANELLA B√âGUELIN, S. Computer-aided security proofs
for the working cryptographer. In CRYPTO 2011
(Heidelberg, 2011), vol. 6841 of LNCS, Springer, pp. 71‚Äì90.

[11] BARTHE, G., HEDIN, D., ZANELLA B√âGUELIN, S.,

GR√âGOIRE, B., AND HERAUD, S. A machine-checked
formalization of Œ£-protocols. In CSF 2010 (2010), IEEE.

[12] BARTHE, G., K√ñPF, B., OLMEDO, F., AND ZANELLA

B√âGUELIN, S. Probabilistic reasoning for differential
privacy. In POPL 2012 (2012), ACM.

[13] BORISOV, N., GOLDBERG, I., AND BREWER, E.

Off-the-Record Communication, or, why not to use PGP. In
WPES 2004 (2004), ACM, pp. 77‚Äì84.

[14] BRANDS, S. An EfÔ¨Åcient Off-line Electronic Cash System

Based on the Representation Problem. Tech. Rep. CS-R9323,
CWI, 1993.

[15] BRICKELL, E. F., CAMENISCH, J., AND CHEN, L. Direct

Anonymous Attestation. In ACM CCS 04 (2004), ACM.

[16] BRINER, T. Compiler for zero-knowledge proof-of-

knowledge protocols. Master‚Äôs thesis, ETH Zurich, 2004.

[17] CAMENISCH, J., AND HERREWEGHEN, E. V. Design and

Implementation of the idemix Anonymous Credential
System. In ACM CCS 02 (2002), ACM Press, pp. 21‚Äì30.
[18] CAMENISCH, J., AND LYSYANSKAYA, A. A Signature

Scheme with EfÔ¨Åcient Protocols. In SCN 02 (2002),
vol. 2576 of LNCS, Springer, pp. 268‚Äì289.

[19] CAMENISCH, J., AND SHOUP, V. Practical VeriÔ¨Åable
Encryption and Decryption of Discrete Logarithms. In
CRYPTO 03 (2003), vol. 2729 of LNCS, Springer.

[20] CAMENISCH, J., AND STADLER, M. EfÔ¨Åcient group

signature schemes for large groups. In CRYPTO 97 (1997),
vol. 1294 of LNCS, Springer, pp. 410‚Äì424.

[21] CAMENISCH et al., J. SpeciÔ¨Åcation of the Identity Mixer

Cryptographic Library (Version 2.3.0). Research Report RZ
3730 (#99740), IBM Research, 2010.

[22] CHAUM, D. Security without identiÔ¨Åcation: Transaction

systems to make big brother obsolete. Commun. ACM 28, 10
(1985), 1030‚Äì1044.

[23] CHAUM, D., AND EVERTSE, J.-H. A secure and

privacy-protecting protocol for transmitting personal
information between organizations. In CRYPTO (1986),
vol. 263 of LNCS, Springer, pp. 118‚Äì167.

[24] CRAMER, R. Modular Design of Secure yet Practical

Cryptographic Protocols. PhD thesis, CWI and University of
Amsterdam, 1997.

[25] CRAMER, R., DAMG√ÖRD, I., AND SCHOENMAKERS, B.

Proofs of partial knowledge and simpliÔ¨Åed design of witness
hiding protocols. In CRYPTO 94 (1994), vol. 839 of LNCS,
Springer, pp. 174‚Äì187.

[26] DAMG√ÖRD, I. On Œ£-protocols, 2004. Lecture on

Cryptologic Protocol Theory; Faculty of Science, University
of Aarhus.

[27] DAMG√ÖRD, I., AND FUJISAKI, E. A statistically-hiding
integer commitment scheme based on groups with hidden

order. In ASIACRYPT 02 (2002), vol. 2501 of LNCS,
Springer, pp. 77‚Äì85.

[28] DAMG√ÖRD, I., GEISLER, M., KR√òIGAARD, M., AND

NIELSEN, J. B. Asynchronous Multiparty Computation:
Theory and Implementation. In PKC 09 (2009), vol. 5443 of
LNCS, Springer, pp. 160‚Äì179.

[29] FIAT, A., AND SHAMIR, A. How to prove yourself:

practical solutions to identiÔ¨Åcation and signature problems.
In CRYPTO 86 (1987), vol. 263 of LNCS, Springer.
[30] FUJISAKI, E., AND OKAMOTO, T. Statistical zero

knowledge protocols to prove modular polynomial relations.
In CRYPTO 97 (1997), vol. 1294 of LNCS, Springer.

[31] GOLDBERG, I., USTAOGLU, B., GUNDY, M. V., AND

CHEN, H. Multi-party off-the-record messaging. In ACM
CCS 09 (2009), ACM, pp. 358‚Äì368.

[32] GOLDREICH, O. Zero-knowledge twenty years after its

invention. Tech. Rep. TR02-063, Electronic Colloquium on
Computational Complexity, 2002.

[33] GOLDREICH, O., MICALI, S., AND WIGDERSON, A.

Proofs that yield nothing but their validity or all languages in
NP have zero-knowledge proof systems. Journal of the ACM
38, 1 (1991), 691‚Äì729.

[34] GOLDWASSER, S., MICALI, S., AND RACKOFF, C. The

knowledge complexity of interactive proof-systems. In STOC
85 (1985), ACM, pp. 291‚Äì304.

[35] GONTHIER, G., MAHBOUBI, A., AND TASSI, E. A Small
Scale ReÔ¨Çection Extension for the Coq system. Rapport de
recherche RR-6455, INRIA, 2008.

[36] GUILLOU, L., AND QUISQUATER, J.-J. A ‚Äúparadoxical‚Äù

identity-based signature scheme resulting from
zero-knowledge. In CRYPTO 88 (1990), vol. 403 of LNCS,
Springer, pp. 216‚Äì231.

[37] KIYOMOTO, S., OTA, H., AND TANAKA, T. A Security
Protocol Compiler Generating C Source Codes. In ISA 08
(2008), IEEE, pp. 20‚Äì25.

[38] LAGRANGE, J. L. ≈íuvres, 1770.
[39] LEROY, X. Formal certiÔ¨Åcation of a compiler back-end or:

programming a compiler with a proof assistant. In POPL 06
(2006), ACM Press, pp. 42‚Äì54.

[40] LIPMAA, H. On diophantine complexity and statistical
zeroknowledge arguments. In ASIACRYPT 03 (2003),
vol. 2894 of LNCS, Springer, pp. 398‚Äì415.

[41] MACKENZIE, P., OPREA, A., REITER, M. Automatic
generation of two-party computations. In ACM CCS 03
(2003), ACM, pp. 210‚Äì219.

[42] MALKHI, D., NISAN, N., PINKAS, B., AND SELLA, Y.

Fairplay ‚Äì Secure two-party computation system. In USENIX
Security Symposium (2004), USENIX Association.

[43] MEIKLEJOHN, S., ERWAY, C., K√úP√á√ú, A., HINKLE, T.,

AND LYSYANSKAYA, A. ZKPDL: A Language-Based
System for EfÔ¨Åcient Zero-Knowledge Proofs and Electronic
Cash. In USENIX Security Symposium (2010), USENIX
Association, pp. 193‚Äì206.

[44] MICROSOFT. U-Prove.

http://www.microsoft.com/u-prove, 2011.

[45] NECULA, G. C., AND LEE, P. The design and

implementation of a certifying compiler. In PLDI (New
York, NY, USA, 1998), vol. 33, PUB-ACM, pp. 333‚Äì344.

[46] NIPKOW, T., AND PAULSON, L. Isabelle web site.

http://isabelle.in.tun.de, 2010.

499[47] RIAL, A., AND DANEZIS, G. Privacy-preserving smart

metering, 2011.

[48] RIVEST, R., SHAMIR, A., AND TAUMAN, Y. How to Leak a

Secret - Theory and Applications of Ring Signatures. In
ASIACRYPT 01 (2001), vol. 2248 of LNCS, Springer.

[49] SCHNORR, C. EfÔ¨Åcient signature generation by smart cards.

Journal of Cryptology 4, 3 (1991), 161‚Äì174.

[50] SCHR√ñPFER, A., KERSCHBAUM, F., BISWAS, D.,

GEISSINGER, S., AND SCH√úTZ, C. L1 - Faster
Development and Benchmarking of Cryptographic
Protocols. In SPEED-CC 09 (2009).

[51] WANG, B., AND SONG, Z. A Non-Interactive Deniable

Authentication Scheme Based on Designated VeriÔ¨Åer Proofs.
Information Sciences 179, 6 (2009), 858‚Äì865.

[52] ZUCK, L. D., PNUELI, A., GOLDBERG, B., BARRETT,
C. W., FANG, Y., AND HU, Y. Translation and run-time
validation of loop transformations. Formal Methods in
System Design 27, 3 (2005), 335‚Äì360.

APPENDIX

A. AN OVERVIEW OF CertiCrypt

CertiCrypt [8, 10] is an automated toolset for proving the se-
curity of cryptographic constructions in the computational model.
It builds upon state-of-the-art veriÔ¨Åcation technologies to support
code-based proofs, in which security is cast in terms of equivalence
of probabilistic programs. The core of CertiCrypt is a rich set of
veriÔ¨Åcation techniques based on a Relational Hoare Logic for prob-
abilistic programs [8]. A recent extension [9] supports reasoning
about a broad range of quantitative properties, including statistical
distance, which is crucial in our deÔ¨Ånition of zero-knowledge.

The CertiCrypt toolset consists of two main components. Both
allow proving that the distributions generated by probabilistic ex-
periments are identical or statistically close, but differ in their de-
gree of automation, Ô¨Çexibility and formal guarantees. The Ô¨Årst
component, called CertiCrypt, excels in Ô¨Çexibility and is fully for-
malized in the Coq proof assistant; its veriÔ¨Åcation methods are
implemented in Coq and proved correct w.r.t. program seman-
tics. The second component, EasyCrypt, delivers a higher de-
gree of automation by relying on SMT solvers and automated the-
orem provers to discharge veriÔ¨Åcation conditions arising in proofs.
EasyCrypt generates proof certiÔ¨Åcates that can be mechanically
checked in Coq, thus practically reducing the trusted computing
base to that of the Ô¨Årst component; however, it lacks on generality
as it only exposes a limited set of proof methods. ZKCrypt takes
advantage of both components: it uses the latter to check the cor-
rectness of goal resolution and the former for verifying the compiler
for reference implementations and the equivalence of reference and
optimized implementations. We outline below some of the essen-
tial features of both components.
Language. Programs are written in a procedural, probabilistic im-
perative language that includes deterministic and random assign-
ments, conditional statements and loops. This base language suf-
Ô¨Åces to conveniently express a wide class of cryptographic experi-
ments and security properties. However, to achieve greater Ô¨Çexibil-
ity, the language of deterministic and random expressions is user-
extensible. A program c in the language of CertiCrypt denotes a
function JcK from an initial memory m (a mapping from program
variables to values) to a distribution over Ô¨Ånal memories. We de-
note by Pr [c, S : m] the probability of event S w.r.t to the distri-
bution JcK m. We refer the reader to Barthe et al. [12] for a more
detailed description of the language and its semantics.

Reasoning principles. Proving the (approximate) equivalence of
the distributions generated by two probabilistic programs in Cer-
tiCrypt amounts to deriving valid judgments in an approximate Re-
lational Hoare Logic (apRHL). We restrict our attention in this pa-
per to a fragment of apRHL that captures both perfect and statisti-
cal indistinguishability of distributions generated by programs. We
consider judgments of the form c1 ‚àº«´ c2 : Œ® ‚áí Œ¶ where c1 and
c2 are probabilistic programs, Œ®, Œ¶ binary relations over program
memories and «´ ‚àà [0, 1]. Taking Œ¶ as the equality relation on a
subset of observable program variables X, one recovers the usual
deÔ¨Ånition of statistical indistinguishability. In particular, given an
event A, represented as a predicate over memories, if A only de-
pends on variables in X, one has

m1 Œ® m2 =‚áí |Pr [c1, m1 : A] ‚àí Pr [c2, m2 : A] | ‚â§ «´ .

«´

We let c1 ‚âàŒ®,X
c2 denote the validity of c1 ‚àº«´ c2 : Œ® ‚áí Œ¶ when
Œ¶ is the equality relation on variables in X; we omit Œ® when it is
the total relation or can be inferred from the context.

B.

INPUT FILE OF THE USE CASE

Figure 6 shows the input (a .zk-Ô¨Åle) for our running exam-
ple. It is obtained by instantiating the template CL(m1, m2) with
the mapping underlying the CL-signature scheme [18] (cf. Equa-
tion 1), as is already done in the identity mixer speciÔ¨Åcation. The
rest of the Ô¨Åle describes the algebraic setting and required security
goals.

The Ô¨Årst two blocks, Declarations and Inputs declare
all variables used in the protocol and the public and private in-
puts of the parties. Typically, variables will be declared as private
if and only if knowledge of these values has to be proved. The
Properties block speciÔ¨Åes the security properties and the over-
all structure of the protocol. The KnowledgeError of the gen-
erated protocol shall be at most 2‚àí80, and the statistical distance of
simulated from real protocol runs must be at most 2‚àíSZKParameter .
Inside ZKCrypt, the KnowledgeError parameter is translated
onto a concrete challenge length and SZKParameter gives the
security parameter controlling the tightness of the HVZK property.
The proof goal only consists of a single predicate. It shall be proved
using a SigmaGSP-protocol; the maximum ChallengeLength
that may safely be used for the homomorphism is speciÔ¨Åed (this
cannot be computed from phi as it would require to compute the
order of Zmod*(n)). For concrete values of n, i.e., strong RSA
moduli, this parameter implicitly gives the concrete value of d (the
product of all primes smaller than c+ dividing ord H) for which
the proof of knowledge property holds.

:= n, z, R_1, A, S, R_2, b;

Declarations {
Int(2048) n;
Zmod*(n)
z, R_1, R_2, A, S;
Int(1000) m_1, m_2, e, v, b;
}
Inputs {
Public
ProverPrivate := e, m_2, v;
}
Properties {
KnowledgeError
SZKParameter
ProtocolComposition := P_0;
}
SigmaGSP P_0 {
Homomorphism(phi: Z^3 -> Zmod*(n):

:= 80;
:= 80;

(e,m_2,v) |-> (A^e*S^v*R_2^m_2));

ChallengeLength := 80;
Relation(

(z*R_1^(-m_1)) = phi(e,m_2,v) And m_2 >= b); }

Figure 6: .zk-Ô¨Åle specifying Idemix proof goal G.

500