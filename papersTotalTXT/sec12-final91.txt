On Breaking SAML: Be Whoever You Want to Be

Juraj Somorovsky1, Andreas Mayer2, J¨org Schwenk1, Marco Kampmann1, and Meiko Jensen1

1Horst G¨ortz Institute for IT-Security, Ruhr-University Bochum, Germany

2Adolf W¨urth GmbH & Co. KG, K¨unzelsau-Gaisbach, Germany

{Juraj.Somorovsky, Joerg.Schwenk, Marco.Kampmann, Meiko.Jensen}@rub.de,

Andreas.Mayer@wuerth.com

Abstract

The Security Assertion Markup Language (SAML) is a
widely adopted language for making security statements
about subjects. It is a critical component for the develop-
ment of federated identity deployments and Single Sign-
On scenarios. In order to protect integrity and authentic-
ity of the exchanged SAML assertions, the XML Signa-
ture standard is applied. However, the signature veriﬁca-
tion algorithm is much more complex than in traditional
signature formats like PKCS#7. The integrity protection
can thus be successfully circumvented by application of
different XML Signature speciﬁc attacks, under a weak
adversarial model.

In this paper we describe an in-depth analysis of 14
major SAML frameworks and show that 11 of them,
including Salesforce, Shibboleth, and IBM XS40, have
critical XML Signature wrapping (XSW) vulnerabilities.
Based on our analysis, we developed an automated pen-
etration testing tool for XSW in SAML frameworks. Its
feasibility was proven by additional discovery of a new
XSW variant. We propose the ﬁrst framework to an-
alyze such attacks, which is based on the information
ﬂow between two components of the Relying Party. Sur-
prisingly, this analysis also yields efﬁcient and practical
countermeasures.

Introduction

1
The Security Assertion Markup Language (SAML) is an
XML based language designed for making security state-
ments about subjects. SAML assertions are used as se-
curity tokens in WS-Security, and in REST based Single
Sign-On (SSO) scenarios. SAML is supported by major
software vendors and open source projects, and is widely
deployed. Due to its ﬂexibility and broad support, new
application scenarios are deﬁned constantly.

SAML ASSERTIONS. Since SAML assertions con-
tain security critical claims about a subject, the validity
of these claims must be certiﬁed. According to the stan-

dard, this shall be achieved by using XML Signatures,
which should either cover the complete SAML assertion,
or an XML document containing it (e.g. a SAML Au-
thentication response).

However, roughly 80% of the SAML frameworks that
we evaluated could be broken by circumventing integrity
protection with novel XML Signature wrapping (XSW)
attacks. This surprising result is mainly due to two facts:
• Complex Signing Algorithm: Previous digital sig-
nature data formats like PKCS#7 and OpenPGP
compute a single hash of the whole document, and
signatures are simply appended to the document.
The XML Signature standard is much more com-
plex. Especially, the position of the signature and
the signed content is variable. Therefore, many per-
mutations of the same XML document exist.

• Unspeciﬁed internal

interface: Most SAML
frameworks treat the Relying Party (i.e.
the Web
Service or website consuming SAML assertions) as
a single block, assuming a joint common state for
all tasks. However, logically this block must be sub-
divided into the signature veriﬁcation module (later
called RPsig) which performs a cryptographic opera-
tion, and the SAML processing module (later called
RPclaims) which processes the claims contained in
the SAML assertion. Both modules have different
views on the assertion, and they typically only ex-
change a Boolean value about the validity of the sig-
nature.

CONTRIBUTION.

In this paper, we present an in-
depth analysis of 14 SAML frameworks and systems.
During this analysis, we found critical XSW vulnerabili-
ties in 11 of these frameworks. This result is alarming
given the importance of SAML in practice, especially
since SSO frameworks may become a single point of at-
tack.
It clearly indicates that the security implications
behind SAML and XML Signature are not understood
yet.

Second, these vulnerabilities are exploitable by an at-
tacker with far fewer resources than the classical network
based attacker from cryptography: Our adversary may
succeed even if he does not control the network. He does
not need realtime eavesdropping capabilities, but can
work with SAML assertions whose lifetime has expired.
A single signed SAML assertion is sufﬁcient to com-
pletely compromise a SAML issuer/Identity Provider.
Using SSL/TLS to encrypt SAML assertions, and thus to
prevent adversaries from learning assertions by intercept-
ing network trafﬁc, does not help either: The adversary
may e.g. register as a regular customer at the SAML is-
suer, and may use his own assertion to impersonate other
customers.

Third, we give the ﬁrst model for SAML frameworks
that takes into account the interface between RPsig and
RPclaims. This model gives a clear deﬁnition of successful
attacks on SAML. Besides its theoretical interest, it also
enables us to prove several positive results. These results
are new and help to explain why some of the frameworks
were not vulnerable to our attacks, and to give advice on
how to improve the security of the other 11 frameworks.

Last, we show that XSW vulnerabilities constitute an
important and broad class of attack vectors. There is no
easy defense against XSW attacks: Contrary to common
belief, even signing the whole document does not neces-
sarily protect against them. To set up working defenses,
a better understanding of this versatile attack class is re-
quired. A specialized XSW pentesting tool developed
during our research will be released as open source to aid
this understanding. Its practicability was proven by dis-
covering a new attack vector on Salesforce SAML inter-
face despite the fact that speciﬁc countermeasures have
been applied.

RESPONSIBLE DISCLOSURE. All vulnerabilities
found during our analysis were reported to the respon-
sible security teams. Accordingly, in many cases, we
closely collaborated with them in order to patch the
found issues.

OUTLINE. The rest of the paper is organized as fol-
lows. Section 2 gives a highlevel overview on SAML,
and Section 3 adds details. The methodology of the in-
vestigation is explained in Section 4, and the detailed re-
sults are described in Section 5. In Section 6 we present
the ﬁrst fully automated XSW penetration test tool for
SAML. Section 7 gives a formal analysis and derives two
countermeasures. In Section 8 we discuss their practi-
cal feasibility. Section 9 presents an overview on related
work. In the last section we conclude and propose future
research directions.

Figure 1: A typical Single Sign-On scenario: The user
visits the RP, which generates a request token. He redi-
rects this token to the IdP. The issued token is sent to the
user and forwarded to the RP. Even though the channel
is secured by SSL/TLS, the user still can see the token.

2 Motivation

In this section we introduce two typical SAML scenarios
and some widely used SAML frameworks.

SAML-BASED SINGLE SIGN-ON. Typical Internet
users have to manage many identities for different web
applications. To overcome this problem, Single Sign-On
was developed. In this approach the users authenticate
only once to a trustworthy Identity Provider (IdP). After
a successful login of a user, the IdP issues security to-
kens on demand. These tokens are used to authenticate
to Relying Parties (RP).

A simpliﬁed Single Sign-On scenario is depicted in
Figure 1. In this setting, a user logged-in by the IdP ﬁrst
visits the desired RP (1). The RP issues a token request
(2). This token is sent to the user (3) who forwards it
to the IdP (4). The IdP issues a token response for the
user including several claims (e.g. his access rights or
expiration time). In order to protect the authenticity and
integrity of the claims, the token is signed (5). Subse-
quently, the token is sent to the user (6), who forwards it
to the RP (7). The RP validates the signature and after-
wards grants access to the protected service or resource,
if the user is authorized (8). This access control decision
is based on the claims in the validated token.

SECURING WEB SERVICES WITH SAML. Another
typical application scenario is the use of SAML together
with WS-Security [29] in SOAP [21] to provide authen-
tication and authorization mechanisms to Web Services.
SAML assertions are included as security tokens in the
Security header.

SAML PROVIDERS AND FRAMEWORKS.

The
evaluation presented in this paper was made through-
out the last 18 months and includes prominent and well-
used SAML frameworks, which are summarized in Ta-
ble 1. Our analysis included the IBM hardware appliance

ClientRelying Party(RP)Identity Provider (IdP)45SAML ResponseTokenIssuing andSigningToken Redirect6Token Response7Token Redirect8Signature    validationToken  evaluationUser   authorization[SSL/TLS]3Token Request1LoginRequest[SSL/TLS]2SAML RequestTokenIssuingFramework/Provider
Apache Axis 2
Guanxi
Higgins 1.x
IBM XS40
JOSSO
WIF
OIOSAML
OpenAM
OneLogin
OpenAthens
OpenSAML
Salesforce
SimpleSAMLphp
WSO2

Type
WS

Web SSO
Web SSO

WS

Language
Java
Java
Java
XSLT
Java
.NET
Java, .NET
Java
Java, PHP, Ruby, Python
Java, C++
Java, C++

Web SSO
Web SSO
Web SSO
Web SSO
Web SSO
Web SSO
Web SSO
Web SSO —
Web SSO
Web SSO

PHP
Java

Reference
http://axis.apache.org
http://guanxi.sourceforge.net
www.eclipse.org/higgins
www.ibm.com
www.josso.org
http://msdn.microsoft.com
http://www.oiosaml.info
http://forgerock.com/openam.html
www.onelogin.com
www.openathens.net
http://opensaml.org
www.salesforce.com
http://simplesamlphp.org
www.wso2.com

Application
WSO2 Web Services
Sakai Project (www.sakaiproject.org)
Identity project
Enterprise XML Security Gateway
Motorola, NEC, Redhat
Microsoft Sharepoint 2010
Danish eGovernment (e.g. www.virk.dk)
Enterprise-Class Open Source SSO
Joomla, Wordpress, SugarCRM, Drupal
UK Federation (www.eduserv.org.uk)
Shibboleth, SuisseID
Cloud Computing and CRM
Danish e-ID Federation (www.wayf.dk)
eBay, Deutsche Bank, HP

Table 1: Analyzed SAML frameworks and providers: The columns give information about type (Web Service or
Browser-based SSO), programming language (if known), web site, and application in concrete products or frameworks.

XS40, which is applied as an XML Security Gateway.
Other examples of closed source frameworks are the
Windows Identity Foundation (WIF) used in Microsoft
Sharepoint and the Salesforce cloud platform. Important
open source frameworks include OpenSAML, OpenAM,
OIOSAML, OneLogin, and Apache Axis 2. OpenSAML
is for example used in Shibboleth and the SDK of the
electronic identity card from Switzerland (SuisseID).
OpenAM, formerly known as SUN OpenSSO, is an iden-
tity and access management middleware, used in major
enterprises. The OIOSAML framework is e.g. used in
Danish public sector federations (e.g. eGovernment busi-
ness and citizen portals). The OneLogin Toolkits inte-
grate SAML into various popular open source web appli-
cations like Wordpress, Joomla, Drupal, and SugarCRM.
Moreover, these Toolkits are used by many OneLogin
customers (e.g. Zendesk, Riskonnect, Zoho, Knowl-
edgeTree, and Yammer) to enable SAML-based SSO.
Apache Axis2 is the standard framework for generating
and deploying Web Service applications.

3 Technical Foundations

In this section we brieﬂy introduce the SAML standard
and XML Signature wrapping attacks. Additionally, for
readers unfamiliar with the relevant W3C standards, we
present XML Signature [14] and XML Schema [36].

3.1 XML Signature
The XML Signature standard [14] deﬁnes the syntax and
processing rules for creating, representing, and verifying
XML-based digital signatures.
It is possible to sign a
whole XML tree or only speciﬁc elements. One XML
Signature can cover several local or global resources.
A signature placed within the signed content is called
an enveloped signature.
If the signature surrounds the
signed parts, it is an enveloping signature. A detached
signature is neither inside nor a parent of the signed data.

<Signature ID?>
<SignedInfo>

<CanonicalizationMethod/>
<SignatureMethod/>
(<Reference URI? >
(<Transforms>)?
<DigestMethod>
<DigestValue>

</Reference>)+

</SignedInfo>
<SignatureValue>
(<KeyInfo>)?
(<Object ID?>)*

</Signature>

Figure 2: XML Signature data structure (”?”: zero or one
occurrence; ”+”: one or more occurrences; ”*”: zero or
more occurrences).

An XML Signature is represented by the Signature
element. Figure 2 provides its basic structure. XML
Signatures are two-pass signatures:
the hash value of
the resource (DigestValue) along with the used hash
algorithm (DigestMethod) and the URI reference to
the resource are stored in a Reference element. Ad-
ditionally, the Transforms element speciﬁes the pro-
cessing steps which are applied prior to digesting of
the resource. Each signed resource is represented by
a Reference element
in the SignedInfo element.
Therefore, SignedInfo is a collection of hash val-
ues and URIs. The SignedInfo itself is protected
by the signature. The CanonicalizationMethod and
the SignatureMethod element specify the algorithms
used for canonicalization and signature creation, and are
also embedded in SignedInfo. The Base64-encoded
value of the computed signature is deposited in the
SignatureValue element. In addition, the KeyInfo el-
ement facilitates the transport of signature relevant key
management information. The Object is an optional el-
ement that may contain any data.

<saml:Assertion Version ID IssueInstant>

<saml:Issuer>
<ds:Signature>?
<saml:Subject>?
<saml:Conditions>?
<saml:Advice>?
<saml:AuthnStatement>*
<saml:AuthzDecisionStatement>*
<saml:AttributeStatement>*

</saml:Assertion>

Figure 3: SAML assertion structure.

3.2 XML Schema
The W3C recommendation XML Schema [36] is a lan-
guage to describe the layout, semantics, and content of
an XML document. A document is deemed to be valid,
when it conforms to a speciﬁc schema. A schema con-
sists of a content model, a vocabulary, and the used data
types. The content model describes the document struc-
ture and the relationship of the items. The standard pro-
vides 19 primitive data types to deﬁne the allowed con-
tent of the elements and attributes.

Regarding to our evaluation of SAML based XML
Signature Wrapping attacks there is one important el-
ement deﬁnition in XML Schema. The any element
allows the usage of any well-formed XML document
in a declared content type. When an XML processor
validates an element deﬁned by an any element, the
processContents attribute speciﬁes the level of ﬂex-
ibility. The value lax instructs the schema validator to
check against the given namespace. If no schema infor-
mation is available, the content is considered valid. In the
case of processContents="skip" the XML processor
does not validate the element at all.

3.3 SAML
SAML is an XML standard for exchanging authentica-
tion and authorization statements about Subjects [11].
Several proﬁles are deﬁned in [10]. The most important
proﬁle is the Browser SSO proﬁle, which deﬁnes how to
use SAML with a web browser.

A SAML assertion has the structure described in Fig-
ure 3. The issuing time of the assertion is speciﬁed in
saml:IssueInstant. All attributes are required.

The saml:Issuer element speciﬁes the SAML au-
thority (the IdP) that is making the claim(s) in the asser-
tion. The assertion’s saml:Subject deﬁnes the princi-
pal about whom all statements within the assertion are
made. The saml:*Statement elements are used to
specify user-deﬁned statements relevant for the context
of the SAML assertion.

To protect the integrity of the security claims made
by the Issuer, the whole saml:Assertion element must
be protected with a digital signature following the XML

Figure 4: SAML message examples (SOAP and REST):
The SAML assertion is put into a root element R and
signed using an enveloped signature. When signing the
SOAP body, an additional detached signature is used.

Signature standard. Therefore,
the SAML speciﬁca-
tion [11] requires that either the saml:Assertion ele-
ment or an ancestor element must be referenced by the
Signature element, with an enveloped XML Signature
([11], Section 5.4.1). Furthermore, Id-based referencing
must be used ([11], Section 5.4.2), which opens the way
for XSW attacks.

In REST based frameworks, the SAML assertion is
typically put into an enveloping Response element.
Frameworks applying SOAP insert the SAML assertions
into the SOAP header (or the Security element in-
side of the SOAP header). For clariﬁcation purposes,
consider that the SAML assertions are signed using en-
veloped XML Signatures and are put into some binding
root element R (see Figure 4).

3.4 XML Signature Wrapping Attacks

XML documents containing XML Signatures are typi-
cally processed in two independent steps: signature val-
idation and function invocation (business logic). If both
modules have different views on the data, a new class of
vulnerabilities named XML Signature Wrapping attacks
(XSW) [27, 23] exists.
In these attacks the adversary
modiﬁes the message structure by injecting forged ele-
ments which do not invalidate the XML Signature. The
goal of this alteration is to change the message in such
a way that the application logic and the signature veriﬁ-
cation module use different parts of the message. Con-
sequently, the receiver veriﬁes the XML Signature suc-
cessfully but the application logic processes the bogus
element. The attacker thus circumvents the integrity pro-
tection and the origin authentication of the XML Signa-
ture and can inject arbitrary content. Figure 5 shows a
simple XSW attack on a SOAP message.

XSW attacks resemble other classes of injection at-
tacks like XSS or SQLi: in all cases, the attacker tries to
force different views on the data in security modules (e.g.
Web Application Firewalls) and data processing modules
(HTML parser, SQL engine).

SignedProcessedEnvelopeAssertionHeaderID=“123“SignatureSignedInfoReferenceURI=“#123“ResponseAssertionSignatureSignedInfoReferenceURI=“#123“ID=“123“BodyBinding root element RFigure 5: A simple XML Signature wrapping attack: The
attacker moves the original signed content to a newly cre-
ated Wrapper element. Afterwards, he creates an arbi-
trary content with a different Id, which is invoked by the
business logic.

4 XSW Attacks on SAML

In this section we ﬁrst characterize the assumed threat
model. Second, we describe the basic attack principle
that underlies our analysis of the 14 frameworks.1

4.1 Threat Model
As a prerequisite the attacker requires an arbitrary signed
SAML message. This could be a single assertion A or a
whole document D with an embedded assertion, and its
lifetime can be expired. After obtaining such a message,
the attacker modiﬁes it by injecting evil content, e.g. an
evil assertion EA. In our model we assume two differ-
ent types of adversaries, which are both weaker than the
classical network based attacker:

1. Advacc. To obtain an assertion, this attacker regis-
ters as a user of an Identity Provider IdP. Advacc
then receives, through normal interaction with IdP,
a valid signed SAML assertion A (probably as a
part of a larger document D) making claims about
Advacc. The attacker now adds additional claims EA
about any other subject S, and submits the modiﬁed
document D(cid:48) (A(cid:48)) to RP.

2. Advintc. This adversary retrieves SAML assertions
from the Internet, but he does not have the abil-
ity to read encrypted network trafﬁc. This can
be done either by accessing transmitted data di-
rectly from unprotected networks (snifﬁng), or in
an ”ofﬂine” manner by analyzing proxy or browser
caches. Since SAML assertions should be worthless
once their lifetime expired, they may even be posted

1Please note that from now on we distinguish between the document
D and the root element R. This is to make clear the distinction between
the element referenced by the XML signature, and the document root:
Even if the root element R of the original document D is signed, we
may transform this into a new document D(cid:48) with a new evil root ER,
without invalidating the signature.

Figure 6: Types of signature applications on SAML as-
sertions on the left. The new malicious content needed
to execute the attacks depicted on the right, accordingly.

in technical discussion boards, where Advintcmay
access them.

4.2 Basic Attack Principle
As described in the previous section, XML Signatures
can be applied to SAML assertions in different ways and
placed in different elements. The only prerequisite is that
the Assertion element or the protocol binding element
(ancestor of Assertion) is signed using an enveloped
signature with Id-based referencing. In this section we
analyze the usage of SAML assertions in different frame-
works and the possibilities of inserting malicious con-
tent. Generally, SAML assertions and their signatures
are implemented as depicted in Figure 6:

1. The ﬁrst possible usage of signatures in SAML as-
sertions is to insert the XML Signature S1 as a
child of the SAML assertion A1 and sign only the
Assertion element A1. This type can be used in-
dependently of the underlying protocol (SOAP or
REST).

2. The second type of signature application in SAML
signs the whole protocol binding element R. The
XML Signature can be placed into the SAML asser-
tion A1 or directly into the protocol binding root ele-
ment R. This kind of signature application is used in
different SAML HTTP bindings, where the whole
Response element is signed.

3. It is also possible to use more than one XML Sig-
nature. The third example shows this kind of signa-
ture application: the inner signature S1 protects the
SAML assertion and the outer signature S addition-
ally secures the whole protocol message. This kind
of signature application is e.g. used by the Simple-
SAMLphp framework.

In order to apply XSW attacks to SAML assertions,
the basic attack idea stays the same: The attacker has

SignedProcessedEnvelopeWrapperHeaderID=“123“SignatureSignedInfoReferenceURI=“#123“BodyBodyCreateKeyPairMonitorInstancesID=“attack“A1S1EAA1S1REREAA1SRS1EREALegitimate contentInjected evil contentSignedProcessedSigning Type 1)Signing Type 2)Signing Type 3)to create new malicious elements and force the assertion
logic to process them, whereas the signature veriﬁcation
logic veriﬁes the integrity and authenticity of the original
content. In applications of the ﬁrst signature type, the
attacker only has to create a new evil assertion EA. In the
second and third signing types, he also has to create the
whole evil root ER element including the evil assertion.

4.3 Attack Permutations
The attacker has many different possibilities where to in-
sert the malicious and the original content. To this end,
he has to deal with these questions:

sertion logic?

• At which level in the XML message tree should the
malicious content and the original signed data be
included?
• Which Assertion element is processed by the as-
• Which element is used for signature veriﬁcation?
By answering these questions we can deﬁne different
attack patterns, where the original and the malicious el-
ements can be permuted (Figure 7). We thus get a com-
plete list of attack vectors, which served as a guideline
for our investigations.

For the following explanations we only consider sign-
ing type 1) deﬁned in Figure 6. In this signing type only
the Assertion element is referenced.

The attack permutations are depicted in Figure 7. In
addition, we analyze their SAML standard conformance
and the signature validity:

1. Malicious assertion, original assertion, and signa-
ture are left on the same message level: This kind of
XML message can have six permutations. None of
them is SAML standard compliant, since the XML
Signature does not sign its parent element. The di-
gest value over the signed elements in all the mes-
sages can be correctly validated. We can use this
type of attack messages if the server does not check
the SAML conformance.

2. All the three elements are inserted at different mes-
sage levels, as child elements of each other, which
again results in six permutations: Messages 2-a and
2-b show examples of SAML standard conform-
ing and cryptographically valid messages. In both
cases the signature element references its parent –
the original assertion A1. Message 2-c illustrates a
message which is not SAML standard conform as
the signature signs its child element. Nevertheless,
the message is cryptographically valid. Lastly, mes-
sage 2-d shows an example of an invalid message
since the signature would be veriﬁed over both as-
sertions. Generally, if the signature is inserted as the

Figure 7: Possible variants for XSW attacks applied on
messages with one signed SAML assertion divided ac-
cording to the insertion depth of the evil assertion EA,
the original assertion A1 and the signature S1. The var-
ious permutations are labeled according to their validity
and SAML-conformance.

child of the root element, the message would also be
either invalid or not SAML standard compliant.

3. For the insertion of these three elements we use two
message levels: Message 3-a shows an example of
a valid and SAML compliant document. By con-
structing message 3-b, the signature element was
moved to the new malicious assertion. Since it ref-
erences the original element, it is still valid, but does
not conform to the SAML standard.

The analysis shown above can similarly be applied to

messages with different signing types (see Figure 6).

5 Practical Evaluation

We evaluated the above deﬁned attacks on real-world
systems and frameworks introduced in Section 2. In this
section we present the results.

5.1 Signature Exclusion Attacks
We start the presentation of our results with the simplest
attack type called Signature exclusion attack. This at-
tack relies on poor implementation of a server’s security
logic, which checks the signature validity only if the sig-
nature is included. If the security logic does not ﬁnd the
Signature element, it simply skips the validation step.

A1S1EARA1S1EARA1S1EAR2) Three Levels (6 Permutations)3) Two Levels (12 Permutations)A1S1EARA1S1EARA1S1EARA1S1EAR1) One Level (6 Permutations)SignedProcessedSignature Invalidnot SAML-conforma)b)c)d)a)b)EAS1A1REAS1A1Rc)EAS1A1Rd)SAML-conformFigure 8: XML tree-based illustration of reﬁned XSW attacks found in Type 1 signature applications.

The evaluation showed that three SAML-based frame-
works were vulnerable to these attacks: Apache Axis2
Web Services Framework, JOSSO, and the Java-based
implementation of SAML 2.0 in Eduserv (other versions
of SAML and the C-implementation in Eduserv were not
affected).

By applying this attack on JOSSO and Eduserv the at-
tacker had to remove the Signature element from the
message, since if it was found, the framework tried to
validate it. On the other hand, the Apache Axis2 frame-
work did not validate the Signature element over the
SAML assertion at all, even if it was included in the mes-
sage. Apache Axis2 validated only the signature over the
SOAP body and the Timestamp element. The signature
protecting the SAML assertion, which is included sep-
arately in the Assertion element, was completely ig-
nored.

5.2 Reﬁned Signature Wrapping
Ten out of 14 systems were prone to reﬁned XSW at-
tacks.

Classiﬁed on the three different signature application
types given in Figure 6, ﬁve SAML-based systems failed
in validating Type 1 messages, where only the asser-
tion is protected by an XML Signature. Figure 8 depicts
the XML tree-based illustration of the found XSW vari-
ants. Starting from left to right, Higgins, Apache Axis2,
and the IBM XS 40 Security Gateway were outfoxed
by the two depicted permutations.
In the ﬁrst variant
it was sufﬁcient to inject an evil assertion with a dif-
ferent Id attribute in front of the original assertion. As
the SAML standard allows to have multiple assertions in
one protocol element, the XML Schema validation still
succeeded. The second attack type embedded the orig-
inal assertion as a child element into the evil assertion
EA. In both cases the XML Signature was still standard
conform, as enveloped signatures were applied. This
was broken in the case of OIOSAML by using detached
signatures. In this variant the original Signature ele-
ment was moved into the EA, which was inserted be-
fore the legitimate assertion. The last shown permuta-
tion was applicable to the cloud services of Salesforce

Figure 9: XML tree-based illustration of reﬁned XSW
attacks found in Type 2 signature applications.

and the OpenAM framework. At this, the genuine asser-
tion was placed into the original Signature element. As
both implementations apply XML Schema for validating
the schema conformance of a SAML message, this was
done by injecting them into the Object element, which
allows arbitrary content. Again, this is not compliant
to the SAML standard because this mutation transforms
the enveloped to an enveloping signature. Finally, the
OneLogin Toolkits were prone to all shown attack vari-
ants as they did not apply XML Schema, validated the
XML Signature independent of it’s semantic occurrence
and used a ﬁxed reference to the processed SAML claims
(/samlp:Response/saml:Assertion[1]).

We found three susceptible implementations, which
applied Type 2 messages, where the whole message is
protected by an XML Signature. We depict the attacks
on these implementations in Figure 9.
In the Guanxi
and JOSSO implementations the legitimate root element
was inserted into the Object element in the original
Signature. The Signature node was moved into the
ER element which also included the new evil assertion.
In the case of WSO2, it was sufﬁcient to place the orig-
inal root element into the ER object. Naturally, some-
one would expect that enforcing full document signing
would eliminate XSW completely. The both given ex-
amples demonstrate that this does not hold in practice.
Again, this highlights the vigilance required when im-
plementing complex standards such as SAML.

Finally, we did not ﬁnd vulnerable frameworks that
applied Type 3 messages, where both the root and the as-

RootAssertionID=“evil“AssertionID=“123“SignatureSignedInfoReferenceURI=“#123“RootAssertionID=“evil“AssertionID=“123“SignatureSignedInfoReferenceURI=“#123“RootAssertionID=“evil“AssertionID=“123“SignatureSignedInfoReferenceURI=“#123“SignedProcessedRootAssertionID=“evil“AssertionID=“123“SignatureSignedInfoReferenceURI=“#123“OIOSAMLHiggins, Apache Axis2, IBM XS 40 Security GatewayOpenAM, SalesforceRootAssertionRootID=“123“SignatureSignedInfoReferenceURI=“#123“ID=“evil“AssertionRootAssertionRootID=“123“SignatureSignedInfoReferenceURI=“#123“ID=“evil“AssertionGuanxi, JOSSOWSO2sertion are protected by different signatures. Indeed, one
legitimate reason is, that most SAML implementations
do not use Type 3 messages. In our practical evaluation,
only SimpleSAMLphp applied them by default. Never-
theless, this does not mean that XSW is not applicable to
this message type in practice.

5.3 OpenSAML Vulnerability
The attack vectors described above did not work against
the prevalently deployed OpenSAML library. The reason
was that OpenSAML compared the Id used by the signa-
ture validation with the Id of the processed assertion. If
these identiﬁers were different (based on a string compar-
ison), the signature validation failed. Additionally, XML
messages including more than one element with the same
Id were also rejected. Both mechanisms are handled in
OpenSAML by using the Apache Xerces library and its
XML Schema validation method [34]. Nevertheless, it
was possible to overcome these countermeasures with a
more sophisticated XSW attack.

As mentioned before,

in OpenSAML the Apache
Xerces library performs a schema validation of every in-
coming XML message. Therefore, the Id of each el-
ement can be deﬁned by using the appropriate XML
Schema ﬁle. This allows the Xerces library to iden-
tify all included Ids and to reject messages with Id
values which are not unique (e.g. duplicated). How-
ever, a bug in this library caused that XML elements
deﬁned with xsd:any content were not processed cor-
rectly. More concretely, the content of the elements
deﬁned as <xsd:any processContents="lax"> were
not checked using the deﬁned XML Schema. Therefore,
it was possible to insert elements with arbitrary – also
duplicated – Ids inside an XML message. This created a
good position for our wrapped content.

It is still the question which of the extensible elements
could be used for the execution of our attacks. This de-
pends on two processing properties:

1. Which element is used for assertion processing?
2. Which element is validated by the security module,

if there are two elements with the same Id?

Interestingly,
the two existing implementations of
Apache Xerces (Java and C++) handled element deref-
erencing differently.

For C++, the attacker had to ensure that the original
signed assertion was copied before the evil assertion. In
the Java case, the legitimate assertion had to be placed
within or after the evil assertion.
In summary, if two
elements with the same Id values occurred in an XML
message, the XML security library detected only the ﬁrst
(for C++) or the last (for Java) element in the message.
This property gave the attacker an opportunity to use

Figure 10: XSW attack on OpenSAML library.

<element name="Extensions" type="samlp:ExtensionsType"/>
<complexType name="ExtensionsType">

<sequence>

<any namespace="##other" processContents="lax"

maxOccurs="unbounded"/>
</sequence>

</complexType>

Figure 11: XML Schema deﬁnition of the Extensions
element.

e.g. the Extensions element for the C++ library, whose
XML Schema is deﬁned in Figure 11. However, the
Extensions element is not the only possible position for
our wrapped content. The schemas of SAML and XML
Signature allow more locations (e.g. the Object element
of the Signature, or the SubjectConfirmationData
and Advice elements of the Assertion).

The previously described behavior of

the XML
schema validation forced OpenSAML to use the wrapped
original assertion for signature validation.
In contrast,
the application logic processed the claims of the evil as-
sertion. In Figure 10, we present the concrete attack mes-
sages of this novel XSW variant.

The successful attack on OpenSAML shows that coun-
tering the XSW attack can become more complicated
than expected. Even when applying several countermea-
sures, the developer should still consider vulnerabilities
in the underlying libraries. Namely, one vulnerability in
the XML Schema validating library can lead to the exe-
cution of a successful XSW attack.

5.4 Various Implementation Flaws
While reviewing the OneLogin Toolkit, we discovered
another interesting ﬂaw: the implementation did not care
about what data was actually signed. Therefore, any con-
tent signed by the IdP was sufﬁcient to launch a XSW
attack. In our case we used the metadata of the IdP 2 and
created our own self-made response message to success-
fully attack OneLogin.

2The SAML Metadata [12] describes properties of SAML entities
in XML to allow the easy establishment of federations. Typically, the
metadata is signed by the issuer and publicly available.

SignedProcessedResponseAssertionExtensionsAssertionC++JavaSignatureSignedInfoReferenceURI=“#123“ID=“123“ResponseAssertionAssertionSignatureSignedInfoReferenceURI=“#123“ID=“123“ID=“123“ID=“123“ObjectBesides the fact that a SAML system has to check
what data is signed, it is also essential to verify by whom
the signature was created. In an early version of Sim-
pleSAMLphp, which applied Type 3 messages, we ob-
served that an attacker could forge the outer signature of
the response message with any arbitrary key. In short,
the SimpleSAMLphp RP did not verify if the included
certiﬁcate in the KeyInfo element is trustworthy at all.
The key evaluation for the signed assertion was correctly
handled.

5.5 Secure Frameworks
In our evaluation of real-world SAML implementations
we observed that Microsoft Sharepoint 2010 and Simple-
SAMLphp were resistant to all applied test cases. Based
on these ﬁndings the following questions arise: How
do these systems implement signature validation?
In
which way do signature validation and assertion process-
ing work together? Due to the fact that the source code of
Sharepoint 2010 is not publicly available, we were only
able to analyze SimpleSAMLphp.

According to this investigation the main signature
validation and claims processing algorithm of Simple-
SAMLphp performs the following ﬁve steps to counter-
act XSW attacks:

1. XML Schema validation: First,

the whole re-
sponse message is validated against the applied
SAML schemas.

2. Extract assertions: All included assertions are ex-
tracted. Each assertion is saved as a DOM tree in
a separate variable. The following steps are only
applied on these segregated assertions.

3. Verify what is signed: SimpleSAMLphp checks, if
each assertion is protected by an enveloped signa-
ture. In short, the XML node addressed by the URI
attribute of the Reference element is compared to
the root element of the same assertion. The XML
Signature in the assertion is an enveloped signature
if and only if both objects are identical.

4. Validate signature: The veriﬁcation of every en-
veloped signature is exclusively done on the DOM
tree of each corresponding assertion.

5. Assertion processing: The subsequent assertion
processing is solely done with the extracted and suc-
cessfully validated assertions.

When not considering the signature exclusion bug
found in the OpenAthens implementation and its Java-
based assertions’ processing, this framework was also
resistant to all the described attacks. The analysis of its
implementation showed that it processes SAML asser-
tions similarly to the above described SimpleSAMLphp
framework.

e
p
y
t
g
n

i

n
g
i

Frameworks / Providers S
1)
Apache Axis 2
Guanxi
2)
1)
Higgins 1.x
1)
IBM XS40
2)
JOSSO
1)
WIF
1)
OIOSAML
1)
OpenAM
OneLogin
1)
1)
OpenAthens
1)
OpenSAML
1)
Salesforce
3)
SimpleSAMLphp
WSO2
2)

e
r
u
t
a
n
g
i

S

n
o
i
s
u

l
c
x
e

X

X

X

d
e
t
a
c
i
t
s
i

h
p
o
S

W
S
X

X

e
l

b
a
r
e
n

l

u
v

t
o
N

X

X

W
S
X
d
e
n
ﬁ
e
R
X
X
X
X
X

X
X
X

X

X

Table 2: Results of our practical evaluation show that a
majority of the analyzed frameworks were vulnerable to
the reﬁned wrapping techniques.

5.6 Summary
We evaluated 14 different SAML-based systems. We
found 11 of them susceptible to XSW attacks, while the
majority were prone to reﬁned XSW. One prevalently
used framework (OpenSAML) was receptive to a new,
more subtle, variant of this attack vector.
In addition,
three out of the tested frameworks were vulnerable to
Signature Exclusion attacks. We found two implemen-
tations, which were resistant against all test cases. The
results obtained from our analysis are summarized in Ta-
ble 2.

6 XSW Penetration Test Tool for SAML

Motivated on our crucial ﬁndings from the extensive
frameworks’ analysis and the vast amount of possible
attack permutations, we implemented the ﬁrst fully au-
tomated penetration test tool for XSW attacks in SAML-
based frameworks.
In this section we brieﬂy describe
the basic design decisions for our tool. Afterwards, we
motivate its usage by revisiting the Salesforce SAML in-
terface. This interface yielded a new possibility for an
interesting XSW attack even after a deep investigation
with different handcrafted messages.

Our tool will be integrated into the WS-Attacker
framework3 and offered as open source to support the
huge Web Services and SSO developers’ community.

6.1 Penetration Test Tool
According to the theoretical and practical analysis of dif-
ferent SAML frameworks (see Section 4, 5), we gained
the following general knowledge about XSW attacks:

3http://ws-attacker.sourceforge.net

• XML Schema validation: Some of the SAML
frameworks check message conformance to the un-
derlying XML schema. Therefore, it is necessary to
use XML schema extension points for placing the
wrapped content. If the extension elements are not
provided in the message, they have to be explicitly
included.
• Order and position: The order and position of
signed and executed elements in the message tree
can force the different processing modules to have
inconsistent data views.
• Processing of the Ids: Several SAML frameworks
explicitly check, if the Id in the handled assertion
is also used in the Reference of the XML Signa-
ture. Application of this countermeasure alone does
not work, as there is still the option to use more el-
ements with equal Ids.

• Placement of

the Signature element: The
Signature element can be placed in the newly cre-
ated evil assertion or stay in the original assertion
(cf. the attacks on Higgins, Apache Axis2 and IBM
XS40 in Figure 8). Both cases must be considered.
• Signature exclusion: In three out of 14 frameworks
implementation bugs caused that the signature vali-
dation step was omitted.
• Untrusted signatures: It is essential to check that
the signature was created with a trustworthy key.
Otherwise, the attacker can forge a signature with
any arbitrary key and embed the corresponding cer-
tiﬁcate in the KeyInfo element.

Based on this knowledge, we developed a library,
which allows the systematic creation of a vast amount
of different SAML attack vectors.
Its processing can
be summarized in the following steps. First, the library
takes a signed XML document containing a SAML as-
sertion and analyzes the usage of XML Signature. The
element referenced by the signature is stored as a string.
Subsequently, it creates a new malicious message includ-
ing an evil assertion with modiﬁed content (e.g.
the
NameID and/or Timestamp element). Then, it searches
dynamically for extension points in the XML Schema
documents (e.g. XML Schemas for SAML, HTTP bind-
ing, XML Signature, or SOAP). It places the extension
elements into the malicious message (e.g. a new Object
element is created and placed into the given Signature
element). Afterwards, the library embeds the stored orig-
inal referenced element into each of the possible mali-
cious message elements. For each position, a combina-
tion of different attack vectors – considering changes in
the Ids of the newly created elements and the positions
of the Signature elements – are created. For complete-
ness, test cases for signature exclusion and untrusted sig-
natures are provided. With these attack vectors, develop-

Figure 12: A successful XSW attack performed against
the patched Salesforce SAML interface.

ers can systematically test the security of their (newly)
developed SAML libraries.

6.2 Salesforce SAML Interface Revisited

After reporting the XSW vulnerability to Salesforce, the
security response team developed a simple and promis-
ing countermeasure: the SAML interface solely accepted
messages containing one Assertion element4. On re-
quest of the Salesforce security team, we investigated
the ﬁxed SAML interface with handcrafted messages
containing wrapped contents in different elements. Our
manual analysis did not reveal any new attack vectors.
Every message containing more than one Assertion el-
ement was automatically rejected. Therefore, we ﬁrst
considered this interface to be secure.

A few months later, after ﬁnishing the development of
our penetration test tool, we decided to retest the Sales-
force SAML interface and prove the feasibility of our ap-
proach. Surprisingly, the automated penetration test tool
revealed a new successful attack variant by inserting the
wrapped content into the Audience element – a descen-
dant of the Conditions element. This element typically
contains a URI constraining the parties that can consume
the issued assertion. The wrapped message is depicted in
Figure 12. As can be seen in the ﬁgure, both Assertion
elements needed to contain the same Id attribute.

This scientiﬁcally interesting attack vector stayed un-
analyzed as the Salesforce security team did not expose
any concrete information about their SAML interface.
However, this ﬁnding shows how complex the develop-
ment of secure signature wrapping countermeasures is.
This motivates for further development of automatic pen-
etration test tools for XSW.

Salesforce security team afterwards implemented a
countermeasure, which could successfully mitigate all
our attack types. Its details were not revealed.

4This countermeasure is not standard-conform as one message can
generally contain several assertions. Therefore, we do not consider this
remedy in our countermeasure analysis in Section 7.

SignedProcessedResponseAssertionAssertionSignatureSignedInfoReferenceURI=“#123“ID=“123“ID=“123“Audiencesaml.salesforce.com7.3 Relying Party Model
We assume that processing of documents containing
SAML assertions is split into two parts: (1) XML Sig-
nature veriﬁcation RPsig, and (2) SAML security claims
processing RPclaims (see Figure 13). This assumption is
justiﬁed since both parts differ in their algorithmic base,
and because this separation was found in all frameworks.
If RPclaims accepts, then the application logic RPwork of
the Relying Party will deliver the requested resource to
the requestor.

The XML Signature veriﬁcation module RPsig is con-
ﬁgured to trust several Identity Provider public keys
{pk1, . . . , pkr}. Each public key deﬁnes a trusted do-
main within RP. After receiving a signed XML document
D, RPsig searches for a Signature element. It applies
the referencing method described in Reference to re-
trieve the signed parts of the document, applies the trans-
forms described in Transforms to these parts, and com-
pares the computed hash values with the values stored in
DigestValue. If all these values match, signature ver-
iﬁcation is performed over the whole SignedInfo ele-
ment, with one of the trusted keys from {pk1, . . . , pkr}.
RPsig then communicates the result of the signature veri-
ﬁcation (eventually alongside D) to RPclaims.

The SAML security claims processing module
RPclaims may operate a customer database dbRP, and may
validate SAML assertions against this database. In this
case if the claimed identity is contained in dbRP, the asso-
ciated rights are granted to the requestor. As an alterna-
tive, RPclaims may rely on authorization data contained in
dbIdP. In this case, the associated rights will be contained
in the SAML assertion, and RPclaims will grant these.

Please note that the deﬁnition of the winning event
given below does not depend on the output of the sig-
nature veriﬁcation part RPsig, but on the SAML asser-
tion processing RPclaims. This is necessary since in all
cases described in this paper, signature veriﬁcation was
done correctly (as is always the case with XML Signa-
ture wrapping). Therefore, to be able to formulate mean-
ingful statements about the security of a SAML frame-
work, we must make some assumptions on the behavior
of RPclaims.

There are many possible strategies for RPclaims to pro-
cess SAML assertions: E.g. use the claims from the ﬁrst
assertion which is opened during parsing, from the ﬁrst
that is closed during parsing (analogously for the last as-
sertion opened or closed), or issue an error message if
more than one Assertion element is read.

7.4 Adversarial Model
Please recall
types of adversaries
we have mentioned in our threat model in Section 4.
Advintc is the stronger of the two: He has the ability to

the two different

Figure 13: Overview of the components in our formal
model.

7 Analysis and Countermeasures

In order to deﬁne what a successful attack on a SAML
implementation is, we have to deﬁne the possibilities of
the adversary, and the event that characterizes a success-
ful attack. We do this in form of a game played between
the adversary on one side, and IdP and RP on the other
side. Additionally, we derive two different countermea-
sures. Their practical application is described in Sec-
tion 8.

7.1 Data Model

A SAML assertion A can be sent to a Relying Party RP
either as a stand-alone XML document, or as part of a
larger document D. (D may be a complete SOAP mes-
sage, or a SAML Authentication response.) To process
the SAML assertion(s), the Relying Party (more speciﬁ-
cally, RPclaims) searches for the Assertion element and
parses it. We assume that A is signed, either stand-alone,
or as part of D.

7.2

Identity Provider Model

We deﬁne an Identity Provider IdP to be an entity that is-
sues signed SAML assertions, and that has control over
a single private key for signing. Thus, companies like
Salesforce may operate several IdPs, one for each do-
main of customers.

An Identity Provider IdP operates a customer database
dbIdP and is able to perform a secure authentication
protocol with any customer contained in this database.
Furthermore, he has control over a private signing key,
where the corresponding public key is trusted by a set of
Relying Parties RP := {RP1, . . . ,RPn}, either directly,
or through means of a Public Key Infrastructure. After
receiving a request from one of the customers registered
in dbIdP, and after successful authentication, he may is-
sue a signed XML document D, where the signed part
contains the requested SAML assertion A.

IdP1IdP2IdP3AdvaccAdvintcRPsigRPclaimsRPworkpartially intercept network trafﬁc, e.g. by snifﬁng HTTP
trafﬁc on an unprotected WLAN, by reading past mes-
sages from an unprotected log ﬁle, or by a chosen ci-
phertext attack on TLS 1.0 along the lines of [5]. Please
note that already this adversary is strictly weaker than the
classical network based attacker known from cryptogra-
phy. Advacc, our weaker adversary, only has access to
the IdP and RP, i.e. he may register as a customer with
IdP and receive SAML assertions issued about himself,
and he may send requests to RP.

We deﬁne preconditions and success conditions of an
attacker in the form of a game G. If Adv mounts a suc-
cessful attack under these conditions, we say that Adv
wins the game. This facilitates some deﬁnitions.

During the game G, the adversary has access to a
validly signed document D containing a SAML assertion
A issued by IdP. He then generates his own (evil) asser-
tion EA, and combines it arbitrarily with D into an XML
document D(cid:48). This document is then sent to RP.

Deﬁnition 1. We say that the adversary (either Advintc or
Advacc) wins game G if RP, after receiving document D(cid:48),
with non-negligible probability Pr(WinAdv) bases its au-
thentication and authorization decisions on the security
claims contained in EA.

Remark: For all researched frameworks, the winning
probability was either negligible or equal to 1. Within the
term ”negligible” we include the possibility that Adv is-
sues a forged cryptographic signature, which we assume
to be impossible in practice.
If an adversary wins the
game against a speciﬁc Relying Party RP, he takes over
the trust domain for a speciﬁc public key pk within RP.
Advacc may do this for all pk where he is allowed to reg-
ister as a customer with the corresponding IdP who con-
trols (sk, pk). Advintc can achieve this for all pk where he
is able to ﬁnd single signed SAML assertion A where the
signature can (could in the past) be veriﬁed with pk.

7.5 Countermeasure 1:

what-is-hashed

Only-process-

We can derive the ﬁrst countermeasure if we assume that
RPsig acts as a ﬁlter and only forwards the hashed parts
of an XML document to RPclaims. The hashed parts of
an XML document are those parts that are serialized as
an input to a hash function, and where the hash value is
stored in a Reference element. This excludes all parts
of the document that are removed before hash calculation
by applying a transformation, especially the enveloped
signature transform.

Claim 1. If RPsig only forwards the hashed parts of D to
RPclaims, then Pr(WinAdv) is negligible.

It is straightforward to see that EA is only forwarded

to RPclaims if a valid signature for EA is available.

Please note that although this approach is simple and
effective, it is rarely used in practice due to a number of
subtle implementation problems. A variant of this ap-
proach is implemented by SimpleSAMLphp, where the
RP imposes special requirements on the SAML authen-
tication response, thus limiting interoperability. We dis-
cuss these problems in Section 8.

7.6 Countermeasure 2: Mark signed ele-

ments

In practice, RPsig only returns a Boolean value, and
the whole document D is forwarded to RPclaims. Since
IdPhas to serve many different Relying Parties, we as-
sume knowledge about the strategy of RPclaims only for
RPsig. One possibility to mark signed elements is to hand
over the complete document D from RPsig to RPclaims,
plus a description where the validly signed assertions can
be found.

A second possibility that

is more appropriate for
SAML is that RPsig chooses a random value r, marks
the validly signed elements with an attribute containing
r, and forwards r together with the marked document.
RPclaims can then check if the assertion processed con-
tains r.

Let us therefore consider the second approach in more
detail. For sake of simplicity we assume that only one
complete element (i.e. a complete subtree of the XML
document tree) is signed.

Claim 2. Let Dsig be the signed subtree of D, and
let r ∈ {0,1}l be the random value chosen by RPsig
and attached to Dsig. Then Pr(WinAdv) is bounded by
max{breaksig,2−l}.

RPclaims (regardless of its strategy to choose an asser-
tion) will only process EA if r is attached to this element.
An adversary can achieve this by either generating a valid
signature for EA (then r will be attached by RPsig), or by
guessing r and attaching it to EA.

8 Practical Countermeasures

In Section 5.5 we analyzed message processing of Sim-
pleSAMLphp. This framework was resistant against all
XSW attacks. One could therefore ask a legitimate ques-
tion: Why do we need further countermeasures and why
is it not appropriate to apply the security algorithm of
SimpleSAMLphp in every system?

We want to make clear that SimpleSAMLphp offers
both critical functionalities in one framework: signa-
ture validation (RPsig) and SAML assertion evaluation

Figure 14: The see-what-is-signed approach applied in
HTTP POST binding: After successful signature valida-
tion the security module RPsig excludes all the unsigned
elements and forwards the message to the module pro-
cessing security claims RPclaims and the business logic.

(RPclaims). These two methods are implemented using
the same libraries and processing modules. After pars-
ing a document, the elements are stored within a docu-
ment tree and can be accessed directly. This allows the
security developers to conveniently access the same el-
ements used in signature validation and assertion evalu-
ation steps. However, especially in SOA environments
there exist scenarios, which force the developers to sep-
arate these two steps into different modules or even dif-
ferent systems, e.g.:

• Using a signature validation library: Before eval-
uating the incoming assertion elements, the devel-
oper uses a DOM-based signature library, which
returns true or false according to the message
validity. However, the developer does not exactly
know which elements were validated.
If the as-
sertion evaluation uses a different parsing approach
(e.g.
streaming-based SAX or StAX approach)
or another DOM-library, the message processing
could become error-prone.
• XML Security gateways: XML Security gateways
can validate XML Signatures and are conﬁgured to
forward only validated XML documents. If the de-
veloper evaluates a validated document in his appli-
cation, he again has no explicit information about
the position of the signed element. Synchronization
of signature and assertion processing components in
this scenario becomes even more complicated, if the
developer has no information about the implemen-
tation of the security gateway (e.g. IBM XS40).

These two examples show that a convenient access to
the same XML elements is not always given. Subse-
quently, we present two practical feasible countermea-
sures, which can be applied in complex and distributed
real-world implementations. Both countermeasures re-
sult from our formal analysis in Section 7.

8.1 See-what-is-signed
The core idea of this countermeasure is to forward only
those elements to the business logic module (RPclaims)

that were validated by the signature veriﬁcation module
(RPsig). This is not trivial as extracting the unsigned el-
ements from the message context could make the fur-
ther message processing in some scenarios impossible.
Therefore, we propose a solution that excludes only the
unsigned elements which do not contain any signed de-
scendants. We give an example of such a message pro-
cessing in Figure 14. This way, the claims and message
processing logic would get the whole message context:
in case of SOAP it would see the whole Envelope ele-
ment, by application of HTTP POST binding it would be
able to process the entire Response element. The main
advantage of this approach is that the message process-
ing logic does not have to search for validated elements
because all forwarded elements are validated.

We want to stress the fact that by application of this ap-
proach all unsigned character nodes have to be extracted.
Otherwise, the attacker could create an evil assertion EA
and insert the signed original assertion into each element
of EA. If RPsig would not extract the character contents
from EA, RPclaims could process its claims. However, by
extracting the unsigned character nodes, the attacker has
no possibility to insert his evil content, since it was ex-
cluded in RPsig. Nevertheless, the subsequent XML mod-
ules can still access the whole XML tree.

This idea has already been discussed by Gajek et
al. [17]. However, until now no XML Signature
framework implements this countermeasure.
It could
be applied especially in the context of SAML HTTP
POST bindings because the unsigned elements within
the SAML response do not contain any data needed
in RPclaims. We consider this countermeasure in these
scenarios as appropriate because the SAML standard
only allows the usage of Id-based referencing, exclusive
canonicalization, and enveloped transformation. The au-
thors explicitly state that this countermeasure would not
work if XML Signature uses speciﬁc XSLT or XPath
transformations.

8.2 Unique Identiﬁcation (Tainting) of

Signed Data

The second countermeasure represents another form of
the see-what-is-signed approach. The basic idea is to
uniquely identify the signed data in the RPsig module
and forward this information to the following modules.
As described in our formal analysis, this could be done
by generating a random value r, sending it to the next
processing module (or as an attribute in the document
root element), and attaching it to all the signed elements.
We give an example of this countermeasure applied to a
SOAP message in Figure 15.

The main drawback of this countermeasure is that the
SAML XML Schema does not allow the inclusion of

ResponseAssertionID=“123“SignatureURI=“#123“RPsigRPclaimsStatusResponseAssertionID=“123“contains partial information about the structure of the
SOAP message and the neighborhood of the signed el-
ement(s). The information preserves the structure of the
data to be signed. However, Gajek et al. have shown
that this approach does not prevent XSW attacks [16].
Benameur, Kadir, and Fenet [6] have extended the inline
approach, but suffer from the same vulnerabilities.

Jensen et al. [24] have analyzed the effectiveness of
XML Schema validation in terms of fending XSW at-
tacks in Web Services. Thereby, they have used man-
ually hardened XML Schemas. The authors have con-
cluded that XML Schema validation is capable of fend-
ing XSW attacks, at the expense of two important disad-
vantages: for each application a speciﬁc hardened XML
Schema without extension points must be created care-
fully. Moreover, validating of a hardened XML Schema
entails severe performance penalties.

XPath and XPath Filter 2 are speciﬁed as referenc-
ing mechanisms in the XML Signature standard. How-
ever, the WS-Security standard proposes not to use these
mechanisms, and the SAML standard mandates to use
Id-based referencing instead. This is due to the fact that
both standards are very complex. Gajek et al. [15] have
evaluated the effectiveness of these mechanisms to mit-
igate XSW attacks in the SOAP context, and have pro-
posed a lightweight variant FastXPath, which has lead
to the same performance in a PoC implementation as by
adapting the Id-based referencing.

Jensen et al. [23] have however shown that this ap-
proach does not completely eliminate XSW attacks: by
clever manipulations of XML namespace declarations
within a signed document, which take into account the
processing rules for canonicalization algorithms in XML
Signature, XSW attacks could successfully be mounted
even against XPath referenced resources.

The impacts of practical XSW attacks have also been
analyzed in [20, 33].
In these works new types of
XSW attack have been applied on SOAP Web Service
interfaces of Amazon and Eucalyptus clouds. The at-
tacks have exploited different XML processing in dis-
tinct modules.

In summary, previous work has mostly concentrated
on SOAP, and the results do not directly apply to all
SAML use cases.

SAML and Single Sign-On Since SAML offers very
ﬂexible mechanisms to make claims about identities,
there is a large body of research on how SAML can be
used to improve identity management (e.g. [22, 39]) and
other identity-related processes like payment or SIP on
the Internet [25, 35]. In all these applications, the secu-
rity of all SAML standards is assumed.

In an overview paper on SAML, Maler and Reed [26]
have proposed mutually authenticated TLS as the basic

Figure 15: Unique identiﬁcation of signed data applied
on a SOAP message including two signed elements: The
RPsig module uniquely identiﬁes the signed elements
with a random value r and forwards this information
along with the whole XML message.

new attributes: neither directly into the Assertion el-
ement nor the Response binding element. Therefore,
the XML Schema validation of the assertion processing
module would fail. For general application of this idea
the SAML XML Schema needs to be extended.

Another possibility to implement this countermeasure
is to use XML node types, which do not violate XML
Schema, but are visible to the XML processors. For
example, processing instructions, which are intended to
carry instructions to the application belong to this group.
They can be placed anywhere in the document without
invalidating the XML Schema. Additionally, they can
be conveniently found by processing XML trees with
streaming and DOM-based parsers. Therefore, the pres-
ence of these XML nodes would help to ﬁnd the vali-
dated data and thus allows to mitigate XSW attacks. We
propose this technique for further discussion in the W3C
XML Security Working Group and the OASIS consor-
tium.

9 Related Work

XML Signature Wrapping (XSW). XSW attacks
have ﬁrst been described in [28] and [7]. Several coun-
termeasures have been proposed over time.

McIntosh and Austel [28] have presented several XSW
attacks and discussed (informal) receiver-sided security
policies in order to prevent such exploits. They have
however not given a deﬁnitive solution for this problem.
Bhargavan, Fournet and Gordon [7] have analyzed a
formal approach in order to verify Web Services speciﬁ-
cations. They have proposed a policy advisor [8], a tool
that generates appropriate security policies for Web Ser-
vices protocols. This approach is however not directly
applicable to SAML.

Rahaman, Schaad and Rits [32, 30, 31] have refrained
from policy-driven approaches and have introduced an
inline solution. The authors have proposed to embed an
Account element into the SOAP header. This element

EnvelopeAssertionHeaderID=“123“SignatureSignatureURI=“#123“BodyURI=“#body“ID=“body“UnsignedContentRPsigRPclaimsrg=“xy“rg=“xy“r=“xy“EnvelopeAssertionHeaderID=“123“SignatureSignatureURI=“#123“BodyURI=“#body“ID=“body“UnsignedContentr=“xy“security mechanism. Please note that even if mutually
authenticated TLS would be employed, it would not pre-
vent our attacks because we only need a single signed
SAML assertion from an IdP, which we can get through
different means. Moreover, there exist speciﬁc sidechan-
nels, which could be exploited by an adversary. Let us
e.g. mention chosen-plaintext attacks against SSL/TLS
predicted by [37] and reﬁned by [5], or the Million Ques-
tion attack by Bleichenbacher [9]. Other complications
arise with the everlasting problems with SSL PKIs.

In 2003, T. Groß has initiated the security analysis of
SAML [18] from a Dolev-Yao point of view, which has
been formalized in [4]. He has found, together with B.
Pﬁtzmann [19], deﬁciencies in the information ﬂow be-
tween the SAML entities. Their work has inﬂuenced a
revision of the standard.

In 2008, Armando et al. [3] have built a formal model
of the SAML 2.0 Web Browser SSO protocol and have
analyzed it with the model checker SATMC. By intro-
ducing a malicious RP they have found a practical at-
tack on the SAML implementation of Google Apps. An-
other attack on the SAML-based SSO of Google Apps
has been found in 2011 [2]. Again, a malicious RP has
been used to force a user’s web browser to access a re-
source without approval. Thereby, the malicious RP has
injected malicious content in the initial unintended re-
quest to the attacked RP. After successful authentication
on the IdP this content has been executed in the context
of the user’s authenticated session.

The fact that SAML protocols consist of multiple lay-
ers has been pointed out in [13]. In this paper, the Weak-
est Link Attack has enabled adversaries to succeed at all
levels of authentication by breaking only at the weakest
one.

Very recently, another work pointing out the impor-
tance of SSO protocols has been published by Wang et
al. [38]. This work has analyzed the security quality
of commercially deployed SSO solutions. It has shown
eight serious logic ﬂaws in high-proﬁle IdPs and RPs
(such as OpenID, Facebook, or JanRain), which have
allowed an attacker to sign in as the victim user. The
SAML-based SSO has not been analyzed.

10 Conclusion

In this paper we systematically analyzed the application
of XSW attacks on SAML frameworks and systems. We
showed that the large majority of systems exhibit criti-
cal security insufﬁciencies in their interfaces. Addition-
ally, we revealed new classes of XSW attacks, which
worked even if speciﬁc countermeasures were applied.
We showed that the application of XML Security heav-
ily depends on the underlying XML processing system
(i.e. different XML libraries and parsing types). The pro-

cessing modules involved can have inconsistent views on
the same secured XML document, which may result in
successful XSW attacks. Generally, these heterogeneous
views can exist in all data formats beyond XML.

We proposed a formal model by analyzing the in-
formation ﬂow inside the Relying Party and presented
two countermeasures. The effectiveness of these coun-
termeasures depends on the real information ﬂow and
the data processing inside RPclaims. Our research is
a ﬁrst step towards understanding the implications of
the information ﬂow between cryptographic and non-
cryptographic components in complex software environ-
ments. Research in this direction could enhance the re-
sults, and provide easy-to-apply solutions for practical
frameworks.

As another future research direction, we propose de-
velopment of an enhanced penetration testing tool for
XSW in arbitrary XML documents and all types of XML
Signatures. This kind of tool presents a huge challenge
as it should e.g. consider more difﬁcult transformations
like XPath or XSLT.

Acknowledgements
The authors would like to thank all the security teams and
their developers for their cooperation, and would like to
note that throughout the collaboration all the teams ef-
fectuated a productive and highly professional commu-
nication.

Moreover, we would like to thank Scott Cantor, David
Jorm, Florian Kohlar, Christian Mainka, Christopher
Meyer, Thomas Roessler, and the anonymous review-
ers (of the USENIX Security Symposium and the IEEE
Symposium on Security and Privacy) for their valuable
remarks on the developed attacks and the paper content.
Finally, we thank Alexander Bieber for the Sharepoint
2010 test bed.

This work was partially funded by the Sec2 project of
the German Federal Ministry of Education and Research
(BMBF, FKZ: 01BY1030).
References
[1] IEEE International Conference on Web Services, ICWS 2009, Los

Angeles, CA, USA, 6-10 July 2009 (2009), IEEE.

[2] ARMANDO, A., CARBONE, R., COMPAGNA, L., CU ´ELLAR, J.,
PELLEGRINO, G., AND SORNIOTTI, A. From Multiple Creden-
tials to Browser-Based Single Sign-On: Are We More Secure?
In Future Challenges in Security and Privacy for Academia and
Industry, J. Camenisch, S. Fischer-Hbner, Y. Murayama, A. Port-
mann, and C. Rieder, Eds., vol. 354 of IFIP Advances in Infor-
mation and Communication Technology. Springer Boston, 2011.
[3] ARMANDO, A., CARBONE, R., COMPAGNA, L., CU ´ELLAR,
Formal Analysis of SAML 2.0
J., AND TOBARRA, M. L.
Web Browser Single Sign-On: Breaking the SAML-based Single
Sign-On for Google Apps. In Proceedings of the 6th ACM Work-
shop on Formal Methods in Security Engineering, FMSE 2008,
V. Shmatikov, Ed. ACM, Alexandria and VA and USA, 2008.

[4] BACKES, M., AND GROSS, T. Tailoring the dolev-yao abstrac-
In SWS (2005), E. Damiani and

tion to web services realities.
H. Maruyama, Eds., ACM, pp. 65–74.

[5] BARD, G. V.

A Challenging but Feasible Blockwise-
Adaptive Chosen-Plaintext Attack on SSL. In SECRYPT (2006),
M. Malek, E. Fern´andez-Medina, and J. Hernando, Eds., IN-
STICC Press, pp. 99–109.

[6] BENAMEUR, A., KADIR, F. A., AND FENET, S. XML Rewrit-
ing Attacks: Existing Solutions and their Limitations. In IADIS
Applied Computing 2008 (Apr. 2008), IADIS Press.

[7] BHARGAVAN, K., FOURNET, C., AND GORDON, A. D. Verify-
ing policy-based security for web services. In CCS ’04: Proceed-
ings of the 11th ACM conference on Computer and communica-
tions security (2004), pp. 268–277.

[8] BHARGAVAN, K., FOURNET, C., GORDON, A. D., AND
O’SHEA, G. An advisor for web services security policies. In
SWS ’05: Proceedings of the 2005 workshop on Secure web ser-
vices (New York, NY, USA, 2005), ACM, pp. 1–9.

[9] BLEICHENBACHER, D. Chosen ciphertext attacks against proto-
cols based on the rsa encryption standard pkcs #1. In CRYPTO
(1998), pp. 1–12.

[10] CANTOR, S., KEMP,

Proﬁles for

J., MALER, E., AND PHILPOTT,
the OASIS Security Assertion Markup
R.
Language (SAML) V2.0.
OASIS Standard, 15.03.2005,
2005. http://docs.oasis-open.org/security/saml/v2.
0/saml-profiles-2.0-os.pdf.

[11] CANTOR, S., KEMP, J., PHILPOTT, R., AND MALER, E.
Assertions and Protocol for the OASIS Security Assertion
Markup Language (SAML) V2.0. OASIS Standard, 15.03.2005,
2005. http://docs.oasis-open.org/security/saml/v2.
0/saml-core-2.0-os.pdf.

[12] CANTOR, S., MOREH, J., PHILPOTT, R., AND MALER,
E. Metadata for the OASIS Security Assertion Markup
Language (SAML) V2.0.
OASIS Standard, 15.03.2005,
2005. http://docs.oasis-open.org/security/saml/v2.
0/saml-metadata-2.0-os.pdf.

[13] CHAN, Y.-Y. Weakest link attack on single sign-on and its case
in saml v2.0 web sso. In Computational Science and Its Applica-
tions - ICCSA 2006, M. Gavrilova, O. Gervasi, V. Kumar, C. Tan,
D. Taniar, A. Lagan, Y. Mun, and H. Choo, Eds., vol. 3982 of
Lecture Notes in Computer Science. Springer Berlin / Heidelberg,
2006, pp. 507–516. 10.1007/11751595 54.

[14] EASTLAKE, D., REAGLE, J., SOLO, D., HIRSCH, F., AND
ROESSLER, T. XML Signature Syntax and Processing (Second
Edition), 2008. http://www.w3.org/TR/xmldsig-core/.

[15] GAJEK, S., JENSEN, M., LIAO, L., AND SCHWENK, J. Analy-
sis of signature wrapping attacks and countermeasures. In ICWS
[1], pp. 575–582.

[16] GAJEK, S., LIAO, L., AND SCHWENK, J. Breaking and ﬁxing
the inline approach. In SWS ’07: Proceedings of the 2007 ACM
workshop on Secure web services (New York, NY, USA, 2007),
ACM, pp. 37–43.

[17] GAJEK, S., LIAO, L., AND SCHWENK, J. Towards a formal
semantic of xml signature. W3C Workshop Next Steps for XML
Signature and XML Encryption, 2007.

[18] GROSS, T. Security Analysis of the SAML SSO Browser/Artifact
Proﬁle. In ACSAC (2003), IEEE Computer Society, pp. 298–307.
[19] GROSS, T., AND PFITZMANN, B. SAML artifact information
ﬂow revisited. In In IEEE Workshop on Web Services Security
(WSSS) (Berkeley, May 2006), IEEE, pp. 84–100.

[20] GRUSCHKA, N., AND IACONO, L. L. Vulnerable cloud: Soap
message security validation revisited. In ICWS [1], pp. 625–631.

[21] GUDGIN, M., HADLEY, M., MENDELSOHN, N., MOREAU, J.-
J., AND NIELSEN, H. F. SOAP Version 1.2 Part 1: Messaging
Framework. W3C Recommendation (2003).

[22] HARDING, P., JOHANSSON, L., AND KLINGENSTEIN, N. Dy-
namic security assertion markup language: Simplifying single
sign-on. Security Privacy, IEEE 6, 2 (march-april 2008), 83 –
85.

[23] JENSEN, M., LIAO, L., AND SCHWENK, J. The curse of names-
paces in the domain of xml signature. In SWS (2009), E. Damiani,
S. Proctor, and A. Singhal, Eds., ACM, pp. 29–36.

[24] JENSEN, M., MEYER, C., SOMOROVSKY, J., AND SCHWENK,
J. On the effectiveness of xml schema validation for counter-
ing xml signature wrapping attacks. In Securing Services on the
Cloud (IWSSC), 2011 1st International Workshop on (sept. 2011),
pp. 7 –13.

[25] LUTZ, D., AND STILLER, B. Combining identity federation with
payment: The saml-based payment protocol. In Network Oper-
ations and Management Symposium (NOMS), 2010 IEEE (april
2010), pp. 495 –502.

[26] MALER, E., AND REED, D. The venn of identity: Options and
issues in federated identity management. Security Privacy, IEEE
6, 2 (march-april 2008), 16 –23.

[27] MCINTOSH, M., AND AUSTEL, P. XML Signature Element
Wrapping Attacks and Countermeasures. In SWS ’05: Proceed-
ings of the 2005 workshop on Secure web services (New York,
NY, USA, 2005), ACM Press, pp. 20–27.

[28] MCINTOSH, M., AND AUSTEL, P. XML signature element
wrapping attacks and countermeasures. In Workshop on Secure
Web Services (2005).

[29] NADALIN, A., KALER, C., MONZILLO, R., AND HALLAM-
BAKER, P. Web Services Security: SOAP Message Security 1.1
(WS-Security 2004). OASIS Standard (2006).

[30] RAHAMAN, M. A., MARTEN, R., AND SCHAAD, A. An inline
approach for secure soap requests and early validation. OWASP
AppSec Europe, 2006.

[31] RAHAMAN, M. A., AND SCHAAD, A. Soap-based secure con-

versation and collaboration. In ICWS (2007), pp. 471–480.

[32] RAHAMAN, M. A., SCHAAD, A., AND RITS, M. Towards se-
In Workshop on Secure

cure soap message exchange in a soa.
Web Services (2006).

[33] SOMOROVSKY, J., HEIDERICH, M., JENSEN, M., SCHWENK,
J., GRUSCHKA, N., AND IACONO, L. L. All Your Clouds are
Belong to us – Security Analysis of Cloud Management Inter-
faces. In The ACM Cloud Computing Security Workshop (CCSW)
(Oct. 2011).

[34] THE APACHE SOFTWARE FOUNDATION. Apache Xerces.
[35] TSCHOFENIG, H., FALK, R., PETERSON, J., HODGES, J.,
SICKER, D., AND POLK, J. Using saml to protect the session
initiation protocol (sip). Network, IEEE 20, 5 (sept.-oct. 2006),
14 –17.

[36] VAN DER VLIST, E. XML Schema. O’Reilly, 2002.
[37] WAGNER, D., AND SCHNEIER, B. Analysis of the SSL 3.0 pro-
In In Proceedings of the Second USENIX Workshop on
tocol.
Electronic Commerce (1996), USENIX Association, pp. 29–40.
[38] WANG, R., CHEN, S., AND WANG, X. Signing Me onto Your
Accounts through Facebook and Google: a Trafﬁc-Guided Secu-
rity Study of Commercially Deployed Single-Sign-On Web Ser-
vices. In IEEE Symposium on Security and Privacy (Oakland),
IEEE Computer Society (May 2012).

[39] YONG-SHENG, Z., AND JING, Y. Research of dynamic authen-
tication mechanism crossing domains for web services based on
saml. In Future Computer and Communication (ICFCC), 2010
2nd International Conference on (may 2010), vol. 2, pp. V2–395
–V2–398.

