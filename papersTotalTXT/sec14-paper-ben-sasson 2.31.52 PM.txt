Succinct Non-Interactive Zero Knowledge  

for a von Neumann Architecture

Eli Ben-Sasson, Technionâ€”Israel Institute of Technology; Alessandro Chiesa,  

Massachusetts Institute of Technology; Eran Tromer, Tel Aviv University;  

Madars Virza, Massachusetts Institute of Technology

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/ben-sasson

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20â€“22, 2014 â€¢ San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXSuccinct Non-Interactive Zero Knowledge for a von Neumann Architecture

Eli Ben-Sasson

Alessandro Chiesa

Technion

MIT

Eran Tromer
Tel Aviv University

Madars Virza

MIT

Abstract

Cryptography offers a powerful tool to address these se-
curity concerns: zero-knowledge proofs [43]. The server,
acting as the prover, attempts to convince the client, act-
ing as the veriï¬er, that the following NP statement is true:
â€œthere exists w such that z = F(x,w)â€. Indeed:
â€¢ The soundness property of the proof system guarantees
that, if the NP statement is false, the prover cannot
convince the veriï¬er (with high probability). Thus,
soundness addresses the clientâ€™s integrity concern.

â€¢ The zero-knowledge property of the proof system guar-
antees that, if the NP statement is true, the prover can
convince the veriï¬er without leaking any information
about w (beyond was is leaked by the output z). Thus,
zero knowledge addresses the serverâ€™s conï¬dentiality.
Moreover, the client sometimes not only seeks soundness
but also proof of knowledge [43, 11], which guarantees
that, whenever he is convinced, not only can he deduce
that a witness w exists, but also that the server knows one
such witness. This stronger property is often necessary to
security if F encodes cryptographic computations, and is
satisï¬ed by most zero-knowledge proof systems.

Efï¬ciency. Besides the aforementioned security desider-
ata, many settings also call for efï¬ciency desiderata. The
client may be either unable or unwilling to engage in
lengthy interactions with the server, or to perform large
computations beyond the â€œbare minimumâ€ of sending the
input x and receiving the output z. For instance, the client
may be a computationally-weak device with intermittent
connectivity (e.g., a smartphone).

Thus, it is desirable for the proof to be non-interactive
[25, 55, 23]: the server just send the claimed output Ëœz,
along with a non-interactive proof string Ï€ that attests
that Ëœz is the correct output. Moreover, it is also desirable
for the proof to be succinct: Ï€ has size OÎ» (1) and can be
veriï¬ed in time OÎ» (|F| +|x| +|z|), where OÎ» (Â·) is some
polynomial in a security parameter Î» ; in other words, Ï€ is
very short and easy to verify (i.e., veriï¬cation time does
not depend on |w|, nor Fâ€™s running time).

We build a system that provides succinct non-interactive
zero-knowledge proofs (zk-SNARKs) for program execu-
tions on a von Neumann RISC architecture. The system
has two components: a cryptographic proof system for
verifying satisï¬ability of arithmetic circuits, and a circuit
generator to translate program executions to such circuits.
Our design of both components improves in functionality
and efï¬ciency over prior work, as follows.

Our circuit generator is the ï¬rst to be universal:

it
does not need to know the program, but only a bound
on its running time. Moreover, the size of the output
circuit depends additively (rather than multiplicatively)
on program size, allowing veriï¬cation of larger programs.
The cryptographic proof system improves proving and
veriï¬cation times, by leveraging new algorithms and a
pairing library tailored to the protocol.

Introduction

We evaluated our system for programs with up to
10,000 instructions, running for up to 32,000 machine
steps, each of which can arbitrarily access random-access
memory; and also demonstrated it executing programs
that use just-in-time compilation. Our proofs are 230
bytes long at 80 bits of security, or 288 bytes long at
128 bits of security. Typical veriï¬cation time is 5 ms,
regardless of the original programâ€™s running time.
1
1.1 Goal
Consider the setting where a client owns a public input x,
a server owns a private input w, and the client wishes to
learn z := F(x,w) for a program F known to both parties.
For instance, x may be a query, w a conï¬dential database,
and F the program that executes the query on the database.
Security. The client is concerned about integrity of
computation: how can he ascertain that the server reports
the correct output z? In contrast, the server is concerned
about conï¬dentiality of his own input: how can he prevent
the client from learning information about w?

USENIX Association  

23rd USENIX Security Symposium  781

zk-SNARKs. A proof system achieving the above se-
curity and efï¬ciency desiderata is called a (publicly-
veriï¬able) zero-knowledge Succinct Non-interactive AR-
gument of Knowledge (zk-SNARK). zk-SNARK con-
structions can be applied to a wide range of security appli-
cations, provided these constructions deliver good enough
efï¬ciency, and support rich enough functionality (i.e., the
class of programs F that is supported).

Remark 1.1. In the zero-knowledge setting above, the
client does not have the serverâ€™s input, and so cannot
conduct the computation on his own. Hence, it is not
meaningful to compare â€œefï¬ciency of outsourced compu-
tation at the serverâ€ and â€œefï¬ciency of native execution at
the clientâ€, because the latter was never an option. Non-
interactive zero-knowledge proofs (and zk-SNARKs) are
useful regardless of cross-over points.

Our goal in this paper is to construct

a zk-SNARK implementation supporting executions on a

universal von Neumann RISC machine.

1.2 Prior work
zk-SNARKs. Many works have obtained zk-SNARK
constructions [45, 51, 38, 22, 56, 16, 52, 27]. Three of
these [56, 16, 27] provide implementations, and thus we
brieï¬‚y recall them. Parno et al. [56] present two main
contributions.
â€¢ A zk-SNARK, with essentially-optimal asymptotics,
for arithmetic circuit satisï¬ability, based on quadratic
arithmetic programs (QAPs) [38]. They accompany
their construction with an implementation.

â€¢ A compiler that maps C programs with ï¬xed memory
accesses and bounded control ï¬‚ow (e.g., array accesses
and loop iteration bounds are compile-time constants)
into corresponding arithmetic circuits.

Ben-Sasson et al. [16] present three main contributions.
â€¢ Also a QAP-based zk-SNARK with essentially-
optimal asymptotics for arithmetic circuit satisï¬ability,
and a corresponding implementation. Their construc-
tion follows the linear-interactive proofs of [22].

â€¢ A simple RISC architecture, TinyRAM, along with a
circuit generator for generating arithmetic circuits that
verify correct execution of TinyRAM programs.

sponding TinyRAM program.

â€¢ A compiler that, given a C program, produces a corre-
Finally, Braun et al. [27] re-implemented the protocol
of [56] and combined it with a circuit generator that in-
corporates memory-checking techniques [24] to support
random-access memory [14].
Outsourcing computation to powerful servers. Nu-
merous works [63, 65, 66, 64, 32, 68, 71, 67, 27] seek to
veriï¬ably outsource computation to untrusted powerful

servers, e.g., in order to make use of cheaper cycles or
storage. (See Appendix A for a summary.) We stress that
veriï¬able outsourcing of computations is not our goal.
Rather, as mentioned, we study functionality and efï¬-
ciency aspects of non-interactive zero-knowledge proofs,
which are useful even when applied to relatively-small
computations, and even with high overheads.

Compared to most protocols to outsource computations,
known zk-SNARKs use â€œheavyweightâ€ techniques, such
as probabilistically-checkable proofs [6] and expensive
pairing-based cryptography. The optimal choice of pro-
tocol, and whether it actually pays off compared to local
native execution, are complex, computation-dependent
questions [71], and we leave to future work the ques-
tion of whether zk-SNARKs are useful for the goal of
outsourcing computations.

1.3 Limitations of prior work
Recent work has made tremendous progress in taking
zk-SNARKs from asymptotic theory into concrete im-
plementations. Yet, known implementations suffer from
several limitations.
Per-program key generation. As in any non-interactive
zero-knowledge proof, a zk-SNARK requires a one-time
trusted setup of public parameters: a key generator sam-
ples a proving key (used to generate proofs) and a ver-
iï¬cation key (used to check proofs). However, current
zk-SNARK implementations [56, 16] require the setup
phase to depend on the program F, which is hard-coded
in the keys. Key generation is costly (quasilinear in Fâ€™s
runtime) and is thus difï¬cult to amortize if conducted
anew for each program. More importantly, per-program
key generation requires, for each new choice of program,
a trusted partyâ€™s help.
Limited support for high-level languages. Known cir-
cuit generators have limited functionality or efï¬ciency:
(i) [56]â€™s circuit generator only supports programs with-
out data dependencies, since memory accesses and loop
iteration bounds cannot depend on a programâ€™s input;
(ii) [27]â€™s circuit generator allows data-dependent memory
accesses, but each such access requires expensive hashing
to verify Merkle-tree authentication paths; (iii) [16]â€™s cir-
cuit generator supports arbitrary programs but its circuit
size scales inefï¬ciently with program size (namely, it has
size â„¦((cid:31)T ) for (cid:31)-instruction T -step TinyRAM programs).
Moreover, while there are techniques that mitigate some
of the above limitations [72], these only apply in special
cases, and not do address general data dependencies, a
common occurrence in many programs.
Generic
aforementioned
zk-SNARKs use several sub-algorithms, and in particular
elliptic curves and pairings. Protocol-speciï¬c optimiza-
tions are a key ingredient in fast implementations of

sub-algorithms.

The

782  23rd USENIX Security Symposium 

USENIX Association

2

pairing-based protocols [59], yet prior implementations
only utilize off-the-shelf cryptographic libraries, and miss
key optimization opportunities.

1.4 Results
We present two main contributions: a new circuit genera-
tor and a new zk-SNARK for circuits. These can be used
independently, or combined to obtain an overall system.

1.4.1 A new circuit generator
We design and build a new circuit generator that incorpo-
rates the following two main improvements.
(1) Our circuit generator is universal: when given input
bounds (cid:31),n,T , it produces a circuit that can verify the
execution of any program with â‰¤ (cid:31) instructions, on any
input of size â‰¤ n, for â‰¤ T steps. Instead, all prior circuit
generators [66, 64, 56, 16, 27] hardcoded the program
in the circuit. Combined with a zk-SNARK for circuits
(or any NP proof system for circuits), we achieve a no-
table conceptual advance: once-and-for-all key genera-
tion that allows verifying all programs up to a given size.
This removes major issues in all prior systems: expen-
sive per-program key generation, and the thorny issue of
conducting it anew in a trusted way for every program.

Our circuit generator supports a universal machine
that, like modern computers, follows the von Neumann
paradigm (program and data lie in the same read/write
address space). Concretely, it supports a von Neumann
RISC architecture called vnTinyRAM, a modiï¬cation of
TinyRAM [17]. Thus, we also support programs leverag-
ing techniques such as just-in-time compilation or self-
modifying code [36, 58].

To compile C programs to the vnTinyRAM machine
language, we ported the GCC compiler to this architecture,
building on the work of [16].

See Figure 1 for a functionality comparison with prior

circuit generators (for details, see [27, Â§2]).
Supported functionality
side-effect free comp.
data-dep. mem. accesses
data-dep. contr. ï¬‚ow
self-modifying code
universality

[66, 64, 56]

[16]
(cid:31)
(cid:31)
(cid:31)
Ã—
Ã—

(cid:31)
Ã—
Ã—
Ã—
Ã—

[27]
(cid:31)
(cid:31)
Ã—
Ã—
Ã—

this work

(cid:31)
(cid:31)
(cid:31)
(cid:31)
(cid:31)

Figure 1: Functionality comparison among circuit generators.

(2) Our circuit generator efï¬ciently handles larger arbi-
trary programs: the size of the generated circuit C(cid:31),n,T

pendence on program size is additive, instead of multi-
plicative as in [16], where the generated (non-universal)

is O(cid:31)((cid:31) + n + T ) Â· log((cid:31) + n + T )(cid:30) gates. Thus, the de-
circuit has size Î˜(cid:31)(n +T )Â· (log(n +T ) + (cid:31))(cid:30). As Figure 2

shows, our efï¬ciency improvement compared to [16] is

not merely asymptotic but yields sizable concrete sav-
ings: as program size (cid:31) increases, our amortized per-cycle
gate count is essentially unchanged, while that of [16]
grows without bound, becoming orders of magnitudes
more expensive.

|C(cid:31),n,T|/T

improvement

n = 102
T = 220
(cid:31) = 103
(cid:31) = 104
(cid:31) = 105
(cid:31) = 106

[16]
1,872
10,872
100,872
1,000,872

1.4Ã—
7.9Ã—
72.1Ã—
590.8Ã—
Figure 2: Per-cycle gate count improvements over [16].

this work
1,368
1,371
1,400
1,694

An efï¬ciency comparison with other non-universal cir-
cuit generators [66, 64, 56, 27] is not well-deï¬ned. First,
they support more restricted classes of programs, so a pro-
grammer must â€œwrite aroundâ€ the limited functionality.
Second, their efï¬ciency is not easily speciï¬ed, since the
output circuit is ad hoc for the given program, and the only
way to know its size is to actually run the circuit generator.
We expect, and ï¬nd, that such circuit generators perform
better than ours for programs that are already â€œclose to a
circuitâ€, and worse for programs rich in data-dependent
memory accesses and control ï¬‚ow.

1.4.2 A new zk-SNARK for circuits
Our third contribution is a high-performance implementa-
tion of a zk-SNARK for arithmetic circuits.
(3) We improve upon and implement the protocol of Parno
et al. [56]. Unlike previous zk-SNARK implementations
[56, 16, 27], we do not use off-the-shelf cryptographic
libraries. Rather, we create a tailored implementation
of the requisite components: the underlying ï¬nite-ï¬eld
arithmetic, elliptic-curve group arithmetic, pairing-based
checks, and so on.

To facilitate comparison with prior work, we instanti-
ate our techniques for two speciï¬c algebraic setups: we
provide an instantiation based on Edwards curves [33] at
80 bits of security (as in [16]), and an instantiation based
on Barretoâ€“Naehrig curves [9] at 128 bits of security (as
in [56, 27]).

On our reference platform (a typical desktop), proof
veriï¬cation is fast: at 80-bit security, for an n-byte input
to the circuit, veriï¬cation takes 4.7 + 0.0004Â· n millisec-
onds, regardless of circuit size; at 128-bit security, it takes
4.8 + 0.0005Â· n. The constant term dominates for small
inputs, and corresponds to the veriï¬erâ€™s pairing-based
checks; in both cases, it is less than half the time for sep-
arately evaluating the 12 requisite pairings of the checks.
We achieve this saving by merging parts of the pairingsâ€™
computation in a protocol-dependent way â€” another rea-
son for a custom implementation of the underlying math.

USENIX Association  

23rd USENIX Security Symposium  783

3

Key generation and proof generation entail a per-gate
cost. For example, for a circuit with 16 million gates: at
80 bits of security, key generation takes 81 Âµs per gate
and proving takes 109 Âµs per gate; at 128 bits of security,
these per-gate costs mildly increase to 100 Âµs and 144 Âµs.
As in previous zk-SNARK implementations, proofs
have constant size (independent of the circuit or input
size); for us, they are 230 bytes at 80 bits of security, and
288 bytes at 128 bits of security.

Compared to previous implementations of zk-SNARKs
for circuits [56, 16, 27], our implementation improves
both proving and veriï¬cation times, e.g., see Figure 3.

80 bits of security

128 bits of security

Key gen.
Prover
Veriï¬er
Proof

[16]
306s
351s
66.1ms
322B

this
97s
115s
4.9ms
230B

impr.
3.2Ã—
3.1Ã—
13.5Ã—
1.4Ã—

[56]
123s
784s
9.2ms
288B

this
117s
147s
5.1ms
288B

impr.
1.1Ã—
5.3Ã—
1.8Ã—
(same)

Figure 3: Comparison with prior zk-SNARKs for a 1-million-gate arith-
metic circuit and a 1000-bit input, running on our benchmarking ma-
chine, using software provided by the respective authors. Since [27] is
a re-implementation of [56], we only include the latterâ€™s performance.
(N = 5 and std < 2%)

1.4.3 Two components: independent or combined
Our new circuit generator and our new zk-SNARK for
circuits can be used independently. For instance, the
circuit generator can (up to interface matching) replace
the circuit generators in [66, 64, 56, 16, 27], thus granting
these systems universality. Similarly, our zk-SNARK
for circuits can replace the underlying zk-SNARKs in
[56, 16, 27], or be used directly in applications where a
suitable circuit is already speciï¬ed.

Combining these two components, we obtain a full
system: a zk-SNARK for proving/verifying correctness of
vnTinyRAM computations; see Figure 4 and Figure 5 for
diagrams of this system. We evaluated this overall sys-
tem for programs with up to 10,000 instructions, running
for up to 32,000 steps. Veriï¬cation time is, again, only
few milliseconds, independent of the running time of the
vnTinyRAM program, even when program size and input
size are kilobytes. Proofs, as mentioned, have a small
constant size. Key generation and proof generation entail
a per-cycle cost, with a dependence on program size that
â€œtapers offâ€ as computation length increases. For instance,
at 128-bit security and vnTinyRAM with a word size of
32 bits, key generation takes 210ms per cycle and proving
takes 100ms per cycle, for 8K-instruction programs.
JIT case study: efï¬cient memcpy. Besides evaluat-
ing individual components, we give an example demon-
strating the rich functionality supported by the integrated
system. We wrote a vnTinyRAM implementation of
memcpy that leverages just-in-time compilation (in par-

OFFLINE PHASE (ONCE) 

Key Generator 

circuit 

generator 

universal 
circuit 

zk-SNARK 

key generator 

program size bound 
input size bound 
time bound 

proving key 

verification key 

Figure 4: Ofï¬‚ine phase (once). The key generator outputs a proving
key and veriï¬cation key, for proving and verifying correctness of any
program execution meeting the given bounds.

Prover 

ONLINE PHASE (ANY NUMBER OF TIMES) 
Verifier 

auxiliary 
input 

(nondeterminism) 

witness 
map 

circuit 

assignment 

zk-SNARK 
prover 

proof 

zk-SNARK 
verifier 

accept/ 
reject 

program  input 

proving key 

verif. key 

program  input 

Figure 5: Online phase (any number of times). The prover sends a
short and easy-to-verify proof to a veriï¬er. This can be repeated any
number of times, each time for a different program and input.

ticular, dynamic loop unrolling) to require fewer cycles.
(See Section B.)
2 Preliminaries
F[z] denotes the ring of univariate polynomials over F,
and by Fâ‰¤d[z] the subring of polynomials of degree â‰¤ d.
Concatenation of vectors/scalars is denoted by â—¦.
2.1 Arithmetic circuits
Given a ï¬nite ï¬eld F, an F-arithmetic circuit takes inputs
that are elements in F, and its gates output elements in F.
The circuits we consider only have bilinear gates.1
Deï¬nition 2.1. Let n,h,l respectively denote the input,
witness, and output size. The circuit satisfaction prob-
lem of a circuit C : Fn Ã— Fh â†’ Fl with bilinear gates is
deï¬ned by the relation RC = {((cid:28)x,(cid:28)a) âˆˆ FnÃ—Fh : C((cid:28)x,(cid:28)a) =
0l} and language LC = {(cid:28)x âˆˆ Fn : âˆƒ(cid:28)a âˆˆ Fh, C((cid:28)x,(cid:28)a) = 0l}.
All the arithmetic circuits we consider are over prime
ï¬elds Fp. In this case, when passing boolean strings as
inputs to arithmetic circuits, we pack the stringâ€™s bits into
as few ï¬eld elements as possible: given s âˆˆ {0,1}m, we
use [[s]]m
, where |m|p :=
(cid:22)m/(cid:21)log p(cid:20)(cid:19), such that the binary representation of xi âˆˆ
Fp is the i-th block of (cid:22)log p(cid:19) bits in s (padded with 0â€™s if
needed). We extend the notation [[s]]m
p to binary strings s âˆˆ
p := [[s0mâˆ’n]]m
{0,1}n with n < m bits via padding: [[s]]m
p .
2.2 Quadratic arithmetic programs
Our zk-SNARK leverages quadratic arithmetic programs
(QAPs), introduced by Gennaro et al. [38].
Deï¬nition 2.2. A quadratic arithmetic program of size
m and degree d over F is a tuple ((cid:28)A,(cid:28)B, (cid:28)C,Z), where
(cid:28)A,(cid:28)B, (cid:28)C are three vectors, each of m + 1 polynomials in
Fâ‰¤dâˆ’1[z], and Z âˆˆ F[z] has degree exactly d.
1A gate with inputs x1, . . . ,x m âˆˆ F is bilinear if the output is
(cid:17)(cid:28)a, (1,x1, . . . ,x m)(cid:16)Â·(cid:17)(cid:28)b, (1,x1, . . . ,x m)(cid:16) for some (cid:28)a,(cid:28)b âˆˆ Fm+1. In particu-
lar, these include addition, multiplication, and constant gates.

p to denote the vector (cid:28)x âˆˆ F|m|p

p

784  23rd USENIX Security Symposium 

USENIX Association

4

Like a circuit, a QAP induces a satisfaction problem:

Deï¬nition 2.3. The satisfaction problem of a size-m
QAP ((cid:31)A,(cid:31)B, (cid:31)C,Z) is the relation R((cid:31)A,(cid:31)B,(cid:31)C,Z) of pairs ((cid:31)x,(cid:31)s)
such that (i) (cid:31)x âˆˆ Fn, (cid:31)s âˆˆ Fm, and n â‰¤ m; (ii) xi = si for
i âˆˆ [n] (i.e., (cid:31)s extends (cid:31)x); and (iii) the polynomial Z(z)
divides the following one:

(A0(z) + âˆ‘m

i=1 siAi(z))Â· (B0(z) + âˆ‘m

i=1 siBi(z))

âˆ’ (C0(z) + âˆ‘m

i=1 siCi(z)) .

We denote by L((cid:31)A,(cid:31)B,(cid:31)C,Z) the language of R((cid:31)A,(cid:31)B,(cid:31)C,Z).
Gennaro et al. [38] showed that circuit satisï¬ability can
be efï¬ciently reduced to QAP satisï¬ability (which can
then be proved and veriï¬ed using zk-SNARKs):

Lemma 2.4. There exist two polynomial-time algorithms
QAPinst, QAPwit that work as follows. For any circuit
C : FnÃ—Fh â†’ Fl with a wires and b gates, ((cid:31)A,(cid:31)B, (cid:31)C,Z) :=
QAPinst(C) is a QAP of size m and degree d over F that
satisï¬es the following three properties.
â€¢ EFFICIENCY. It holds that m = a and d = b + l + 1.
â€¢ COMPLETENESS. For any ((cid:31)x,(cid:31)a) âˆˆ RC, it holds that
â€¢ PROOF OF KNOWLEDGE. For any ((cid:31)x,(cid:31)s) âˆˆ R((cid:31)A,(cid:31)B,(cid:31)C,Z),
â€¢ NON-DEGENERACY. The polynomials A0, . . . ,A n are

((cid:31)x,(cid:31)s) âˆˆ R((cid:31)A,(cid:31)B,(cid:31)C,Z), where (cid:31)s := QAPwit(C,(cid:31)x,(cid:31)a).
it holds that ((cid:31)x,(cid:31)a) âˆˆ RC, where (cid:31)a is a preï¬x of (cid:31)s.
nonzero and distinct.

2.3 Pairings
Let G1 and G2 be two cyclic groups of order r. We
denote elements of G1,G2 via calligraphic letters such
as P, Q. We write G1 and G2 in additive notation.
Let P1 be a generator of G1, i.e., G1 = {Î±P1}Î±âˆˆFr
(Î± is also viewed as an integer, hence Î±P1 is well-
deï¬ned); let P2 be a generator for G2. A pairing is
an efï¬cient map e: G1 Ã— G2 â†’ GT , where GT is also a
cyclic group of order r (which we write in multiplicative
notation), satisfying the following properties: (i) bilin-
earity: for every nonzero elements Î±,Î² âˆˆ Fr, it holds
that e(Î±P1,Î² P2) =e(P 1, P2)Î±Î² ; (ii) non-degeneracy:
e(P1, P2) is not the identity in GT .

zk-SNARKs for arithmetic circuits

2.4
A (preprocessing) zk-SNARK for F-arithmetic circuit
satisï¬ability (see, e.g., [22]) is a triple of polynomial-
time algorithms (G,P,V ), called key generator, prover,
and veriï¬er. The key generator G, given a security pa-
rameter Î» and an F-arithmetic circuit C : Fn Ã— Fh â†’ Fl,
samples a proving key pk and a veriï¬cation key vk; these
are the proof systemâ€™s public parameters, which need
to be generated only once per circuit. After that, any-
one can use pk to generate non-interactive proofs for the

language LC, and anyone can use the vk to check these
proofs. Namely, given pk and any ((cid:31)x,(cid:31)a) âˆˆ RC, the hon-
est prover P(pk,(cid:31)x,(cid:31)a) produces a proof Ï€ attesting that
(cid:31)x âˆˆ LC; the veriï¬er V (vk,(cid:31)x,Ï€) checks that Ï€ is a valid
proof for(cid:31)x âˆˆ LC. A proof Ï€ is both a proof of knowledge,
and a (statistical) zero-knowledge proof. The succinctness
property requires that Ï€ has length OÎ» (1) and V runs in
time OÎ» (|(cid:31)x|), where OÎ» hides a (ï¬xed) polynomial in Î» .
Constructions. Several zk-SNARK constructions are
known [45, 51, 38, 22, 56, 16, 52]. The most efï¬cient ones
are based on quadratic span programs (QSPs) [38, 52] or
quadratic arithmetic programs (QAPs) [38, 22, 56, 16].
We focused on QAP-based constructions, because QAPs
allow for tighter reductions from arithmetic circuits (see
Lemma 2.4). Concretely, we build on the QAP-based
zk-SNARK protocol of Parno et al. [56] (see Section 4).

Remark 2.5 (full succinctness). The key generator G
takes C as input, and so its complexity is linear in |C|.
One could require G to not take C as input, and have
its output keys work for all (polynomial-size) circuits
C; then, Gâ€™s running time would be independent of C.
A zk-SNARK satisfying this stronger property is fully
succinct. Theoretical constructions of such zk-SNARKs
are known, based on various cryptographic assumptions
[54, 69, 21]. Despite achieving essentially-optimal asymp-
totics [6, 18, 15, 14, 21] no implementations of them have
been reported to date.

2.5 A von Neumann RISC architecture
Ben-Sasson et al. [16] introduced TinyRAM, a Harvard
RISC architecture with word-addressable memory. We
modify TinyRAM to obtain vnTinyRAM, which differs
from it in two main ways. First, vnTinyRAM follows the
von Neumann paradigm, whereby program and data are
stored in the same read-write address space; programs
may use runtime code generation. Second, vnTinyRAM
has byte-addressable memory, along with instructions to
load/store bytes or words.2

Besides the above main differences, vnTinyRAM is
very similar to TinyRAM. Namely, it is parametrized by
the word size, denoted W , and the number of registers,
denoted K. The CPU state of the machine consists of
(i) a W -bit program counter; (ii) K general-purpose W -bit
registers; (iii) a 1-bit condition ï¬‚ag. The full state of the
machine also includes memory, which is a linear array
of 2W bytes, and two tapes, each with a string of W -bit
words, and read-only in one direction. One tape is for a
primary input
(treated as nondeterministic, untrusted advice).

and the other for an auxiliary input

2Byte-addressing is common in programs performing array or string
operations (and is a deeply-ingrained assumption in the GCC and LLVM
compilers), while word-addressing in programs performing arithmetic.

USENIX Association  

23rd USENIX Security Symposium  785

5

In memory, an instruction is represented as a double
word (one word for an immediate, and another for opcode,
etc.). Thus, a program is a list of address/double-word
pairs specifying the initial contents of memory; all other
memory locations assume the initial value of 0.

We deï¬ne the language of accepting computations:

Deï¬nition 2.6. Fix bounds (cid:31),n,T . The language L(cid:31),n,T
consists of pairs ( , ) such that: (i)
is a program
with â‰¤ (cid:31) instructions, (ii)
is a primary input with â‰¤ n
words, (iii) there exists an auxiliary input
)
accepts in â‰¤ T steps. We denote by R(cid:31),n,T the relation
corresponding to L(cid:31),n,T .

s.t.

( ,

3 Our circuit generator
A circuit generator translates the correctness of suitably-
bounded program executions into circuit satisï¬ability:
given input bounds (cid:31),n,T , it produces a circuit that can
verify the execution of any program with â‰¤ (cid:31) instructions,
on any input of size â‰¤ n, for â‰¤ T steps. More precisely,
using the notations [[s]]p (for packing the binary string
s into ï¬eld elements) and |s|p (for computing the num-
ber of ï¬eld elements required to pack s) introduced in
Section 2.1, we deï¬ne a (universal) circuit generator for
vnTinyRAM as follows.

Deï¬nition 3.1. A (universal) circuit generator of efï¬-
ciency f (Â·) over a prime ï¬eld Fp is a polynomial-time
algorithm circ, together with an efï¬cient witness map
wit, working as follows. For any program size bound
(cid:31), time bound T , and primary-input size bound n, C :=
circ((cid:31),n,T ) is an Fp-arithmetic circuit C : Fm
p â†’ Fl
p,
for m := |(cid:31)2W|p +|nW|p and some h,l, where W is the
word size (cf. Section 2.5).
â€¢ EFFICIENCY. The circuit C has f ((cid:31),n,T ) gates.
â€¢ COMPLETENESS. Given any program , primary in-
such that(cid:31)( , ), (cid:30) âˆˆ R(cid:31),n,T , it
put
â—¦ [[ ]]nW
holds that ((cid:29)x,(cid:29)a) âˆˆ RC, where (cid:29)x := [[
p and
(cid:29)a := wit((cid:31),n,T,
â€¢ PROOF OF KNOWLEDGE. There is a polynomial-time
algorithm such that, given any ((cid:29)x,(cid:29)a) âˆˆ RC, outputs a
witness

, and witness

p Ã—Fh

]](cid:31)2W
p

for ( , ) âˆˆ L(cid:31),n,T .

,

,

).

The circuit C output by circ is universal because it does
not depend on the program or primary input
, but only
on their respective size bounds (cid:31) and n (as well as the
time bound T ). When combined with any proof system
for circuit satisï¬ability (e.g., our zk-SNARK), this fact
enables the generation of the proof systemsâ€™ parameters
to be universal as well. Namely, it is possible to generate
keys for all bound choices (e.g., in powers of 2) up to some
constant, once and for all; afterwards, one can pick the
keys corresponding to bounds ï¬tting a given computation.
This avoids expensive per-program key generation and,

more importantly, the need for a trusted party to conduct
key generation anew for every program.

We construct a universal circuit generator with the fol-

lowing efï¬ciency:

Theorem 3.2. There is a circuit generator of efï¬ciency

f ((cid:31),n,T ) =O(cid:31)((cid:31) + n + T ) Â· log((cid:31) + n + T )(cid:30) over any

prime ï¬eld Fp of size p > 22W , where W is the word
size (cf. Section 2.5).

(In our case, the condition p > 22W is always fulï¬lled.)

3.1 Past techniques
Most of the difï¬culties that arise when designing a circuit
generator have to do with data dependencies. A circuitâ€™s
topology does not depend on its inputs but, in contrast,
program ï¬‚ow and memory accesses depend on the choice
of program and the programâ€™s inputs. Thus, a circuit
tasked with verifying program executions must be â€œreadyâ€
to support a multitude of program ï¬‚ows and memory
accesses, despite the fact that its topology has already
been ï¬xed. Various techniques have been applied to the
design of circuit generators.
Program analysis.
and its inputs ( ,

In the extreme, if both the program
) are known in advance, designing
a circuit generator is simple: construct a circuit that eval-
uates
) by preparing the circuitâ€™s topology to
match the pre-determined program ï¬‚ow and memory ac-
cesses. But now suppose that only
is known in advance,
but not its inputs ( ,
piece by piece (e.g., separately examine the various loops,
branches, and so on), one could try to design a circuit C
that can handle different choices of inputs. Most prior
circuit generators [66, 64, 56, 27] take this approach.

). In this case, by analyzing

on ( ,

However, this approach suffers from several limitations.
First, the class of supported programs
is not rich, be-
cause support for data dependencies is limited. E.g., [56]
requires array accesses and loop iteration bounds to be
compile-time constants; also, while [27] supports data-
dependent memory accesses, most program ï¬‚ow is also
restricted to be known (or bounded) at compile-time; mit-
igations are possible, but only in special cases [72]. Sec-
ond, and more importantly, this approach does not seem to
allow for designing universal circuit generators, because
the program is not known in advance and thus there is
no program to analyze.
Multiplex every access.
Computers are universal
random-access machines (RAMs), so one approach of
designing a universal circuit is to mimic a computerâ€™s
execution, building a layered circuit as follows. The i-th
layer contains the entire state of the machine (CPU state
and random-access memory) at time step i, and layer i +1
is computed from it by evaluating the transition function

786  23rd USENIX Security Symposium 

USENIX Association

6

of the machine, handling any accesses to memory via mul-
tiplexing. While this approach supports arbitrary program
ï¬‚ow, memory accesses are inefï¬ciently supported; indeed,
if memory has S addresses, the resulting circuit is huge:
it has size â„¦(T S).
Nondeterministic routing. Ben-Sasson et al. [14] sug-
gested using nondeterministic routing on a BeneË‡s network
to support memory accesses efï¬ciently; Our circuit gen-
erator builds on the techniques of [14, 16], so we brieï¬‚y
review the main idea behind nondeterministic routing.

Following [14], Ben-Sasson et al. [16] introduced a
simple computer architecture, called TinyRAM, and con-
structed a routing-based circuit generator for TinyRAM.
They deï¬ne the following notions. A CPU state, denoted
S, is the CPUâ€™s contents (e.g., program counter, regis-
ters, ï¬‚ags) at a given time step. An execution trace for
a program , time bound T , and primary input
is a
sequence tr = (S1, . . . ,S T ) of CPU states. An execution
such that
trace tr is valid if there is an auxiliary input
the execution trace induced by
)
is tr.

running on inputs ( ,

We seek an arithmetic circuit C for verifying that tr is
valid. We break this down by splitting validity into three
sub-properties: (i) validity of instruction fetch (for each
time step, the correct instruction is fetched); (ii) validity
of instruction execution (for each time step, the fetched
instruction is correctly executed); and (iii) validity of
memory accesses (each load from an address retrieves the
value of the last store to that address).

The ï¬rst two properties are veriï¬ed as follows. Con-
struct a circuit C so that, for any two CPU states S and S(cid:31),
C (S,S(cid:31),g) is satisï¬ed for some â€œguessâ€ g if and only if S(cid:31)
can be reached from S (by fetching from the instruction
indicated by the program counter in S and then executing
it), for some state of memory. Then, properties (i) and
(ii) hold if C (Si,Si+1,Â·) is satisï¬able for i = 1, . . . ,T âˆ’ 1.
Thus, C contains T âˆ’ 1 copies of C , each wired to a pair
of adjacent states in tr.
The third property is veriï¬ed via nondeterministic rout-
ing. Assume that C also gets as input MemSort(tr), which
equals to the sorting of tr by accessed memory addresses
(breaking ties via timestamps), and write a circuit Cmem so
that validity of memory accesses holds if Cmem is satisï¬ed
by each pair of adjacent states in MemSort(tr). (Roughly,
Cmem checks consistency of â€œload-after-loadâ€, â€œload-after-
storeâ€, and so on.) However, C merely gets some auxiliary
input trâˆ—, which purports to be MemSort(tr). So C works
as follows: (a) C has T âˆ’ 1 copies of Cmem, each wired to
a pair of adjacent states in trâˆ—; (b) C separately veriï¬es
that trâˆ— = MemSort(tr) by routing on a O(T logT )-node
BeneË‡s network. The switches of the routing network are
set according to non-deterministic guesses (i.e., additional
values in the auxiliary input), and the routing network
merely veriï¬es that the switch settings induce a permu-

tation; this allows for a very tight reduction. (Known
constructions that compute the correct permutation hide
large constants in big-oh notation [1].)
Past inefï¬ciencies. After ï¬lling in additional details,
the construction of [16] reviewed above gives a circuit

of size Î˜(cid:31)(n + T ) Â· (log(n + T ) + (cid:29))(cid:30) = â„¦((cid:29) Â· T ). The
â„¦((cid:29)Â· T ) arises from the fact that all of the (cid:29) instructions
are hardcoded into each of the T âˆ’ 1 copies of C .
in
Thus, besides being non-universal, the circuit scales inef-
ï¬ciently as (cid:29) grows (e.g., for (cid:29) = 104, C â€™s size is already
dominated by â€™s size).

3.2 Our construction
In comparison to [16], our circuit generator is universal
and, moreover, its size only grows with (cid:29) + T (additive
dependence on program size) instead of with (cid:29)Â· T (mul-
tiplicative dependence). As our evaluation demonstrates
(see Section 5.1), the size improvement actually translates
into signiï¬cant savings in practice.

Instead of hardcoding the program into each copy
of the circuit C , we follow the von Neumann paradigm,
where the program lies in the same read/write memory
space as data. We ensure that
is loaded into the initial
state of memory, using a dedicated circuit; we then verify
instruction fetch via the same routing network that is used
for checking data loads/stores. While the idea is intuitive,
realizing it involves numerous technical difï¬culties, some
of which are described below.
Routing instructions and data. We extend an execution
trace to not only include CPU states but also instructions:
tr = (S1,I1, . . . ,S T ,IT ) where Si is the i-th CPU state, and
Ii is the i-th executed instruction. We seek an arithmetic
circuit C that checks tr, in this â€œextendedâ€ format, for the
same three properties as above: (i) validity of instruction
fetch; (ii) validity of instruction execution; (iii) validity of
memory accesses.

As in [16], checking that tr satisï¬es property (ii)
is quite straightforward. Construct a circuit Cexe so
that, given two CPU states S,S(cid:31) and an instruction I,
Cexe(S,S(cid:31),I,g) is satisï¬ed, for some guess g, if and only
if S(cid:31) can be reached from S, by executing I, for some state
of memory. Then, C contains T âˆ’ 1 copies of Cexe, each
wired to adjacent CPU states and an instruction, i.e., the
i-th copy is Cexe(Si,Si+1,Ii,gi).

Unlike [16], though, we verify properties (i) and (iii)
jointly, via the same routing network. The auxiliary input
now contains trâˆ— = (A1, . . . ,A 2T ), purportedly equal to the
memory-sorted list of both instructions fetches and CPU
states. (Since the program lies in the same read-write
memory as data, an instruction fetch from is merely
a special type of memory load.) Thus, to check that tr
satisï¬es properties (i) and (iii), we design C to (a) verify
that trâˆ— = MemSort(tr) via nondeterministic routing, and

USENIX Association  

23rd USENIX Security Symposium  787

7

(b) verify validity of all (i.e., instruction and data) memory
accesses, via a new circuit C(cid:31)mem applied to each pair of
adjacent items Ai,Ai+1 in trâˆ—. Thus, in this approach,
is never replicated T times; rather, the fetching of its
instructions is veriï¬ed together with all other memory
accesses, one instruction fetch at a time.
Multiple memory-access types. Each copy of C(cid:31)mem
inspects a pair of items in trâˆ— and (assuming trâˆ— =
MemSort(tr)) must ensure consistency of â€œload-after-
loadâ€, â€œload-after-storeâ€, and so on. However, unlike
in [16], the byte-addressable memory of vnTinyRAM
is accessed in different-sized blocks:
instruction-size
blocks for instruction fetch; word-size blocks when
loading/storing words; and byte-size blocks when load-
ing/storing bytes. The consistency checks in C(cid:31)mem must
handle â€œaliasingâ€, i.e., accesses to the same point in mem-
ory via different addresses and block sizes.

We tackle this difï¬culty as follows. Double-word
blocks are the largest blocks in which memory is ac-
cessed (as instructions are encoded as double words; cf.
Section 2.5). We thus let each item in trâˆ— always specify
a double-word, even if the itemâ€™s memory access was
with respect to a smaller-sized block (e.g., word or byte).
With this modiï¬cation, we can let C(cid:31)mem perform consis-
tency checks â€œat the double-word levelâ€, and handling
word/byte accesses by mapping them to double-word ac-
cesses with suitable shifting and masking.
Booting the machine. We have so far assumed that
the program , given as input to C, already appears in
memory. However, the circuit C sketched so far only
veriï¬es the validity of tr with respect to a machine whose
memory is initialized to some state, corresponding to the
execution of some program. But C must verify correct
, and so it must also verify
execution of, speciï¬cally,
. Since C does
that memory is initialized to contain
not explicitly maintain memory (not even the initial one)
and only implicitly reasons about memory via the routing
network, it is not clear how C can perform this check.

We tackle this difï¬culty as follows. We further modify
the the execution trace tr, by extending it with an initial
boot section, preceding the beginning of the computation,
during which the input program is stored into mem-
ory, one instruction i at a time. This extends the length
of both tr and trâˆ— from 2T to (cid:30) + 2T , for (cid:30)-instruction
programs, and introduces a new type of item, â€œboot in-
put storeâ€, in trâˆ—. Similarly, the routing network is now
responsible for routing (cid:30) + 2T , rather than 2T , packets.
Further optimizations. The above construction sketch
(depicted in Figure 6) is only intuitive, and does not dis-
cuss other optimizations that ultimately yield the perfor-
mance that we report in Section 5.1.

For example, while [16] rely on BeneË‡s networks, we
rely on arbitrary-size Waksman networks [10], which

ğğ1 ğğğŸğŸ ğğâ„“ğ“ğ“ â‹® 
ğ‘†ğ‘†1 
ğ¼ğ¼1 
ğ‘†ğ‘†2 
ğ¼ğ¼2 
ğ‘†ğ‘†3 
â‹® 
ğ¼ğ¼ğ‘‡ 
ğ‘†ğ‘†ğ‘‡ 

routing 
network 

boot 

ğ¶ğ¶exe 
ğ¶ğ¶exe 
â‹® 
ğ¶ğ¶exe 

ğ¶ğ¶mem 
ğ¶ğ¶mem 
ğ¶ğ¶mem 
ğ¶ğ¶mem 
ğ¶ğ¶mem 
ğ¶ğ¶mem 
â‹® ğ¶ğ¶mem 
â‹® 
ğ¶ğ¶mem 
ğ¶ğ¶mem 

ğ´ğ´1 
ğ´ğ´2 
ğ´ğ´3 
ğ´ğ´4 
ğ´ğ´5 
ğ´ğ´6 
ğ´ğ´7 
ğ´ğ´8 
â‹® 
ğ´ğ´2T+â„“ğ“ğ“âˆ’1 
ğ´ğ´2T+â„“ğ“ğ“ 

only require N(logN âˆ’ 0.91) switches to route N packets,
instead of 2(cid:28)logN(cid:27)((cid:28)logN(cid:27)âˆ’ 0.5). Besides being closer
to the information-theoretic lower bound of N(logN âˆ’
1.443), such networks eliminate costly rounding effects
in [16], where the size of the network is doubled if N is
just above a power of 2.
Compiling to vnTinyRAM. To enable veriï¬cation of
higher-level programs, written in C, we ported the GCC
compiler to the vnTinyRAM architecture, by modifying
the Harvard-architecture, word-addressible TinyRAM C
compiler of [16]. Given a C program, written in the
same subset of C as in [16], the compiler produces the
initial memory map representing a program . This also
served to validate the vnTinyRAM architectural choices
(e.g., the move to byte-addressing signiï¬cantly, and added
instructions, improved efï¬ciency for many programs).

Figure 6: Outline of our universal circuit construction with the extended
trace tr on the left and (allegedly) its memory sort trâˆ— on the right.

4 Our zk-SNARK for circuits

We discuss our second main contribution:
a high-
performance implementation of a zk-SNARK for arith-
metic circuit satisï¬ability. Our approach is to tailor
the requisite mathematical algorithms to the speciï¬c
zk-SNARK protocol at hand. While our techniques can be
instantiated in many algebraic setups and security levels,
we demonstrate them in two speciï¬c settings, to facilitate
comparison with prior work.

See Section 2.4 for an informal deï¬nition of a
zk-SNARK for arithmetic circuit satisï¬ability. We im-
prove upon and implement the zk-SNARK of Parno et
al. [56]. For completeness the â€œPGHR protocolâ€ is sum-
marized in the full version of this paper, which provides
pseudocode for its key generator G, prover P, and veriï¬er
V . The construction is based on QAPs, introduced in
Section 2.2.

Like most other zk-SNARKs, the PGHR protocol relies
on a pairing, which is speciï¬ed by a prime r âˆˆ N, three

788  23rd USENIX Security Symposium 

USENIX Association

8

cyclic groups G1,G2,GT of order r, and a bilinear map
e: G1 Ã— G2 â†’ GT . (See Section 2.3.)
A pairing is typically instantiated via a pairing-friendly
elliptic curve. Concretely, suppose that one uses a curve
E deï¬ned over Fq, with embedding degree k with re-
spect to r, to instantiate the pairing. Then GT is set to
Âµr, the subgroup of r-th roots of unity in Fâˆ—qk. The in-
stantiation of G1 and G2 depends on the choice of e;
typically, G1 is instantiated as an order-r subgroup of
E(Fq), while, for efï¬ciency reasons [7, 8], G2 as an order-
r subgroup of E(cid:28)(Fk/d) where E(cid:28) is a d-th twist of E.
Finally, the pairing e is typically a two-stage function
e(P, Q) := FE(ML(P, Q)), where ML: G1Ã—G2 â†’ Fk
q
is known as Miller loop, and FE: Fk
q is known as
ï¬nal exponentiation and maps Î± to FE(Î±) := Î± (qkâˆ’1)/r.
As mentioned, we instantiate our techniques based on
two different curves: an Edwards curve for the 80-bit
security level (as in [16]) and a Barretoâ€“Naehrig curve for
the 128-bits security level (as in [56, 27]). We selected
both the Edwards curve and Barretoâ€“Naehrig curve so
that râˆ’ 1 has high 2-adic order (i.e., râˆ’ 1 is divisible by
a large power of 2), because this was shown to improve
the efï¬ciency of the key generator and the prover [16].

q â†’ Fk

4.1 An optimized veriï¬er
The veriï¬er V takes as input a veriï¬cation key vk, input
(cid:29)x âˆˆ Fn
r , and proof Ï€, and checks if Ï€ is a valid proof for
the statement â€œ(cid:29)x âˆˆ LCâ€. The computation of V consists
of two parts. First, use vkIC,0, . . . ,vk IC,n âˆˆ G1 (part of
vk) and input (cid:29)x to compute vk(cid:29)x := vkIC,0 + âˆ‘n
i=1 xivkIC,i.
Second, use vk, vk(cid:29)x, and Ï€, to compute 12 pairings and
perform the required checks. In other words, V performs
O(n) scalar multiplications in G1, followed by O(1) pair-
ing evaluations.

With regard to V â€™s ï¬rst part, variable-base multi-scalar
multiplication techniques can be used to reduce the num-
ber of G1 operations needed to compute vk(cid:29)x [16, 56].
With regard to V â€™s second part, even if the pairing evalu-
ations take constant time (independent of the input size
n), these evaluations are very expensive and dominate for
small n. Our focus here is to minimize the cost of these
pairing evaluations.

When only making â€œblack-boxâ€ use of a pairing, the
veriï¬er must evaluate 12 pairings, amounting to 12 Miller
loops plus 12 ï¬nal exponentiations. The straightfor-
ward approach is to compute these using a generic high-
performance pairing library. We proceed differently:
we obtain high-performance implementations of sub-
components of a pairing, and then tailor their use speciï¬-
cally to V â€™s protocol.

Namely, ï¬rst, we obtain state-of-the-art implementa-
tions of a Miller loop and ï¬nal exponentiation. We utilize
optimal pairings [70] to minimize the number of loop

iterations in each Miller loop, and, to efï¬ciently eval-
uate each Miller loop, rely on the formulas of [3] (for
Edwards curves) and [20] (for BN curves). As for ï¬nal
exponentiation, we use multiple techniques to speed it
up: [62, 44, 35, 50].

Next, building on the above foundation, we incorporate

in V the following optimizations.
(1) Sharing Miller loops and ï¬nal exponentiations.
The veriï¬er V computes two products of two pairings.
We leverage the fact that a product of pairings can be
evaluated faster than evaluating each pairing separately
and then multiplying the results [60]. Concretely, in a
product of m pairings, the Miller loop iterations for evalu-
ating each factor can be carried out in â€œlock-stepâ€ so to
share a single Miller accumulator variable, using one Fqk
squaring per loop instead of m.

In a similar vein, one can perform a single ï¬nal expo-
nentiation on the product of the outputs of the m Miller
loops, instead of m ï¬nal exponentiations and then multi-
plying the results. In fact, since the output of the pairing
can be inverted for free (as the element is unitary so that
inverting equals conjugating [61]), the idea of â€œsharingâ€
ï¬nal exponentiations extends to a ratio of pairing products.
Thus, in the veriï¬er we only need to perform 5, instead of
12, ï¬nal exponentiations.

Our implementation incorporates both of the above
techniques. For example, at the 80-bit security level,
separately computing 12 optimal pairings costs 13.6ms,
but the above techniques reduce the time to only 8.1ms.
We decrease this further as discussed next.
(2) Precomputation by processing the veriï¬cation key.
Of the 12 pairings the veriï¬er needs to evaluate, only one
is such that both of its inputs come from the proof Ï€. The
other 11 pairings have one ï¬xed input, either a generator
of G1 or G2, or coming from the veriï¬cation key vk.

When one input to a pairing is ï¬xed, precomputation
techniques apply [60], especially in the case when the
ï¬xed input is the base point in Millerâ€™s algorithm. In V ,
this holds for 9 out of the 11 pairing evaluations. We
thus split the veriï¬erâ€™s computation into an ofï¬‚ine phase,
which consists of a one-time precomputation that only
depends on vk, and a many-time online phase, which
depends on the precomputed values, input (cid:29)x, and proof Ï€.
The result of the ofï¬‚ine phase is a processed veriï¬cation
key vkâˆ—. While vkâˆ— is longer than vk, it allows the online
phase to be faster.

E.g., at the 80-bit security level, vkâˆ— decreases the total

cost of pairing checks from 8.1ms to 4.7ms.

4.2 An optimized prover
The prover P takes as input a proving key pk (which in-
cludes the circuit C : Fn
r , and
witness (cid:29)a âˆˆ Fr. The prover P is tasked to produce a proof

r), input (cid:29)x âˆˆ Fn

r â†’ Fl

r Ã— Fh

USENIX Association  

23rd USENIX Security Symposium  789

9

Ï€, attesting that (cid:31)x âˆˆ LC. The computation of P con-
sists of two main parts. First, compute the coefï¬cients(cid:31)h
of the polynomial H(z) := A(z)B(z)âˆ’C(z)
, where A,B,C âˆˆ
Fr[z] are derived from the QAP instance ((cid:31)A,(cid:31)B, (cid:31)C,Z) :=
QAPinst(C) and QAP witness(cid:31)s := QAPwit(C,(cid:31)x,(cid:31)a). Sec-
ond, use the coefï¬cients(cid:31)h, QAP witness (cid:31)s, and public key
pk to compute Ï€.

Z(z)

With regard to the ï¬rst part of P, the coefï¬cients (cid:31)h
can be efï¬ciently computed via FFT techniques [16, 56];
our implementation follows [16], and leverages the high
2-adic order of r âˆ’ 1 for both of the elliptic curves we
use. With regard to Pâ€™s second part, computing Ï€ requires
solving large instances of the following problem: given
elements Q1, . . . ,Q n all in G1 (or all in G2) and scalars
Î±1, . . . ,Î± n âˆˆ Fr, compute (cid:29)(cid:31)Î±, (cid:31)Q(cid:28) := Î±1Q1 +Â·Â·Â· + Î±nQn.
Previous work [56, 16] has leveraged generic multi-scalar
multiplication to compute Ï€. We observe that these algo-
rithms can be tailored to the speciï¬c scalar distributions
In P, the vector (cid:31)Î± is one of two types:
arising in P.
(i) (cid:31)Î± âˆˆ Fd+1
and represents the coefï¬cients of the degree-
d polynomial H; or (ii) (cid:31)Î± = (1â—¦(cid:31)sâ—¦ Î´1 â—¦ Î´2 â—¦ Î´3) âˆˆ F4+m
,
for random Î´1,Î´2,Î´3 âˆˆ Fr.
In case i, the entries in of (cid:31)Î± are random-looking. We
use the Bosâ€“Coster algorithm [26] due to its lesser mem-
ory requirements (as compared to, e.g., [57]). We follow
[19]â€™s suggestions and achieve an assembly-optimized
heap to implement the Bosâ€“Coster algorithm.

r

r

In case ii, the entries in (cid:31)s depend on the input (C,(cid:31)x,(cid:31)a)
to QAPwit; in turn, (C,(cid:31)x,(cid:31)a) depends on our circuit gen-
erator (Section 3). Using the above algorithm â€œas isâ€ is
inefï¬cient: the algorithm works well when all the scalars
have roughly the same bit complexity, but the entries in
(cid:31)c have very different bit complexity. Indeed, (cid:31)Î± equals to
(cid:31)s augmented with a few entries; and (cid:31)s, the QAP witness,
can be thought of as the list of wire values in C when
computing on ((cid:31)x,(cid:31)a); the bit complexity of a wire value
depends on whether it is storing a boolean value, a word
value, and so on. We observe that there are only a few
â€œtypesâ€ of values, so that the entries of (cid:31)Î± can be clustered
into few groups of scalars with approximately the same
bit complexity; we then apply the algorithm of [26] to
each such group.

4.3 An optimized key generator
The key generator G takes as input a circuit C : Fn
r â†’
Fl
r, and is tasked to compute a proving key pk and a
veriï¬cation key vk. The computation of G consists of
two main parts. First, evaluate each Ai,Bi,Ci at a random
element Ï„, where ((cid:31)A,(cid:31)B, (cid:31)C,Z) := QAPinst(C) is the QAP
instance. Second, use these evaluations to compute pk
and vk.

r Ã—Fh

With regard to Gâ€™s ï¬rst part, we follow [16] and again
leverage the fact that Fr has a primitive root of unity of

large order. With regard to Gâ€™s second part, it is dominated
by the cost of computing pk, which requires solving large
instances of the following problem: given an element
P in G1 or G2 and scalars Î±1, . . . ,Î± n âˆˆ Fr, compute
Î±1P, . . . ,Î± nP. Previous work [56, 16], used ï¬xed-base
windowing [28] to efï¬ciently compute such ï¬xed-base
multi-scalar multiplications.

In our implementation, we achieve additional efï¬ciency,
in space rather than in time. Speciï¬cally, we leverage
a structural property of QAPs derived from arithmetic
circuits, in order to reduce the size of the proving key
pk, as we now explain. Lemma 2.4 states that an F-
arithmetic circuit C : Fn Ã— Fh â†’ Fl, with Î± wires and
Î² gates, can be converted into a corresponding QAP of
size m = Î± and degree d â‰ˆ Î² over F. Roughly, this is
achieved in two steps. First, construct three matrices
A,B,C âˆˆ F(m+1)Ã—d that encode Câ€™s topology: for each
j âˆˆ [d], the j-th column of A,B respectively encodes the
â€œleftâ€ and â€œrightâ€ coefï¬cients of the j-th bilinear gate in
C, while the j-th column of C encodes the coefï¬cients of
the gateâ€™s output. Second, letting S âŠ‚ F be a set of size
d, deï¬ne Z(z) := âˆÏ‰âˆˆS(z âˆ’ Ï‰) and, for i âˆˆ {0, . . . ,m},
let Ai be the low-degree extension of the i-th row of A;
similarly deï¬ne each Bi and Ci. All prior QAP-based
zk-SNARK implementations exploit the fact that columns
in the matrices A,B,C are very sparse.

In contrast, we also leverage a different kind of spar-
sity: we observe that it is common for entire rows of
A,B,C to be all zeroes, causing the corresponding low-
degree extensions to be zero polynomials.3 For instance,
our circuit generator typically outputs a circuit for which
the percentage of non-zero polynomials in (cid:31)A,(cid:31)B, (cid:31)C is only
about 52%,15%,71% respectively. The fact that many
polynomials in (cid:31)A,(cid:31)B, (cid:31)C evaluate to zero can be used to-
wards reducing the size of pk, by switching from a dense
representation to a sparse one.

In fact, we have engineered our circuit generator to re-
duce the number of non-zero polynomials in (cid:31)B as much as
possible, because computations associated to evaluations
of (cid:31)B are conducted with respect to more expensive G2
arithmetic, which we want to avoid as much as possible.

5 Evaluation
We evaluated our system on a desktop computer with
a 3.40 GHz Intel Core i7-4770 CPU (with Turbo Boost
disabled) and 32 GB of RAM. All experiments, except the
largest in Figure 8 and 9, used a small fraction of the RAM.
For the two largest experiments in Figure 9 we added a
Crucial M4 solid state disk for swap space. (While our
code supports multi-threading, our experiments are in
single-thread mode, for comparison with prior work.)

3E.g., if the i-th wire never appears with a non-zero coefï¬cient as

the â€œleftâ€ input of a bilinear gate, then the i-th row of A is zero.

790  23rd USENIX Security Symposium 

USENIX Association

10

5.1 Performance of our circuit generator
In Section 3 we described our universal circuit generator;
we now benchmark its performance.
Parameters. The circuit supports vnTinyRAM, which
is parametrized by two quantities: the word size W and
the number of registers K (see Section 2.5). We report
performance for a machine with K = 16 registers, and
two choices of word size: W = 16 and W = 32.
Methodology. Theorem 3.2 provides an asymptotic ef-
ï¬ciency guarantee: it states that our circuit generator has

efï¬ciency f ((cid:31),n,T ) = O(cid:31)((cid:31) +n +T )Â·log((cid:31) +n +T )(cid:30). To

understand concrete efï¬ciency, we â€œuncoverâ€ the con-
stants hidden in the big-oh notation. By studying the num-
ber of gates in various subcircuits of the generated circuit
C := circ((cid:31),n,T ), we computed the following (quite tight)
upper bound on Câ€™s size:

4logH âˆ’ 1.82)Â· H

(12 + 2W )Â· (cid:31) + (12 +W )Â· n +|Cexe|Â·T + (|Cmem| +
where H := ((cid:31) + n + 2T ) is the â€œheightâ€ of the routing
network, and
â€¢ for (W,K) = (16,16): |Cexe| = 777 and |Cmem| = 211;
â€¢ for (W,K) = (32,16): |Cexe| = 1114 and |Cmem| = 355.
In Figure 7, we give per-cycle gate counts (i.e., |C|/|T|)
for various choices of ((cid:31),n,T ); we also give sub-counts
divided among program/input boot, CPU execution, mem-
ory checking, and routing. (See the full version of this
paper for an extended table with additional data.)
Discussion. We ï¬rst go through the size expression, to
understand it: The ï¬rst two terms, (12 + 2W )Â· (cid:31) + (12 +
W )Â·n, correspond to the pre-execution boot phase, during
which an (cid:31)-instruction program and an n-word primary
input are loaded into the machine. The term |Cexe| Â· T
corresponds to the T copies of Cexe used to verify each
CPU transition, given the fetched instruction and two CPU
states. The term |Cmem|Â· H corresponds to the H copies
of Cmem used to verify consistency on the memory-sorted
trace. Finally, the term (4logH âˆ’1.82)Â·H corresponds to
the routing network for routing H packets (two gates for
each of (2logH âˆ’ 0.91)Â· H binary switches). Note that
H = ((cid:31) +n +2T ) because boot needs (cid:31) +n memory stores
(one for each program instruction and primary input word)
and execution needs 2T memory accesses (1 instruction
fetch and 1 data store/load per execution cycle).

The gate counts in Figure 7 demonstrate the additive
(instead of multiplicative) dependence on program size of
our universal circuit pays off. For example, for (W,K) =
(32,16), a 100-fold increase in program size, from (cid:31) =
103 to (cid:31) = 105, barely impacts the per-cycle gate count:
for T = 220, it increases from 1,992.5 to only 2,041.5.
Indeed, the cost of program size is incurred, once and
for all, during the machine boot; Figure 7 shows that the
per-cycle cost of machine boot diminishes as T grows.

Second, less than half of Câ€™s gates are dedicated to
verifying accesses to random-access memory, while the
majority of gates are dedicated to verifying execution
of the CPU; indeed, almost always, |Cexe|T > 1
2|C|. Put
otherwise, C, which veriï¬es an automaton with random-
access memory (vnTinyRAM), has size that is less than
twice that for verifying an automaton with the same CPU
but no random-access memory at all. Moreover, note that
the size of Cexe appears quite tight: for example, with
(W,K) = (32,16), it has size 1114, not much larger than
the size of the CPU state (545 bits).
5.2 Performance of our zk-SNARK for cir-

cuit satisï¬ability

r Ã— Fh

r â†’ Fl

r , and witness (cid:26)a âˆˆ Fh

In Section 4 we described our zk-SNARK implementa-
tion; we now benchmark its performance.
Methodology. We provide performance characteristics
for each of the zk-SNARK algorithms, G, P and V , at the
80-bit and 128-bit security levels.
(1) The key generator G takes as input an arithmetic cir-
cuit C : Fn
r. Its efï¬ciency mostly depends on
the number of gates and wires in C, because these af-
fect the size and degree of the corresponding QAP (see
Lemma 2.4). Thus, we evaluate G on a circuit with
2i gates and 2i wires for i âˆˆ {10,12, . . . ,24} (and ï¬xed
n = h = l = 100). In Figure 8 we report the resulting
running times and key sizes, as per-gate costs.
(2) The prover P takes as input a proving key pk, input
(cid:26)x âˆˆ Fn
r . Its efï¬ciency mostly depends
on the number of gates and wires in C (the circuit used
to generate pk); we thus evaluate P on the proving keys
output by G, for the same circuits as above. In Figure 8
we report the times, as per-gate costs, and proof sizes.
(3) The veriï¬er V takes as input a veriï¬cation key vk,
input (cid:26)x âˆˆ Fn
r , and proof Ï€. Its efï¬ciency depends only on
(cid:26)x (since the size of (cid:26)x determines that of vk). Thus, we
evaluate V on a random input (cid:26)x âˆˆ Fn
r of 2i bytes for i âˆˆ
{2,4, . . . ,20}. In Figure 8 we report the resulting running
times, along with corresponding key sizes.
Discussion. The data demonstrates that our zk-SNARK
implementation works and scales as expected, as long as
sufï¬cient memory is available (e.g., on a desktop com-
puter with 32GB of DRAM: up to 16 million gates). Key
generation takes about 10ms per gate of C; the size of a
proving key is about 300B per gate, and the size of a ver-
iï¬cation key is about 1B per byte of input to C. Running
the prover takes 11ms to 14ms per gate. For an n-byte
input, proof veriï¬cation time is c1n + c0, where c0 is a
few milliseconds and c1 is a few tenths of microseconds.
5.3 Performance of the combined system
As discussed, our circuit generator (Section 3) and
zk-SNARK for circuits (Section 4) can be used in-

USENIX Association  

23rd USENIX Security Symposium  791

11

Per-cycle gate count of C := circ((cid:31),n,T ) with vnTinyRAM parameters (W,K)

n = 102, K = 16

|C|/T
1,367.4
1,399.0
1,431.0
1,370.3
1,399.2
1,431.0
1,399.7
1,401.1
1,431.1

boot
0.04
0.00
0.00
0.41
0.03
0.00
4.12
0.26
0.02

W = 16
|C|/T divided among
exec.
777.0
777.0
777.0
777.0
777.0
777.0
777.0
777.0
777.0

mem.
422.2
422.0
422.0
424.0
422.1
422.0
442.1
423.3
422.1

routing
168.1
200.0
232.0
168.8
200.1
232.0
176.4
200.6
232.0

Per
cycle
1,992.5
2,024.0
2,056.0
1,997.0
2,024.3
2,056.0
2,041.5
2,027.2
2,056.2

W = 32
|C|/T divided among
exec.
1,114.0
1,114.0
1,114.0
1,114.0
1,114.0
1,114.0
1,114.0
1,114.0
1,114.0

mem.
710.4
710.0
710.0
713.4
710.2
710.0
743.9
712.1
710.1

routing
168.1
200.0
232.0
168.8
200.1
232.0
176.4
200.6
232.0

boot
0.08
0.00
0.00
0.72
0.05
0.00
7.19
0.45
0.03

0
1
=
(cid:31)

3 T = 220
T = 224
T = 228
4 T = 220
T = 224
T = 228
5 T = 220
T = 224
T = 228

0
1
=
(cid:31)

0
1
=
(cid:31)

Figure 7: Per-cycle gate counts in C := circ((cid:31),n,T ) for different choices of ((cid:31),n,T ) and vnTinyRAM parameters (W,K).

80 bits of security

128 bits of security

time/|C|
0.21ms
0.16ms
0.14ms
0.12ms
0.11ms
0.10ms
0.09ms
0.08ms

|pk|/|C|
248.8B
252.5B
253.4B
253.7B
253.7B
253.7B
253.7B
253.7B

time/|C|
0.21ms
0.17ms
0.16ms
0.14ms
0.12ms
0.12ms
0.11ms
0.10ms

|pk|/|C|
304.1B
309.1B
310.3B
310.6B
310.7B
310.7B
310.7B
310.7B

2.8KB

3.6KB

time/|C|
0.18ms
0.16ms
0.14ms
0.13ms
0.12ms
0.12ms
0.11ms
0.11ms

|vk|/|(cid:27)x|
118.7B
29.7B
8.1B
2.8B
1.5B
1.1B
1.1B
1.0B
1.0B
1.0B

|Ï€|
230B
230B
230B
230B
230B
230B
230B
230B

time/|(cid:27)x|
1.2ms
0.3ms
76.7 Âµs
19.5 Âµs
5.4 Âµs
1.8 Âµs
0.8 Âµs
0.5 Âµs
0.4 Âµs
0.4 Âµs

time/|C|
0.21ms
0.18ms
0.16ms
0.15ms
0.15ms
0.15ms
0.14ms
0.14ms

|vk|/|(cid:27)x|
123.4B
30.8B
8.7B
2.9B
1.5B
1.1B
1.0B
1.0B
1.0B
1.0B

|Ï€|
288B
288B
288B
288B
288B
288B
288B
288B

time/|(cid:27)x|
1.2ms
0.3ms
81.2 Âµs
20.3 Âµs
5.9 Âµs
2.1 Âµs
1.0 Âµs
0.7 Âµs
0.6 Âµs
0.5 Âµs

0
0
1
=
n

0
0
1
=
n

key gen. G
|C| = 210
|C| = 212
|C| = 214
|C| = 216
|C| = 218
|C| = 220
|C| = 222
|C| = 224
|vk|
prover P
|C| = 210
|C| = 212
|C| = 214
|C| = 216
|C| = 218
|C| = 220
|C| = 222
|C| = 224

veriï¬er V

|(cid:27)x| = 4B
|(cid:27)x| = 16B
|(cid:27)x| = 64B
|(cid:27)x| = 256B
|(cid:27)x| = 1.0KB
|(cid:27)x| = 4.1KB
|(cid:27)x| = 16.4KB
|(cid:27)x| = 65.5KB
|(cid:27)x| = 262.1KB
|(cid:27)x| = 1.0MB

Figure 8: Per-gate costs of the key generator and prover; and per-byte
costs of the veriï¬er. (N = 10 and std < 1%)

dependently, or combined to obtain a zk-SNARK for
vnTinyRAM. For completeness, the paperâ€™s full version
we spell out how these two components can be combined.
Here we report measured performance of this combined
system, at the 128-bit security level, and for a word size
W = 32 and number of registers K = 16.
Methodology. A zk-SNARK for vnTinyRAM is a triple
of algorithms (KeyGen, Prove, Verify). Given bounds
(cid:31),n,T (for program size, input size, and time), the ef-
ï¬ciency of KeyGen and Prove depends on (cid:31),n,T , while

that of Verify essentially depends only on (cid:31),n. Thus, we
benchmark the system as follows. We evaluate KeyGen
and Prove for various choices of (cid:31) and T , while keeping
n = 100. Instead, since the efï¬ciency of Verify does not
depend on T , we evaluate Verify, for various choices of (cid:31)
and n, on random (cid:31)-instruction programs and n-word in-
puts. In Figure 9, we report the following measurements:
KeyGenâ€™s running time, the sizes of the keys pk and vk,
Proveâ€™s runtime, the (constant) proof size, and Verifyâ€™s
running time. For quantities growing with T , we divide
by T and report the per-cycle cost.
Discussion. The measurements demonstrate that, on
a desktop computer, our zk-SNARK for vnTinyRAM
scales up to computations of 32,000 machine cycles, for
programs with up to 10,000 instructions. Key generation
takes about 200ms per cycle; the size of a proving key is
500KB to 650KB per cycle, and the size of a veriï¬cation
key is a few kilobytes. Running the prover takes 100ms
to 200ms per cycle. Veriï¬cation times remain a few ms ,
even for inputs and programs of several kilobytes.
Program-speciï¬c vk. The time complexity of Verify is
O((cid:31) + n), so veriï¬cation time grows with program size.
This is inevitable, because Verify must read a program
(of at most (cid:31) instructions) and input
(of at most n words)
in order to check, via the given proof Ï€, if ( , ) âˆˆ L(cid:31),n,T
(cf. Deï¬nition 2.6). However, this is inconvenient, e.g.,
when one has to verify many proofs relative to different
inputs to the same program . In our zk-SNARK it is
possible to amortize this cost as follows. Given vk and ,
one can derive, in time O((cid:31)), aprogram-speciï¬c veriï¬ca-
tion key vk , which can be used to verify proofs relative
to any input to . Subsequently, the time complexity of
Verify for any input
5.4 Comparison with prior work
5.4.1 Comparison with prior circuit generators
Universality is the main innovative feature of our circuit
generator. No previous circuit generator achieves univer-

(to ) is O(n), independent of (cid:31).

792  23rd USENIX Security Symposium 

USENIX Association

12

T
/
e
m
i
n t
e
G
y
e
K

T
/
|
k
p
|

|
k
v
|

T
/
e
m

i
t

e
m

i
t

e
v
o
r
P

y
f
i
r
e
V

0
0
1
=
n

T = 4K
T = 8K
T = 16K
T = 32K
T = 4K
T = 8K
T = 16K
T = 32K
T = âˆ—
0 T = 4K
T = 8K
T = 16K
T = 32K

0
1
=
n

T
f
o

) n = 0
n = 10
n = 102
n = 103
n = 104

.
p
e
d
n
i
(

128 bits of security
W = 32, K = 16

(cid:31) = 2K
209.8ms
190.9ms
195.4ms
206.0ms
584.2KB
552.4KB
539.4KB
533.8KB
17.0KB
75.7ms
69.2ms
89.0ms
98.9ms
19.0ms
19.1ms
19.6ms
23.0ms
48.9ms

(cid:31) = 4K
232.1ms
205.9ms
198.1ms
208.4ms
653.6KB
585.2KB
553.9KB
541.1KB
33.1KB
86.7ms
79.7ms
89.1ms
98.6ms
30.0ms
30.2ms
30.7ms
34.1ms
60.0ms

(cid:31) = 6K
257.5ms
216.1ms
204.2ms
211.2ms
727.1KB
618.1KB
570.4KB
548.3KB
49.2KB
103.4ms
97.0ms
98.4ms
102.3ms
40.6ms
40.7ms
41.3ms
44.7ms
70.6ms

(cid:31) = 8K
275.9ms
228.9ms
213.6ms
213.5ms
784.0KB
655.1KB
586.9KB
555.6KB
65.3KB
104.8ms
110.4ms
99.6ms
102.1ms
51.2ms
51.2ms
51.8ms
55.2ms
81.1ms

(cid:31) = 10K
306.4ms
238.8ms
218.3ms
223.7ms
876.8KB
683.7KB
605.5KB
563.4KB
81.5KB
133.7ms
113.0ms
103.3ms
114.2ms
61.3ms
61.4ms
61.9ms
65.4ms
91.3ms

Figure 9: Per-cycle costs of KeyGen and Prove for various program sizes (cid:31), and total running time of Verify for various (cid:31) and n.

sality. (See Figure 1 and Section 3.)

Putting universality aside and focusing on efï¬ciency
instead, a comparison with previous circuit generators is a
multi-faceted problem. On one hand, due to a shared core
of techniques, a comparison with [16]â€™s circuit generator
is straightforward, and shows signiï¬cant improvements
in circuit size, especially as program size grows. See
Section 1.4.1 and Figure 2 (the ï¬gure is for W,K = 16).
Instead, a comparison with other circuit generators
[66, 64, 56, 27] is complex. First, they support a smaller
class of programs (see Figure 1), so a programmer must
â€œwrite aroundâ€ the limited functionality, somehow. And
second, their efï¬ciency is not easily speciï¬ed: due to the
program-analysis techniques (see Section 3.1) the output
circuit is ad hoc for the given program, and the only way
to know its size is to actually run the circuit generator.

Compared to [66, 64, 56, 27], our circuit generator
performs better for programs that are rich in memory
accesses and control ï¬‚ow, and worse for programs that
are more â€œcircuit likeâ€.
Comparison with [66, 64, 56]. The circuit generators
in [66, 64, 56] restrict loop iteration bounds and memory
accesses to be known at compile time; if a program does
not respect these restrictions, it must be ï¬rst somehow
mapped to another one that does. For simplicity, we take
[56]â€™s circuit generator (the latest one) as representative
and, to illustrate the differences between [56]â€™s and our
circuit generator, we consider two â€œextremesâ€.

On one extreme, we wrote a simple C program multi-
plying two 10Ã—10 matrices of 16-bit integers. The circuit
generator in [56] produces a circuit with 1100 gates; in-
stead, our circuit generator (when given the corresponding
vnTinyRAM assembly) produces a much larger circuit:
one with â‰ˆ 107 gates.
On the other extreme, we consider a program mak-
ing many random accesses to memory: pointer-chasing.

Given a permutation Ï€ of [N], start position i âˆˆ [N], and
an integer k, the program outputs Ï€k(i), the element ob-
tained by starting from i and following â€œpointersâ€ for k
times. Since no information about Ï€ is known at com-
pile time, the only way of obtaining Ï€( j), the pointer to
follow, in [56] is via a linear scan. On a simple C pro-
gram that does one linear scan of Ï€ to obtain each new
pointer, [56]â€™s generator outputs a circuit with 2Nk + 1
gates (each of the k array accesses costs 2N gates).

20N

and

In vnTinyRAM, the corresponding program consists
to it is N + 3 words.
of 9 instructions, and the input
Booting vnTinyRAM with
requires 9 + N + 3
â€œboot storesâ€ (see Section 3.2), and takes 5 + 4k cycles
to execute (independent of N). Say that we ï¬x k = 10;
then, in our circuit generator (with W = 32 and K = 16),
each cycle costs about 2000 gates, and can perform a
random access to memory. Thus, pointer chasing in our
case is cheaper than in [56] already for N > 5000, and the
2000Â·(5+40) = N
multiplicative saving, which is about
4500,
grows unbounded as N increases.
Comparison with [27]. The circuit generator of [27] is
also based on program analysis, but provides an additional
feature that allows data-dependent memory accesses: a
program may access memory by guessing the value and
verifying its validity via a subcircuit that checks Merkle-
tree authentication paths. In [27], memory consists of
230 cells, and each access costs many gates: 140K for a
load, and 280K for a store. In comparison, in our circuit
generator for vnTinyRAM (with word size W = 32 so
that memory has 232 cells), each memory store/load costs
less than 1000 gates out of about 2000 per cycle (see
Section 5.1). Besides the aforementioned feature, [27]
rely on program analysis, and (as in [66, 64, 56]) only
support bounded control ï¬‚ow. Thus, [27] performs better
than our circuit generator for programs with bounded
control ï¬‚ow and few data-dependent accesses to memory.

USENIX Association  

23rd USENIX Security Symposium  793

13

5.4.2 Comparison with prior zk-SNARKs
Addressing the other component of our system, the
zk-SNARK for circuits: Figure 3 compares our imple-
mentation with prior ones, on a 1-million-gate circuit
with a 1000-byte input. As shown, we mildly improve the
key generation time and, more importantly, signiï¬cantly
improve the â€œonlineâ€ costs of proving and veriï¬cation.

6 Conclusion
We have presented two main contributions: (i) a circuit
generator for a von Neumann RISC architecture that is
universal and scales additively with program size; and
(ii) a high-performance zk-SNARK for arithmetic circuit
satisï¬ability. These two components can be used inde-
pendently to the beneï¬t of other systems, or combined
into a zk-SNARK that can prove/verify correctness of
computations on this architecture.
The beneï¬ts of universality. Universality attains the
conceptual advance of once-and-for-all key generation,
allowing verifying all programs up to a given size. This
removes major issues in prior systems: expensive per-
program key generation and the thorny issue of conduct-
ing it anew in a trusted way for every program.
The price of universality. The price of universality is
still very high. Going forward, and aiming for widespread
use in security applications, more work is required to
slash costs of key generation and proving so to scale up to
larger computations: e.g., billion-gate circuits, or millions
of vnTinyRAM cycles, and beyond. An interesting open
problem is whether the â€œprogram analysisâ€ techniques
underlying most prior circuit generators [66, 64, 56, 27],
typically more efï¬cient for restricted classes of programs,
can be used to construct universal circuits.
Beyond vnTinyRAM. Finally, going beyond the foun-
dation of a von Neumann RISC architecture, more work
lies ahead towards a richer architecture (e.g., efï¬cient
support for ï¬‚oating-point arithmetic and cryptographic
acceleration), code libraries, and tighter compilers.

A Other prior work
Prior work most relevant to us is about zk-SNARKs, and
is discussed in Section 1.2. There are also numerous
works studying variations or relaxations of the goal we
consider; here, we summarize some of them.
Interactive proofs for low-depth circuits. Goldwasser
et al. [42] obtained an interactive proof for outsourc-
ing computations of low-depth circuits. A set of works
[32, 68, 67] has optimized and implemented the proto-
col of [42]. The protocol of [42] can also be reduced
to a two-message argument system [48, 47]. Canetti et
al. [30] showed how to extend the techniques in [42] to
also handle non-uniform circuits.

Batching arguments.
Ishai et al. [46] constructed a
batching argument for NP, where, to simultaneously ver-
ify that N circuits of size S are satisï¬able, the veriï¬er runs
in time max{S2,N}.
A set of works [63, 65, 66, 64] has improved, optimized,
and implemented the batching argument of Ishai et al. [46]
for the purpose of outsourcing computation. In particular,
by relying on quadratic arithmetic programs of [38], Setty
et al. [64] have improved the running time of the veri-
ï¬er and prover to max{S,N}Â·poly(Î» ) and ËœO(S)Â· poly(Î» )
respectively. Vu et al. [71] provide a system that incorpo-
rates both the batching arguments of [63, 65, 66, 64] as
well as the interactive proofs of [32, 68, 67]. The system
decides which of the two approaches is more efï¬cient to
use for outsourcing a given computation.

Braun et al. [27] apply batching techniques (as well
as zk-SNARKs) to verify MapReduce computations, by
relying on various veriï¬able data structures.
Arguments with competing provers. Canetti et al. [29]
use collision-resistant hashes to get a protocol for out-
sourcing deterministic computations in a model where
a veriï¬er interacts with two computationally-bounded
provers at least one of which is honest [34]. The proto-
col in [29] works directly for random-access machines,
and therefore does not require reducing random-access
machines to any â€œlower-levelâ€ representation (such as
circuits). Canetti et al. implement their protocol for deter-
ministic x86 programs.
Previous circuit generators.
Some prior work ad-
dresses the problem of translating high-level languages
into low-level languages such as circuits. Most prior work
only supports restricted classes of programs: [66, 64]
present a circuit generator based on Fairplay [53, 12],
whose SFDL language does not support important primi-
tives and has inefï¬cient support for others; [56] present a
circuit generator for programs without data dependencies
(pointers and array indices must be known at compile
time, and so do loop iteration bounds).

Other works support more general functionality: [16]
rely on nondeterministic routing to support random-
access machine computations [14]; [27] rely on online
memory checking [24, 14] to support accessing untrusted
storage from a circuit. See [27, Section 2] for a more
detailed overview of some of the above techniques.
Other cryptographic tools. Fully-homomorphic en-
cryption (FHE) [39] and probabilistically-checkable
proofs [5, 4] are powerful tools that are often used in pro-
tocols for outsourcing computations (with integrity or con-
ï¬dentiality guarantees, or both) [49, 54, 2, 37, 31, 47, 41].
However, such constructions have so far not been explored
in practice. Another powerful tool is secure multi-party
computation [40, 13], but most work in this area does not
consider the goal of succinctness.

794  23rd USENIX Security Symposium 

USENIX Association

14

B Case study: memcpy
The function memcpy is a standard C function that works
as follows: given as input two array pointers and a length,
memcpy copies the contents of one array to the other.
Of course, with no data dependencies, copying data in a
circuit is trivial: you just connect the appropriate wires.
However, when the array addresses and their lengths are
unknown, and memcpy is invoked as a subroutine in a
larger program, the trivial solution does not work, and an
efï¬cient implementation is needed.

A naive implementation of memcpy iterates, via a loop,
over each array position i and copies the i-th value from
one array to the other. In vnTinyRAM each such loop
iteration costs 6 instructions; 2 of these are to increase the
iteration counter and jump back to the start of the loop.
Thus, for m-long arrays, copying takes 6m instructions
(discounting loop initialization). But, in vnTinyRAM,
one can do better: loop unrolling can be used to avoid
paying for the 2 â€œcontrolâ€ instructions. Asymptotically,
the optimal number of unrollings depends on the array
length: it is Î˜(âˆšm). Thus, optimal unrolling requires
dynamic code generation on a von Neumann architec-
ture. We wrote a 54-instruction vnTinyRAM program
for memcpy that uses dynamic loop unrolling to achieve
an efï¬ciency of â‰ˆ 4m + 11.5âˆšm cycles for m-long ar-
rays. For m â‰¥ 600, we get 1.25Ã— speed-up over the naive
implementation, and 1.4Ã— speed-up for m â‰¥ 3000.
Acknowledgments
We thank Daniel Genkin, Raluca Ada Popa, Ron Rivest,
and Nickolai Zeldovich for helpful comments and discus-
sions, and Lior Greenblatt, Shaul Kï¬r, Michael Riabzev,
and Gil Timnat for programming assistance.

This work was supported by: the Center for Science
of Information (CSoI), an NSF Science and Technology
Center, under grant agreement CCF-0939370; the Check
Point Institute for Information Security; the European
Communityâ€™s Seventh Framework Programme (FP7/2007-
2013) under grant agreement number 240258; the Israeli
Centers of Research Excellence I-CORE program (center
4/11); the Israeli Ministry of Science, Technology and
Space; the Simons Foundation, with a Simons Award for
Graduate Students in Theoretical Computer Science; and
the Skolkovo Foundation.
References
[1] AJTAI, M., KOML Â´OS, J., AND SZEMER Â´EDI, E. An o(nlogn)

sorting network. In STOC â€™83 (1983).

[2] APPLEBAUM, B., ISHAI, Y., AND KUSHILEVITZ, E. From
secrecy to soundness: Efï¬cient veriï¬cation via secure computation.
In ICALP â€™10 (2010).

[3] AR `ENE, C., LANGE, T., NAEHRIG, M., AND RITZENTHALER,
C. Faster computation of the Tate pairing. Journal of Number
Theory (2011).

15

[4] ARORA, S., LUND, C., MOTWANI, R., SUDAN, M., AND
SZEGEDY, M. Proof veriï¬cation and the hardness of approxi-
mation problems. JACM (1998).

[5] ARORA, S., AND SAFRA, S. Probabilistic checking of proofs: a

new characterization of NP. JACM (1998).

[6] BABAI, L., FORTNOW, L., LEVIN, L. A., AND SZEGEDY, M.
Checking computations in polylogarithmic time. In STOC â€™91
(1991).

[7] BARRETO, P. S. L. M., KIM, H. Y., LYNN, B., AND SCOTT, M.
Efï¬cient algorithms for pairing-based cryptosystems. In CRYPTO
â€™02 (2002).

[8] BARRETO, P. S. L. M., LYNN, B., AND SCOTT, M. Efï¬cient
implementation of pairing-based cryptosystems. Journal of Cryp-
tology (2004).

[9] BARRETO, P. S. L. M., AND NAEHRIG, M. Pairing-friendly

elliptic curves of prime order. In SACâ€™05 (2006).

[10] BEAUQUIER, B., AND Â´ERIC, D. On arbitrary size Waksman net-
works and their vulnerability. Parallel Processing Letters (2002).
[11] BELLARE, M., AND GOLDREICH, O. On deï¬ning proofs of

knowledge. In CRYPTO â€™92 (1993).

[12] BEN-DAVID, A., NISAN, N., AND PINKAS, B. FairplayMP: a

system for secure multi-party computation. In CCS â€™08 (2008).

[13] BEN-OR, M., GOLDWASSER, S., AND WIGDERSON, A. Com-
pleteness theorems for non-cryptographic fault-tolerant distributed
computation (extended abstract). In STOC â€™88 (1988).

[14] BEN-SASSON, E., CHIESA, A., GENKIN, D., AND TROMER,
E. Fast reductions from RAMs to delegatable succinct constraint
satisfaction problems. In ITCS â€™13 (2013).

[15] BEN-SASSON, E., CHIESA, A., GENKIN, D., AND TROMER, E.
On the concrete efï¬ciency of probabilistically-checkable proofs.
In STOC â€™13 (2013).

[16] BEN-SASSON, E., CHIESA, A., GENKIN, D., TROMER, E.,
AND VIRZA, M. SNARKs for C: Verifying program executions
succinctly and in zero knowledge. In CRYPTO â€™13 (2013).

[17] BEN-SASSON, E., CHIESA, A., GENKIN, D., TROMER, E., AND

VIRZA, M. TinyRAM architecture speciï¬cation v2.00, 2013.

[18] BEN-SASSON, E., GOLDREICH, O., HARSHA, P., SUDAN, M.,
AND VADHAN, S. Short PCPs veriï¬able in polylogarithmic time.
In CCC â€™05 (2005).

[19] BERNSTEIN, D. J., DUIF, N., LANGE, T., SCHWABE, P., AND
YANG, B.-Y. High-speed high-security signatures. In CHES â€™11
(2011).

[20] BEUCHAT, J.-L., GONZ Â´ALEZ-DÂ´IAZ, J. E., MITSUNARI, S.,
OKAMOTO, E., RODRÂ´IGUEZ-HENRÂ´IQUEZ, F., AND TERUYA, T.
High-speed software implementation of the optimal ate pairing
over Barreto-Naehrig curves. In Pairing â€™10 (2010).

[21] BITANSKY, N., CANETTI, R., CHIESA, A., AND TROMER, E.
Recursive composition and bootstrapping for SNARKs and proof-
carrying data. In STOC â€™13 (2013).

[22] BITANSKY, N., CHIESA, A., ISHAI, Y., OSTROVSKY, R., AND
PANETH, O. Succinct non-interactive arguments via linear inter-
active proofs. In TCC â€™13 (2013).

[23] BLUM, M., DE SANTIS, A., MICALI, S., AND PERSIANO, G.

Non-interactive zero-knowledge. SIAM J. Comp. (1991).

[24] BLUM, M., EVANS, W., GEMMELL, P., KANNAN, S., AND
NAOR, M. Checking the correctness of memories. In FOCS â€™91
(1991).

[25] BLUM, M., FELDMAN, P., AND MICALI, S. Non-interactive

zero-knowledge and its applications. In STOC â€™88 (1988).

USENIX Association  

23rd USENIX Security Symposium  795

[26] BOS, J., AND COSTER, M. Addition chain heuristics. In CRYPTO

â€™89 (1989).

[27] BRAUN, B., FELDMAN, A. J., REN, Z., SETTY, S., BLUMBERG,
A. J., AND WALFISH, M. Verifying computations with state. In
SOSP â€™13 (2013).

[28] BRICKELL, E. F., GORDON, D. M., MCCURLEY, K. S., AND
WILSON, D. B. Fast exponentiation with precomputation. In
EUROCRYPT â€™92 (1993).

[29] CANETTI, R., RIVA, B., AND ROTHBLUM, G. N. Practical
delegation of computation using multiple servers. In CCS â€™11
(2011).

[30] CANETTI, R., RIVA, B., AND ROTHBLUM, G. N. Two protocols

for delegation of computation. In ICITS 12 (2012).

[31] CHUNG, K.-M., KALAI, Y., AND VADHAN, S. Improved dele-
gation of computation using fully homomorphic encryption. In
CRYPTO â€™10 (2010).

[32] CORMODE, G., MITZENMACHER, M., AND THALER, J. Prac-
tical veriï¬ed computation with streaming interactive proofs. In
ITCS â€™12 (2012).

[33] EDWARDS, H. M. A normal form for elliptic curves. Bulletin of

the American Mathematical Society (2007).

[34] FEIGE, U., AND KILIAN, J. Making games short. In STOC â€™97

(1997).

[35] FUENTES-CASTA ËœNEDA, L., KNAPP, E., AND RODRÂ´IGUEZ-

HENRÂ´IQUEZ, F. Faster hashing to G2. In SAC â€™11 (2012).

[36] GAL, A., EICH, B., SHAVER, M., ANDERSON, D., MANDELIN,
D., HAGHIGHAT, M. R., KAPLAN, B., HOARE, G., ZBARSKY,
B., ORENDORFF, J., RUDERMAN, J., SMITH, E. W., REIT-
MAIER, R., BEBENITA, M., CHANG, M., AND FRANZ, M. Trace-
based just-in-time type specialization for dynamic languages. In
PLDI â€™09 (2009).

[37] GENNARO, R., GENTRY, C., AND PARNO, B. Non-interactive
veriï¬able computing: outsourcing computation to untrusted work-
ers. In CRYPTO â€™10 (2010).

[38] GENNARO, R., GENTRY, C., PARNO, B., AND RAYKOVA, M.
Quadratic span programs and succinct NIZKs without PCPs. In
EUROCRYPT â€™13 (2013).

[39] GENTRY, C. Fully homomorphic encryption using ideal lattices.

In STOC â€™09 (2009).

[40] GOLDREICH, O., MICALI, S., AND WIGDERSON, A. How to
play any mental game or a completeness theorem for protocols
with honest majority. In STOC â€™87 (1987).

[41] GOLDWASSER, S., KALAI, Y., POPA, R. A., VAIKUN-
TANATHAN, V., AND ZELDOVICH, N. Reusable garbled circuits
and succinct functional encryption. In STOC â€™13 (2013).

[42] GOLDWASSER, S., KALAI, Y. T., AND ROTHBLUM, G. N. Dele-
gating computation: Interactive proofs for Muggles. In STOC â€™08
(2008).

[43] GOLDWASSER, S., MICALI, S., AND RACKOFF, C. The knowl-
edge complexity of interactive proof systems. SIAM J. Comp.
(1989).

[44] GRANGER, R., AND SCOTT, M. Faster squaring in the cyclotomic

subgroup of sixth degree extensions. In PKCâ€™10 (2010).

[45] GROTH, J. Short non-interactive zero-knowledge proofs.

ASIACRYPT â€™10 (2010).

In

[46] ISHAI, Y., KUSHILEVITZ, E., AND OSTROVSKY, R. Efï¬cient

arguments without short PCPs. In CCC â€™07 (2007).

[47] KALAI, Y., RAZ, R., AND ROTHBLUM, R. Delegation for

bounded space. In STOC â€™13 (2013).

[48] KALAI, Y. T., AND RAZ, R. Probabilistically checkable argu-

ments. In CRYPTO â€™09 (2009).

[49] KILIAN, J. A note on efï¬cient zero-knowledge proofs and argu-

ments. In STOC â€™92 (1992).

[50] KIM, T., KIM, S., AND CHEON, J. H. On the ï¬nal exponentiation
in Tate pairing computations. IEEE Trans. on Inf. Theory (2013).
[51] LIPMAA, H. Progression-free sets and sublinear pairing-based
non-interactive zero-knowledge arguments. In TCC â€™12 (2012).
[52] LIPMAA, H. Succinct non-interactive zero knowledge arguments
from span programs and linear error-correcting codes. In ASI-
ACRYPT â€™13 (2013).

[53] MALKHI, D., NISAN, N., PINKAS, B., AND SELLA, Y. Fairplay
â€” a secure two-party computation system. In SSYM â€™04 (2004).
[54] MICALI, S. Computationally sound proofs. SIAM J. Comp.

(2000).

[55] NAOR, M., AND YUNG, M. Public-key cryptosystems provably

secure against chosen ciphertext attacks. In STOC â€™90 (1990).

[56] PARNO, B., GENTRY, C., HOWELL, J., AND RAYKOVA, M.
In Oak-

Pinocchio: Nearly practical veriï¬able computation.
land â€™13 (2013).

[57] PIPPENGER, N. On the evaluation of powers and monomials.

SIAM J. Comp. (1980).

[58] RIGO, A., AND PEDRONI, S. PyPyâ€™s approach to virtual machine

construction. In OOPSLA â€™06 (2006).

[59] SCOTT, M. Computing the Tate pairing. In CT-RSA â€™05 (2005).
[60] SCOTT, M. Implementing cryptographic pairings. In Pairing â€™07

(2007).

[61] SCOTT, M., AND BARRETO, P. S. L. M. Compressed pairings.

In CRYPTO â€™04 (2004).

[62] SCOTT, M.,

N.,

BENGER,

CHARLEMAGNE, M.,
DOMINGUEZ PEREZ, L. J., AND KACHISA, E. J.
On
the ï¬nal exponentiation for calculating pairings on ordinary
elliptic curves. In Pairing â€™09 (2009).

[63] SETTY, S., BLUMBERG, A. J., AND WALFISH, M. Toward
practical and unconditional veriï¬cation of remote computations.
In HotOS â€™11 (2011).

[64] SETTY, S., BRAUN, B., VU, V., BLUMBERG, A. J., PARNO, B.,
AND WALFISH, M. Resolving the conï¬‚ict between generality and
plausibility in veriï¬ed computation. In EuroSys â€™13 (2013).

[65] SETTY, S., MCPHERSON, M., BLUMBERG, A. J., AND WAL-
FISH, M. Making argument systems for outsourced computation
practical (sometimes). In NDSS â€™12 (2012).

[66] SETTY, S., VU, V., PANPALIA, N., BRAUN, B., BLUMBERG,
A. J., AND WALFISH, M. Taking proof-based veriï¬ed computa-
tion a few steps closer to practicality. In Security â€™12 (2012).

[67] THALER, J. Time-optimal interactive proofs for circuit evaluation.

In CRYPTO â€™13 (2013).

[68] THALER, J., ROBERTS, M., MITZENMACHER, M., AND PFIS-
TER, H. Veriï¬able computation with massively parallel interactive
proofs. CoRR (2012).

[69] VALIANT, P. Incrementally veriï¬able computation or proofs of

knowledge imply time/space efï¬ciency. In TCC â€™08 (2008).

[70] VERCAUTEREN, F. Optimal pairings. IEEE Trans. on Inf. Theory

(2010).

[71] VU, V., SETTY, S., BLUMBERG, A. J., AND WALFISH, M.
A hybrid architecture for interactive veriï¬able computation. In
Oakland â€™13 (2013).

[72] ZAHUR, S., AND EVANS, D. Circuit structures for improving

efï¬ciency of security and privacy tools. In SP â€™13 (2013).

796  23rd USENIX Security Symposium 

USENIX Association

16

