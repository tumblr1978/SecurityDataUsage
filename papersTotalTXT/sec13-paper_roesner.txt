Securing Embedded User Interfaces: 

Android and Beyond

Franziska Roesner and Tadayoshi Kohno, University of Washington

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Securing Embedded User Interfaces: Android and Beyond

Franziska Roesner and Tadayoshi Kohno

University of Washington

Abstract

Web and smartphone applications commonly embed
third-party user interfaces like advertisements and so-
cial media widgets. However, this capability comes with
security implications, both for the embedded interfaces
and the host page or application. While browsers have
evolved over time to address many of these issues, mo-
bile systems like Android — which do not yet support
true cross-application interface embedding — present an
opportunity to redesign support for secure embedded
user interfaces from scratch. In this paper, we explore
the requirements for a system to support secure embed-
ded user interfaces by systematically analyzing existing
systems like browsers, smartphones, and research sys-
tems. We describe our experience modifying Android to
support secure interface embedding and evaluate our im-
plementation using case studies that rely on embedded
interfaces, such as advertisement libraries, Facebook so-
cial plugins (e.g., the “Like” button), and access control
gadgets. We provide concrete techniques and reﬂect on
lessons learned for secure embedded user interfaces.
1
Modern Web and smartphone applications commonly
embed third-party content within their own interfaces.
Websites embed iframes containing advertisements, so-
cial media widgets (e.g., Facebook’s “Like” or Twitter’s
“tweet” button), Google search results, or maps. Smart-
phone applications include third-party libraries that dis-
play advertisements or provide billing functionality.

Introduction

Including third-party content comes with potential se-
curity implications, both for the embedded content and
the host application. For example, a malicious host may
attempt to eavesdrop on input intended for embedded
content or forge a user’s intent to interact with it, either
by tricking the user (e.g., by clickjacking) or by program-
matically issuing input events. On the other hand, a ma-
licious embedded principal may, for example, attempt to
take over a larger display area than expected.

The Web security model has evolved over time to ad-
dress these and other threats. For example, the same-
origin policy prevents embedded content from directly
accessing or manipulating the parent page, and vice
versa. As recently as 2010, browsers have added the
sandbox attribute for iframes [1], allowing websites to

prevent embedded content from running scripts or redi-
recting the top-level page. However, other attacks —
like clickjacking — remain a serious concern. Malicious
websites frequently mount “likejacking” attacks [24] on
the Facebook “Like” button, in which they trick users
into sharing the host page on their Facebook proﬁles. If
Facebook suspects a button of being part of such an at-
tack, it asks the user to conﬁrm any action in an addi-
tional popup dialog [7] — in other words, Facebook falls
back on a non-embedded interface to compensate for the
insecurity of embedded interfaces.

While numerous research efforts have attempted to
close the remaining security gaps with respect to inter-
face embedding on the Web [11, 25, 29], they struggle
with maintaining backwards compatibility and are bur-
dened with the complexity of the existing Web model.
We argue that Android, which to date offers no cross-
application embedding, offers a compelling opportunity
to redesign secure embedded interfaces from scratch.

Today, applications on Android and other mobile op-
erating systems cannot embed interfaces from another
principal; rather, they include third-party libraries that
run in the host application’s context and provide cus-
tom user interface elements (such as advertisements). On
the one hand, these libraries can thus abuse the permis-
sions of or otherwise take advantage of their host appli-
cations. On the other hand, interface elements provided
by these libraries are vulnerable to manipulation by the
host application. For example, Android applications can
programmatically click on embedded ads in an attempt
to increase their advertising revenue [18]. This lack of
security also precludes desirable functionality from the
Android ecosystem. For example, the social plugins that
Facebook provides on the Web (e.g., the “Like” button or
comments widget) are not available on Android.

Previous research efforts for Android [17, 23] have fo-
cused only on one interface embedding scenario: adver-
tising. As a result, these systems, while valuable, do not
provide complete or generalizable solutions for interface
embedding. For example, to our knowledge, no existing
Android-based solution prevents a host application from
eavesdropping on input to an embedded interface.

In this paper, we explore what it takes to support se-
cure embedded UIs on Android. We systematically an-
alyze existing systems, including browsers, with respect

USENIX Association  

22nd USENIX Security Symposium  97

1

to whether and how they provide a set of security proper-
ties. We view this analysis and the framework we use
for it as a contribution in its own right.
Informed by
this analysis, we describe our experiences modifying the
Android framework to support cross-principal interface
embedding in a way that meets our security goals. We
evaluate our implementation using case studies that rely
on embedded interfaces, including: (1) advertisement li-
braries that run in a separate process from the embedding
application, (2) Facebook social plugins, to date avail-
able only on the Web, and (3) access control gadgets [19]
that allow applications to access sensitive resources (like
geolocation) only in response to real user input.

Through our implementation experience, we consoli-
date and evaluate approaches from prior work. We ﬁnd
that some techniques can be simpliﬁed in practice —
such as an approach for maintaining invariants in the UI
layout tree [18] — but that we face additional practical
challenges, like propagating layout changes across pro-
cesses. We discover that an embedded element’s size is
an important factor in preventing clickjacking, as well
as that we can apply prior work on access control gad-
gets [19] in novel ways to improve interaction ﬂexibility
beyond the browser model. We discuss these and other
challenges and lessons in more detail in Section 8, which
beneﬁts from the context of the preceding sections.

Today’s system developers wishing to support secure
embedded user interfaces have no systematic set of tech-
niques or criteria upon which they can draw. Short
of simply adopting the Web model by directly extend-
ing an existing browser — which may be undesirable for
many reasons, including the need to maintain backwards
compatibility with the existing Web ecosystem and pro-
gramming model — system developers must (1) reverse-
engineer existing techniques used by browsers, and (2)
evaluate and integrate research solutions that address re-
maining issues.
In addition to presenting the ﬁrst se-
cure interface embedding solution for Android, this pa-
per provides a concrete, comprehensive, and system-
independent set of criteria and techniques for supporting
secure embedded user interfaces.

2 Motivation and Background
To motivate the need for secure embedded user inter-
faces, we describe (1) the functionality enabled by em-
bedded applications and interfaces, and (2) the security
concerns associated with this embedding. We argue that
interface embedding often increases the usability of a
particular interaction — embedded content is shown in
context, and users can interact with multiple principals
in one view — but that security concerns associated with
cross-principal UI embedding lead to designs that are
more disruptive to the user experience (e.g., prompts).

2.1 Functionality
Third-Party Applications. Web and smartphone appli-
cations often embed or redirect to user interfaces from
other sources. Common use cases include third-party
advertisements and social sharing widgets (e.g., Face-
book’s “Like” button or comment feed, Google’s “+1”
button, or a Twitter feed). Other examples of embed-
dable content include search boxes and maps.

On the Web, content embedding is done using HTML
tags like iframe or object. On smartphone oper-
ating systems like iOS and Android, however, applica-
tions cannot directly embed UI from other applications
but rather do one of two things: (1) launch another appli-
cation’s full-screen view (via an Android Intent or an iOS
RemoteViewController [2]) or (2) include a library that
provides embeddable UI elements in the application’s
own process. The former is generally used for sharing
actions (e.g., sending an email) and the latter is generally
used for embedded advertisements and billing.
System UI. Security-sensitive actions often elicit system
interfaces, usually in the form of prompts. For exam-
ple, Windows users are shown a User Account Control
dialog [14] when an application requires elevation to ad-
ministrative privileges, and iOS and browser users must
respond to a permission dialog when an application at-
tempts to access a sensitive resource (e.g., geolocation).
Because prompts result in a disruptive user experience,
the research community has explored using embedded
system interfaces to improve the usability of security-
sensitive interactions like resource access.
In particu-
lar, a recent paper [19] describes access control gadgets
(ACGs), embeddable UI elements that — with user in-
teraction — grant applications access to various system
resources, including the camera, the clipboard, the GPS,
etc. For example, an application might embed a loca-
tion ACG, which is provided by the system and dis-
plays a recognizable location icon; when the user clicks
the ACG, the embedding application receives the current
GPS coordinates. As we describe below, ACGs cannot
be introduced into most of today’s systems without sig-
niﬁcant changes to those systems.
2.2 Threat Model and Security Concerns
We consider user interfaces composed of elements
from different, potentially mutually distrusting principals
(e.g., a host application and an embedded advertisement
or an embedded ACG). Host principals may attempt to
manipulate interface elements embedded from another
principal, and embedded principals may attempt to ma-
nipulate those of their host. We assume that the system
itself is trustworthy and uncompromised.

We observe that while Web and smartphone applica-
tions rely heavily on third-party content and services, the
associated third-party user interface is not always actu-

98  22nd USENIX Security Symposium 

USENIX Association

2

ally embedded inside of the client application. For exam-
ple, websites redirect users to PayPal’s full-screen page,
OAuth authorization dialogs appear in pop-up or redi-
rect windows, and Web users who click on a Facebook
“Like” button that is suspected of being part of a click-
jacking attack will see an additional pop-up conﬁrmation
dialog. We observe two main security-related reasons for
the choice not to embed or not to be embedded.

One reason is concern about phishing. If users become
accustomed to seeing embedded third-party login or pay-
ment forms, they may become desensitized to their ex-
istence. Further, because users cannot easily determine
the origin (or presence) of embedded content, malicious
applications may try to trick users into entering sensi-
tive information into spoofed embedded forms (a form
of phishing). Thus, legitimate security-sensitive forms
are often shown in their own tab or window.

Our goal in this paper is not to address such phishing
attacks, but rather to evaluate and implement methods
for securely embedding one legitimate (i.e., not spoofed)
application within another. (While extensions of existing
approaches, such as SiteKeys, may help mitigate embed-
ded phishing attacks, these approaches do have limita-
tions [21] and are orthogonal to the goals of this paper.1)
More importantly — and the subject of this paper —
even legitimate embedded interfaces may be subject to a
wide range of attacks, or may present a threat to the ap-
plication or page that embeds them. In particular, draw-
ing in part on [18], embedded interfaces or their parents
may be subject to:
Display forgery attacks, in which the parent applica-
tion modiﬁes the child element (e.g., to display a false
payment value), or vice versa.
Size manipulation attacks, in which the parent appli-
cation violates the child element’s size requirements or
expectations (e.g., to secretly take photos by hiding the
camera preview [26]), or the child element sets it own
size inappropriately (e.g., to display a full-screen ad).
Input forgery attacks, in which the parent application
delivers forged user input to a child element (e.g., to pro-
grammatically click on an advertisement to increase ad
revenue), or vice versa.
Clickjacking attacks, in which the parent application
forces or tricks the user into clicking on an embedded
element [11] using visual tricks (partially obscuring the
child element or making it transparent) or via timing-
based attacks (popping up the child element just as the
user is about to click in a predictable place).
Focus stealing attacks, in which the parent application
steals the input focus from an embedded element, cap-
turing input intended for it, or vice versa.

1We also note that phished or spoofed interfaces are little threat if
they do not accept private user input — for example, clicking on a fake
ACG will not grant any permissions to the embedding application.

Ancestor redirection attacks, in which a child element
redirects an ancestor (e.g., the top-level) application or
page to a target of its choice, without user consent.
Denial-of-service attacks, in which the parent applica-
tion prevents user input from reaching a child element
(e.g., to prevent a user from clicking “Cancel” on an au-
thorization dialog), or vice versa.
Data privacy attacks, in which the parent or child ex-
tract content displayed in the other.
Eavesdropping attacks, in which the parent application
eavesdrops on user input intended for a child element
(e.g., a sensitive search query), or vice versa.
2.3 Security Goals
Motivated by the above challenges and building on recent
work [18], we now describe the security goals that we
apply in our analysis and implementation. Where noted,
we describe additional goals not discussed by prior work.
1. Display Integrity. One principal cannot alter the con-
tent or appearance of another’s interface element, ei-
ther by direct pixel manipulation or by element size
manipulation. This property prevents display forgery
and size manipulation attacks.

2. Input Integrity. One principal cannot programmati-
cally interact with another’s interface element. This
property prevents input forgery attacks.

3. Intent Integrity. First, an interface element can im-
plement (or request that the system enforce) protec-
tion against clickjacking attacks. Second, one princi-
pal cannot prevent intended user interactions with an-
other’s interface element (denial-of-service). Finally,
based on our implementation experience (Section 5),
we add two additional requirements not discussed in
previous work: an embedded interface element can-
not redirect an ancestor’s view without user consent,
and no interface element can steal focus from another
interface element belonging to a different principal.
4. Data Isolation. One principal cannot extract content
displayed in, nor eavesdrop on user input intended
for, another’s interface element. This property pre-
vents data privacy and eavesdropping attacks.

5. UI-to-API Links. APIs can verify that they were
called by a particular principal or interface element.
These properties assume that principals can be reliably
distinguished and isolated, either by process separation,
run-time validation (e.g., of the same-origin policy), or
compile-time validation (e.g., using static analysis).
3 The Case for Secure UIs in Android
While Section 2 considered UI embedding in general,
we now speciﬁcally make the case for secure embedded
UIs in Android. The fact that an Android application
cannot embed another application’s interface results in a

USENIX Association  

22nd USENIX Security Symposium  99

3

fundamental trust assumption built into the Android UI
toolkit. In particular, every UI element trusts its parent
and its children, who each have unrestricted access to the
element’s APIs. Vulnerabilities arise when this trust as-
sumption is violated, e.g., because an embedded element
is provided by a third-party library.

We now introduce several case studies illustrating that
embedded user interface scenarios in stock Android are
often either insecure or impossible. We will return to
these case studies in Section 6 and reevaluate them in the
context of our implementation.
Advertising. In stock Android, applications wishing to
embed third-party advertisements must include an ad li-
brary, such as AdMob or Mobclix, which runs in the em-
bedding application’s process. These libraries provide a
custom UI element (an AdView) that the embedding ap-
plication instantiates and embeds. As has been discussed
extensively in prior work [17, 23], the library model for
third-party advertisements comes with a number of se-
curity and privacy concerns. For example, the host ap-
plication must trust the advertising library not to abuse
the host’s permissions or otherwise exploit a buggy host
application. Additionally, ad libraries ask their host ap-
plications to request permissions (such as location and
Internet access) on their behalf; applications that request
permissions not clearly relevant to their stated purpose
can desensitize users to permission warnings [8].

Prior work [18] has also identiﬁed and experimen-
tally demonstrated threats to the AdView. Parent appli-
cations can mount a programmatic clickfraud attack in
which they programmatically click on embedded ads to
increase their advertising revenue. Similarly, parent ap-
plications can mount clickjacking attacks by, for exam-
ple, covering the AdView with another UI element that
does not accept (and thus lets pass through) input events.
WebViews. One of the built-in UI elements provided by
Android is the WebView, which can load local HTML
content or an arbitrary URL from the Internet. Though
WebViews appear conceptually similar to iframes, they
do not provide many of the same security properties.
In particular, WebViews — and more importantly, the
contained webpage — can be completely manipulated by
the containing application, which can mount attacks in-
cluding programmatic clicking, clickjacking, and input
eavesdropping [13]. Thus, for example, if an Android
application embeds a WebView that loads a login page,
that application can eavesdrop on the user’s password as
he or she enters it into the WebView.
Facebook Social Plugins. On the Web, Facebook pro-
vides a set of social plugins [6] to third-party web de-
velopers. These plugins include the “Like” button, a
comments widget, and a feed of friends’ activities on
the embedding page (e.g., which articles they liked or

shared). These social plugins are generally implemented
as iframes and thus isolated from the embedding page.

While Facebook also supplies an SDK for smart-
phones (iOS and Android),
this library — like all li-
braries, it runs in the host application’s process — does
not provide embeddable plugins like those found on the
Web. A possible reason for this omission is that Face-
book’s SDK for Android cannot prevent, for example,
applications from programmatically clicking on an em-
bedded “Like” button or extracting private information
from a recommendations plugin. Although developers
can manually implement a social plugin using a Web-
View, this implementation suffers from the security con-
cerns described above. Thus, though embeddable social
plugins on mobile may be desirable to Facebook, they
cannot be achieved securely on stock Android.
Access Control Gadgets. Finally, recent work [19] has
proposed access control gadgets (ACGs), secure em-
bedded UI elements that are used to capture a user’s
permission-granting intent (e.g., to grant an application
access to the user’s current location). Authentically cap-
turing a user’s intent relies on a set of UI-level secu-
rity properties including clickjacking protection, display
isolation, and user intent protection. As we describe in
this paper, fundamental modiﬁcations to Android are re-
quired to enable secure embedded elements like ACGs.
4 Analysis of UI Embedding Systems
To assess the spectrum of solutions and to inform our
implementation choices, we now step back and ana-
lyze prior Web and Android based solutions for cross-
application embedded interfaces with respect to the set of
security properties described in Section 2.3. This analy-
sis is summarized in Figure 1.
4.1 Browsers
Browsers support third-party embedding by allowing
web pages to include iframes from different domains.
Like all pages, iframes are isolated from their parent
pages based on the same-origin policy [27], and browsers
do not allow pages from different origins to capture or
generate input for each other.

However, an iframe’s parent has full control of its size,
layout, and style, including the ability to make it trans-
parent or overlay it with other content. These capabili-
ties enable clickjacking attacks. While there are various
“framebusting” techniques that allow a sensitive page to
prevent itself from being framed in an attempt to prevent
such attacks, these techniques are not foolproof [20].
More importantly, framebusting is a technique to prevent
embedding, not one that supports secure embedding.

Additionally, while an iframe cannot read the URL(s)
of its ancestor(s), it can change the top-level URL, redi-
recting the page without user consent. Newer version of

100  22nd USENIX Security Symposium 

USENIX Association

4

Category

Security Requirement

Browsers Android AdDroid [17] AdSplit [23] RFK [18]

Display Integrity

Prevents direct modiﬁcation
Prevents size manipulation

Input Integrity

Prevents programmatic input

Intent Integrity

Data Isolation

Clickjacking protection
Prevents input denial-of-service
Prevents focus stealing
Prevents ancestor redirection

Prevents access to display
Prevents input eavesdropping

UI-to-API Links APIs can verify caller





























































*
*

*


*



*
*

*

Figure 1: Analysis of Existing Systems. This table summarizes, to the best of our knowledge, the UI-level security properties
(ﬁrst deﬁned in prior work [18] and expanded here) achieved by existing systems. Figure 2 similarly analyzes our implementation.
* Checkmarks annotated with an asterisk require static analysis or hypothetical (not prototyped) changes to the Android framework.

some browsers allow parent pages to protect themselves
by using the sandbox attribute for iframes; thus, we’ve
indicated that the Web prevents such attacks in Figure 1.
However, we observe that it may be desirable to allow
user actions to override such a restriction, and we de-
scribe how to achieve such a policy in later sections.

Research browsers and browser operating systems
(e.g., Gazelle [29] and IBOS [25]) provide similar em-
bedded UI security properties as traditional browsers,
and thus we omit them from Figure 1. Gazelle partially
addresses clickjacking by allowing only opaque cross-
origin overlays, but this policy is not backwards com-
patible. Furthermore, malicious parent pages can still
obscure embedded content by partially overlaying addi-
tional content on top of sensitive iframes. We discuss
additional work considering clickjacking in Section 9.
4.2 Android
Two recent research efforts [17, 23] propose privilege
separation to address security concerns with Android’s
advertising model (under which third-party ad libraries
run in the context of the host application). AdDroid’s
approach [17] introduces a system advertising service
that returns advertisements to the AdDroid userspace li-
brary, which displays them in a new user interface ele-
ment called an AdView. While this approach success-
fully removes untrusted ad libraries from applications, it
does not provide any additional UI-level security proper-
ties for the embedded AdView beyond what is provided
by stock Android (see Figure 1). For example, it does not
prevent the host application from engaging in clickfraud
by programmatically clicking on ads.

AdSplit [23], on the other hand, fully separates ad-
vertisements into distinct Android applications (one for
each host application). AdSplit achieves the visual em-
bedding of the ad’s UI into the application’s UI by over-
laying the host application, with a transparent region for

Finally,

the ad, on top of the ad application. It prevents program-
matic clickfraud attacks by authenticating user input us-
ing Quire [3]. As summarized in Figure 1, AdSplit meets
the majority of security requirements for embedded UIs.
Indeed, the requirements it meets are sufﬁcient for em-
bedded advertisements. Because it does not meet all of
the requirements, however — most importantly, it does
not prevent input eavesdropping — AdSplit would not be
well-suited as a generalized solution for embedded UIs.
the prototype implementation described
in [18] to meet that work’s goals (upon which we build)
also contains weaknesses. In particular, the isolation and
identiﬁcation of different principals (“trust groups” in
the terminology of that paper) is insecure, undermining
all of the security properties. Rather than truly support-
ing one Android application embedding UI from another
application, it merely separates interfaces deﬁned in the
main application from those deﬁned in included libraries.
This separation relies on Java package names, static code
analysis, and hypothetical changes to the Android frame-
work (e.g., changing Android’s Java classloader to en-
able package sealing) that have not been implemented or
veriﬁed in practice.

5
Implementation Experience: LayerCake
We now explore what it takes to support secure embed-
ded UIs, under the deﬁnitions from Section 2.3, in the
Android framework. As no existing Android-based so-
lutions meet these goals, we view this implementation
as an opportunity to consider secure embedding from
scratch. While we adapt techniques from prior work, we
ﬁnd that previously published guidelines are not always
directly applicable. For example, we found that we could
simplify a prior approach [18] when overlaying cross-
application content, but that we faced additional practical
challenges, such as the need to propagate layout changes

USENIX Association  

22nd USENIX Security Symposium  101

5

102  22nd USENIX Security Symposium 

USENIX Association

CategorySecurityRequirementLayerCake(SectionNumber)ApproachDisplayIntegrityPreventsdirectmodiﬁcation(5.3)Embeddedelementsinisolated,overlaidwindows.Preventssizemanipulation(5.6)Usernotiﬁcationsonsizeconﬂicts.InputIntegrityPreventsprogrammaticinput(5.3)Embeddedelementsinisolated,overlaidwindows.IntentIntegrityClickjackingprotection(5.7)Noinputdeliveredifview/windownotfullyvisible.Preventsinputdenial-of-service(5.3)Embeddedwindowsattachedtosystemroot.DataIsolationPreventsaccesstodisplay(5.3)Embeddedelementsinisolated,overlaidwindows.Preventsinputeavesdropping(5.3)Embeddedwindowsattachedtosystemroot.Preventsfocusstealing(5.4)Focuschangesonlyinresponsetorealuserclicks.Preventsancestorredirection(5.8)Promptsand(6.2)redirectionACG.UI-to-APILinksAPIscanverifycaller(5.2)Elementsfromdifferentprincipalsruninseparatecallingprocesses(identiﬁablebypackagename).Figure2:TechniquesforSecureEmbeddedUI.ThistablesummarizeshowLayerCake(ourmodiﬁedversionofAndroid4.2)achieveseachofthedesiredsecuritypropertiesforembeddeduserinterfaceelements.andhandlemultiplelevelsofnesting.WefurtherdiscusstheseandotherchallengesandlessonsinSection8.WethuscreatedLayerCake,amodiﬁedversionoftheAndroidframeworkthatsupportscross-applicationem-beddingviachangestotheActivityManager,theWin-dowManager,andinputdispatching.Weaddedormodi-ﬁed2400linesofsourcecodeacross50ﬁlesinAndroid4.2(JellyBean).Figure2summarizestheimplementa-tionchoicesthatachieveourdesiredsecurityproperties.5.1AndroidBackgroundAndroiduserinterfacesarefocusedaroundActivities,whichpresenttheuserwithaparticularview(orscreen)ofanapplication.AnapplicationgenerallyconsistsofmultipleActivities(e.g.,settings,comments,andnews-feedActivities),eachofwhichdeﬁnesaninterfacecon-sistingofbuilt-inorcustomUIelements(calledViews).Android’sActivityManagerkeepsonlyoneActivityintheforegroundatatime.AnapplicationcannotembedanActivityfromanotherapplication,andtwoapplica-tionscannotrunside-by-side.WhileAndroiddoespro-videsupportforActivityGroups(deprecatedinfavorofFragments)toimproveUIcodereusewithinanappli-cation,thesemechanismsdonotprovidetrueActivityembeddingandarenotapplicableacrossapplicationandprocessboundaries.Thegoalofourexplorationistoal-lowoneapplicationtoembedanActivityfromanotherapplication(runninginthatotherapplication’sprocess).EachrunningAndroidapplicationisassociatedwithoneormorewindows,eachofwhichservesastherootofaninterfacelayouttreeconsistingofapplication-speciﬁedViews.Android’sWindowManagerisolatesthesewindowsfromeachother—e.g.,anapplicationcannotaccessthestatusbar’swindow(shownatthetopofthescreen)—andappropriatelydispatchesuserinput.Ourimplementationreliesontheseisolationproperties.WhileonlyoneActivitycanbeintheforeground,mul-tipleapplications/processesmayhavevisiblewindows.Figure3:SampleApplication.Thisrestaurantreviewap-plicationembedstwothird-partyActivities,anadvertisementandamap.ThemapActivityfurtherembedsanaccesscontrolgadget(ACG)forlocationaccess.Forexample,thestatusbarrunsinthesystemprocess,andthewindowofoneapplicationmaybevisiblebe-lowthe(partially)transparentwindowofanother.Asanexampleofthelatter,AdSplit[23]achievesvisualem-beddingbytakingadvantageofanapplication’sabilitytomakeportionsofitsUItransparent.However,recallfromSection4andFigure1thatthisapproachisinsufﬁ-cientforgeneralizedembeddedUIsecurity.5.2SupportingEmbeddedActivitiesLayerCakeintroducesanewViewintoAndroid’suserinterfacetoolkit(Javapackageandroid.view)calledEmbeddedActivityView.Itallowsanapplicationdevelopertoembedanotherapplication’sActivitywithinherapplication’sinterfacebyspecifyingintheparame-tersoftheEmbeddedActivityViewthepackageandclass6USENIX Association  

22nd USENIX Security Symposium  103

Figure4:WindowManagement.ThisﬁgureshowstheWin-dow/ViewtreefortheActivitiesinFigure3.EmbeddedActiv-itiesarenotembeddedintheViewtree(circles)oftheirpar-ent,butratherwithinaseparatewindow.TheWindowMan-agerkeepstrackofawindow(greysquares)foreachActivityandvisuallyoverlaysanembeddedwindowontopofthecor-respondingEmbeddedActivityViewintheparentActivity.namesofthedesiredembeddedActivity.Figure3showsasampleapplicationthatembedsseveralActivities.WeextendedAndroid’sActivityManager(Java)tosupportembeddedActivities,whicharelaunchedwhenanEmbeddedActivityViewiscreatedanddisplayed.Un-likeordinaryActivities,embeddedActivitiesarenotpartoftheActivityManager’staskstackorhistorylist,butrathersharethefateoftheirparentActivity.Crucially,thismeansthatanembeddedActivity’slifecycleislinkedtothatofitsparent:whentheparentispaused,resumed,ordestroyed,soareallofitsembeddedchildren.AnActivitymayembedmultipleotherActivities,whichthemselvesmayembedoneormoreActivities(multiplenesting).EachembeddedActivityisstartedasanewinstance,somultiplecopiesofthesameActivityareindependent(althoughtheyruninthesameapplica-tion,allowingchangestotheapplication’sglobalstatetopersistacrossdifferentActivityinstances).5.3ManagingWindowsProperlydisplayingembeddedActivitiesrequiredmod-iﬁcationstotheAndroidWindowManager(Java).OneoptionforachievingembeddedUIlayoutsistoliter-allynestthem—thatis,toaddtheembeddedActiv-ity’sViews(UIelements)aschildrenintheparentAc-tivity’sUItree.However,thisdesignwouldallowtheparentActivitytomountinputeavesdroppinganddenial-of-serviceattacksonthechildActivity.Thus,follow-ingtheinterfacelayouttreeinvariantsdescribedinpriorwork[18],wedonotliterallynesttheinterfaceelementsofembeddedActivitiesinsidetheparentActivity.In-stead,anembeddedActivityisdisplayedinanewwin-dow,overlaidontopofthewindowtowhichitisattached(i.e.,thewindowoftheparentActivity).ThisoverlayFigure5:PanningforSoftwareKeyboard.Therestaurantreviewapplication(fromFigure3),includingitsoverlaidem-beddedwindows,mustbepannedupwardtomakeroomforthesoftwarekeyboardunderneaththein-focustextbox.achievesthesamevisualeffectasliteralembeddingbutpreventsinputmanipulationattacks.Figure4showsanexampleoftheinterfacelayouttreesassociatedwiththeActivitiesinthesampleapplicationinFigure3.Wenotethatwewereabletosimplifytheproposedapproach[18],whichwefoundtobeoverlygeneral(seeSection8).ByplacingembeddedActivitiesintotheirownwin-dowsinsteadofintotheparent’swindow,wealsoinheritthesecuritypropertiesprovidedbytheisolationalreadyenforcedbytheWindowManager.Inparticular,thisiso-lationpreventsaparentActivityfrommodifyingorac-cessingthedisplayofitschildActivity(orviceversa).TherelativepositionandsizeofanoverlaidwindowarespeciﬁedbytheembeddingapplicationinthelayoutparametersoftheEmbeddedActivityViewandarehon-oredbytheWindowManager.(NotethatthespeciﬁedsizemayviolatesizeboundsrequestedbytheembeddedActivity,aswediscussinSection5.6.)ThelayoutparametersofanembeddedActivity’swin-dowmustremainconsistentwiththoseoftheassoci-atedEmbeddedActivityView,apracticalchallengenotdescribedinpriorwork.Forexample,whentheuserre-orientsthephoneintolandscapemode,theparentActiv-itywilladjustitsUI.Similarly,whenthesoftkeyboardisshown,AndroidmaypantheActivity’sUIupwardsinordertoavoidcoveringthein-focustextboxwiththekeyboard(Figure5).Inbothcases,theembeddedActiv-ity’swindowsmustberelocatedappropriately.Tosup-portthesedynamiclayoutchanges,theEmbeddedActiv-ityViewreportsitslayoutchangestotheWindowMan-ager,whichappliesthemtotheassociatedwindow.Finally,sinceLayerCakesupportsmultiplelevelsofembedding,itmustappropriatelydisplaywindowsmul-tiplelevelsdown(e.g.,grandchildrenofthetop-levelAc-7104  22nd USENIX Security Symposium 

USENIX Association

Figure6:CroppingFurtherNestedActivities.Ifagrand-child(ActivityC)ofthetop-levelActivity(ActivityA)isplacedorscrolledpartlyoutofthevisibleareaofitsimmediateparent(ActivityB),itmustbecroppedaccordingly.tivity).Forexample,supposeActivityAembedsActiv-ityBwhichembedsActivityC.IftheEmbeddedActivi-tyView(insideActivityB)thatcorrespondstoActivityCisnotfullyvisible—e.g.,becauseitisscrolledhalfwayoutofActivityB’svisiblearea—thenthewindowcorre-spondingtoActivityCmustbecroppedaccordingly(Fig-ure6).ThiscroppingisnecessarybecauseActivityCisnotliterallynestedwithinActivityB,butratheroverlaidontopofit,asdiscussedabove.5.4HandlingFocusBoththeparentandanyembeddedActivitiesmustprop-erlyreceiveuserinput.Whiletoucheventsaredis-patchedcorrectlyeveninthepresenceofvisuallyover-lappingwindows,stockAndroidgrantsfocusforkeyeventsonlytothetop-levelwindow.Asaresult,onlythewindowwiththehighestZ-orderinanapplicationwithembeddedActivitieswilleverreceivekeyevents.WethusmodiﬁedAndroidtoswitchfocusbetweenwin-dowsbelongingtotheparentoranyembeddedActivitieswithinanapplication,regardlessofZ-order.Inparticular,wechangedtheinputdispatcher(C++)todelivertoucheventstotheWindowManagerinadvanceofdeliveringthemtotheresolvedtarget.Whentheusertouchesanunfocusedwindowbelongingtoorembeddedbytheactiveapplication,theWindowManagerredirectsfocus.WindowsthatmightreceivetheredirectedfocusincludethatoftheparentActivity,thewindowofanyem-beddedActivity,oranattachedwindowfromthesameprocess(e.g.,thesettingscontextmenu,whichAndroiddisplaysinanewwindow).Switchingfocusonlyinre-sponsetouserinput(ratherthananapplication’srequest)preventsaparentorchildwindowfromstealingfocustoeavesdroponinputintendedforanotherprincipal.5.5SupportingCross-PrincipalAPIsTosupportdesiredfunctionality,embeddedUIelementsandtheirparentsmustcommunicate.Forexample,anapplicationembeddinganadmaywishtocommunicatekeywordstotheadprovider,orasystem-deﬁnedlocationbutton(ACG)maywishtopassthecurrentlocationtotheparentapplicationinresponsetoauserclick.Toen-Figure7:SizeConﬂictNotiﬁcation.IftheAdMobWrapperapplicationspeciﬁesaminimumsizethattheRestaurantRe-viewActivitydoesnothonorwhenitembedstheadvertisement,asystemnotiﬁcationisdisplayedtotheuser.Clickingonthenotiﬁcationdisplaysafull-screenadvertisementActivity.ableﬂexiblecommunicationbetweenembeddedActivi-tiesandtheirparents,weleveragetheAndroidInterfaceDeﬁnitionLanguage(AIDL),whichletsAndroidappli-cationsdeﬁneinterfacesforinterprocesscommunication.Wethusdeﬁnethefollowingprogrammingmodel.EachembeddableActivitydeﬁnestwoAIDLin-terfaces,onethatit(thechild)willimplement,andonethattheparentapplicationmustimplement.Forexample,theadvertisement(child)mayimplementasetKeywords()method,andthead’sparentappli-cationmaybeaskedtoimplementanonAdLoaded()methodtobenotiﬁedthatanadhasbeensuccess-fullyloaded.Whenanapplicationwishestoem-bedathird-partyActivity,itmustkeepcopiesoftherelevantinterfaceﬁlesinitsownsourceﬁles(asisstandardwithAIDL),anditmustimplementregisterChildBinder().ThisfunctionallowsthechildActivity,oncestarted,tomakeacross-processcallregisteringitselfwiththeparent.Wenotethatthisconnectionissetupautomaticallyonlybetweenparentsandimmediatechildren,asdoingsoforsiblingsorfartherremovedancestorsmayleakin-formationabouttheUIsembeddedbyanotherprincipal.5.6HandlingSizeConﬂictsRecallfromSection5.3thattheWindowManagerhonorstheparentapplication’ssizespeciﬁcationforanEmbed-dedActivityView.Thispolicypreventsachildelementfromtakingoverthedisplay(athreatdiscussedfurtherinthecontextofancestorredirectionbelow).However,wealsowishtopreventsizemanipulationbytheparent.WeobservethatitisonlyofconcernifanembeddedActivityisgivenasmallersizethanrequested,sinceitneednotscaleitscontentstoﬁllits(possiblytoolarge)containingwindow.Thus,wemodiﬁedtheActivityde-scriptorstoincludeonlyanoptionalminimumheightandwidth(speciﬁedindensity-independentpixels).Priorwork[18]describesdifferentsizeconﬂictpoli-ciesbasedonwhethertheembeddedelementistrustedoruntrustedbythesystem.Ifitistrusted(e.g.,asystem-deﬁnedACG),itsownsizerequestshouldbehonored;ifitisuntrusted(e.g.,anadthatrequestsasizeﬁlling8the entire screen), the parent’s size speciﬁcation is hon-
ored. However, we observe that a malicious parent can
mimic the effect of making a child element too small us-
ing other techniques, such as scrolling it almost entirely
off-screen — and that doing so maliciously is indistin-
guishable from legitimate possible scroll placements. We
thus further consider the failure to meet minimum size
requirements in the context of clickjacking (Section 5.7).
Thus, since enforcing a minimum size for trusted em-
bedded elements does provide additional security prop-
erties in practice, we use the same policy no matter
whether mis-sized elements are trusted or untrusted by
the system. That is, the WindowManager honors the size
speciﬁcations of the parent Activity. If these values are
smaller than the embedded Activity’s request, a status
bar notiﬁcation is shown to the user (Figure 7). Similar
to a browser’s popup blocker, the user can click this noti-
ﬁcation to open a full-screen (non-embedded) version of
the Activity whose minimum size was not met.
5.7 Support for Clickjacking Prevention
In a clickjacking attack [11], a malicious application
forces or tricks a user into interacting with an inter-
face, generally by hiding important contextual informa-
tion from the user. For instance, a malicious application
might make a sensitive UI element transparent or very
small, obscure it with another element that allows input
to pass through it, or scroll important context off-screen
(e.g., the preview associated with a camera button).

To prevent such attacks, an interface may wish to dis-
card user input if the target is not fully visible. Since it
may leak information about the embedding application to
let an element query its own visibility, LayerCake allows
embedded Activities to request that the Android frame-
work simply not deliver user input events if the Activity
is:
1. Covered (fully or partly) by another window. This
request is already supported by stock Android via
setFilterTouchesWhenObscured().

2. Not the minimum requested size. A parent application
may not honor a child’s size request (see Section 5.6).
3. Not fully visible due to window placement. An em-
bedded Activity’s current effective window may be
cropped due to scrolling.
Note that an embedded Activity need not be concerned
about a malicious parent making it transparent, because
stock Android already does not deliver input to invisi-
ble windows. Similarly, an Activity need not be con-
cerned about malicious visibility changes to UI elements
within its own window, since process separation ensures
that the parent cannot manipulate these elements. To pre-
vent timing-based attacks, these criteria should be met
for some minimum duration [11] before input is deliv-
ered, a check that we leave to future work.

We emphasize that embedded iframes on the Web to-
day can neither discover if all of these criteria are met —
due to the same-origin policy, they cannot know if the
parent page has styled them to be invisible or covered
them with other content — nor request that the browser
discard input under these conditions.
5.8 Preventing Ancestor Redirection
Android applications use Intents to launch Activities ei-
ther in their own execution context (e.g., to switch to
a Settings Activity) or in another application (e.g., to
launch a browser pointed at a speciﬁed URL). In re-
sponse to a startActivity(intent) system call,
Android launches a new top-level full-screen Activity.
Recall that allowing an embedded element to redirect the
ancestor UI without user consent is a security concern.

for example,

We thus make two changes to the Android frame-
work.
First, we introduce an additional ﬂag for
Intents that starts the resulting Activity inside the
the embedded Activity that started it.
window of
Thus,
if an embedded music player
wishes to switch from its MusicSelection Activity
to its NowPlaying Activity without breaking out of
its embedded window,
it can do so by specifying
Intent.FLAG ACTIVITY EMBEDDED. (If the music
player is not embedded, this ﬂag is simply ignored.)

Second, we introduce a prompt shown to users when
an embedded Activity attempts to launch another Activ-
ity full-screen (i.e., not using the ﬂag described above).
This may happen either because it is a legacy applica-
tion unaware of the ﬂag, or for legitimate reasons (e.g., a
user’s click on an embedded advertisement opens a new
browser window). However, studies have shown that
prompting users is disruptive and ineffective [16]; in Sec-
tion 6.2 we discuss an access control gadget (ACG) that
allows embedded applications to launch full-screen In-
tents in response to user clicks without requiring that the
system prompt the user.
6 Case Studies
We now return to the case studies introduced in Section 3
and describe how LayerCake supports these and other
scenarios. Figure 8 shows that implementation complex-
ity is low, especially for parent applications.
6.1 Geolocation ACG
To support user-driven access for geolocation, we imple-
mented a geolocation access control gadget (ACG) in the
spirit of prior work [19]. We added a LocationAcg
Activity to Android’s SystemUI (which runs in the sys-
tem process and provides the status bar, the recent appli-
cations list, and more). This Activity, which other ap-
plications can embed, simply displays a location button
(see Figure 3).

USENIX Association  

22nd USENIX Security Symposium  105

9

Geolocation ACG
Redirection Intent ACG
Secure WebView
Advertisement
FacebookWrapper

Lines of Java

111
75
133
562
576

Parent Lines of Java

14
23
13
37
30

Figure 8: Implementation Complexity.
Lines of code for
(1) the embedded Activity and (2) the parent’s implementation
of the AIDL interface. We omit legacy applications because
they required no modiﬁcations and expose no parent interfaces.
Implementation complexity is low, especially for embedders.

Following a user click, the SystemUI application, not
the parent application, accesses Android’s location APIs.
To then receive the current location, the parent appli-
cation must implement the locationAvailable()
method deﬁned in the parent AIDL interface provided by
the LocationAcg’s developers (us).
Security Discussion. LayerCake provides the security
properties required to enable ACGs.
In particular, the
parent application of a LocationAcg cannot trick the user
into clicking on the gadget, manipulate the gadget’s look,
or programmatically click on it.

We emphasize again that this ACG provides location
information to the parent application only when the user
wishes to share that information; a well-behaving par-
ent application will not need location permissions. In a
system like Android, where applications can request lo-
cation permissions in their manifest, it is an open ques-
tion how to incentivize developers to use the correspond-
ing ACG instead of requesting that permission. Prior
work [19] has suggested incentives including increased
scrutiny at app store review time of applications request-
ing sensitive permissions.
6.2 Redirection Intent ACG
In Section 5.8, we introduced a system prompt when an
embedded Activity attempts to start a full-screen Activ-
ity. However, prompts are known to be disruptive and of-
ten ignored, especially following a user action intended
to cause the effect about which the prompt warns [31].
For example, a user who clicks on an embedded ad in
stock Android today expects it to open the ad’s target in
a new (non-embedded) browser window. Following the
philosophy of user-driven access control [19], we thus
allow embedded Activities to start top-level Activities
without a prompt if startActivity() is called in
response to a user’s click.

To verify that the user has actually issued the click,
we take advantage of our system’s support for ACGs
and implement an ACG for top-level redirection. This
RedirectAcg Activity again belongs to Android’s
SystemUI application.
It consists primarily of an Im-
ageView that may be ﬁlled with an arbitrary Bitmap, al-

lowing the embedder to completely specify its look. An
embedded Activity that embeds such an ACG (two levels
of embedding) thus uses the cross-process API provided
by the RedirectAcg to (1) provide a Bitmap specifying
the look, and (2) specify an Intent to be supplied to the
startActivity() system call when the user clicks
on the RedirectAcg (i.e., the ImageView’s onClick()
method is ﬁred).
Security Discussion. The UI-level security proper-
ties provided by LayerCake ensure that the Redirec-
tAcg’s onClick() method is ﬁred only in response
to real user clicks. In other words, the embedding ap-
plication cannot circumvent the user intent requirement
for launching a top-level Activity by programmatically
clicking on the RedirectAcg or by tricking the user into
clicking on it.

Unlike the LocationAcg, however, the embedding ap-
plication is permitted to fully control the look of the
RedirectAcg. This design retains backwards compati-
bility with the stock Android experience and relies on
the assumption that a user’s click on anything within an
embedded Activity indicates the user’s intent to interact
with that application. However, alternate designs might
choose to restrict the degree to which the redirecting ap-
plication can customize the RedirectAcg’s interface. For
example, the system could place a visual “full-screen”
or “redirect” indicator on top of the application-provided
Bitmap, or it could simply support a stand-alone “full-
screen” ACG that applications wishing to open a new
top-level view must display without customization.

Note that developers are incentivized to use the Redi-
rectAcg because otherwise attempts to launch top-level
Activities will result in a disruptive prompt (Section 5.8).
6.3 Secure WebView
We implemented a SecureWebView that addresses secu-
rity concerns surrounding Android WebViews [12, 13].
The SecureWebView is an Activity in a new built-in ap-
plication (WebViewApp) that consists solely of an ordi-
nary WebView (inside a FrameLayout) that ﬁlls the Ac-
tivity’s whole UI. Thus, when another Activity embeds a
SecureWebView, the internal WebView takes on the di-
mensions of the associated EmbeddedActivityView.

The SecureWebView Activity exposes a safe subset
(see below) of the underlying WebView’s APIs to its
embedding process. The current version of LayerCake
exposes only a subset of these APIs for demonstra-
tion purposes. A complete implementation will need to
properly (de)serialize all complex data structures (e.g.,
SslCertificate) across process boundaries.
Security Discussion. Separating out the Android Web-
View into another process — that of the WebViewApp —
provides important missing security properties. It is no
longer possible to eavesdrop on input to the embedded

106  22nd USENIX Security Symposium 

USENIX Association

10

webpage, to extract content or programmatically issue
input, or to manipulate the size, location, or transparency
of the WebView to mount clickjacking attacks.

if

While the SecureWebView wraps the existing Web-
View APIs, it should avoid exposing certain sensitive
APIs, such as those that mimic user input (e.g., scrolling
via pageUp()) or that directly extract content from the
WebView (e.g., screenshot via capturePicture()).
Note, however, that APIs which redirect the SecureWeb-
View to another URL are permitted, as the parent appli-
cation could simply open a new SecureWebView instead.
Ideally, Android would replace the WebView with
the SecureWebView, but
this change would not be
backwards compatible and may conﬂict with the goals
of some developers in using WebViews. Thus, we
observe that using a SecureWebView also beneﬁts
the embedding application:
it exposes an API
to the webpage via an ordinary WebView (using
addJavascriptInterface()), a malicious page
could use this to manipulate the host application. Pro-
cess separation protects the host application from such
an attack, and since the WebViewApp has only the
INTERNET permission, the attack’s effect is limited.
Additionally, WebView cookies are not shared across
processes;
the SecureWebView allows applications to
reuse (but not access) existing cookies, possibly provid-
ing a smoother user experience.
6.4 Advertisements
Recall that stock Android applications embedding third-
party advertisements include an ad library that runs in the
host application’s process and provides an AdView ele-
ment. Our modiﬁcations separate the AdView out into its
own process (see the advertisement in Figure 3). To do
this, we create a wrapper application for the AdMob ad-
vertising library [10]. The wrapper application exposes
an embeddable Activity (called EmbeddedAd) that in-
stantiates an AdMob AdView with the speciﬁed param-
eters. This Activity exposes all of AdMob’s own APIs
across the process boundary, allowing the embedding ap-
plication to specify parameters for the ad.
Security Discussion. Moving ads into their own process
(one process per ad library) addresses a number of the
concerns raised in Section 3. In particular, an ad library
can no longer abuse a parent application’s permissions
or exploit a buggy parent application. Furthermore, the
permissions needed by an ad library, such as Internet and
location permissions, must no longer be requested by the
parent application (unless it needs these permissions for
other purposes).

Note that all ads from a given ad library — even if
embedded by different applications — run in the same
process, allowing that ad application to leverage input
from different embedders. For example, if one appli-

cation provides the user’s age and another provides the
user’s gender, the ad application can better target ads in
all parent applications, without revealing additional in-
formation to applications that did not already have it.
(However, we note that some users may prefer that ad
applications not aggregate this information.)

LayerCake goes beyond process separation, providing
UI-level security absent in most prior systems (except
AdSplit [23]). Most importantly, the parent can no longer
mount programmatic click fraud attacks.
6.5 Facebook Social Plugins
We can now support embedded Facebook social wid-
gets in a secure manner. We achieve this by creating a
Facebook wrapper application that exposes Activities for
various Facebook social widgets (e.g., a Comments Ac-
tivity and a Like Activity — see Figure 9). Each Activ-
ity displays a WebView populated with locally-generated
HTML that references the Facebook JavaScript SDK to
generate the appropriate plugin (as done ordinarily by
web pages and as speciﬁed by Facebook [6]).
Security Discussion. LayerCake supports functional-
ity that is impossible to achieve securely in stock An-
droid and may be desirable to Facebook. This func-
tionality was previously available only on the Web, due
to the relative security of embedded iframes (though
clickjacking, or “likejacking”, remains a problem on the
Web). Our implementation protects the social widgets
both by separating them into a different process (pre-
venting data extraction, among others), and by enforcing
other UI-level security properties (preventing clickjack-
ing and programmatic clicking).

We observe that a malicious application might attempt
to mimic the FacebookWrapper application by populat-
ing a local WebView with the HTML for a social plugin.
To prevent this attack, we recommend that the Facebook-
Wrapper application include a secret token in the HTML
it generates (and that Facebook’s backend verify it), sim-
ilar in approach to CSRF protections on the Web.
6.6 Legacy Applications
The applications discussed so far needed wrapper appli-
cations because the wrapped functionality was not previ-
ously available in a stand-alone fashion. However, this
need is not fundamental — any legacy Android applica-
tion (i.e., one that targets older versions of the Android
SDK) can be embedded using the same techniques.

To demonstrate this, we created an application that
embeds both the existing Pandora application and the ex-
isting Amazon application. To do so, we needed to dis-
cover the names of the corresponding Activities in the ex-
isting applications. This information is easy to discover
from Android’s standard log, which prints information
about Intent targets when they are launched. Figure 10

USENIX Association  

22nd USENIX Security Symposium  107

11

108  22nd USENIX Security Symposium 

USENIX Association

Figure9:FacebookSocialPlugins.Thisexampleblogappli-cationembedsbothaFacebook“Like”buttonandacommentsfeed,bothrunninginourFacebookWrapperapplication.showsascreenshotoftheresultingapplication.SecurityDiscussion.Asinpreviouscasestudies,theembeddedActivitiesareisolatedfromtheparent.Thus,theycannotaccesssensitiveinformationinormanipulatetheUIorAPIsintheparentapplication,orviceversa.LegacyapplicationsnaturallydonotusethenewFLAGACTIVITYEMBEDDEDﬂagwhenlaunchingin-ternalActivities.WhileupdatedversionsofPandoraandAmazoncouldusethisﬂagtoredirectwithinanembed-dedwindow,theexperiencewithunmodiﬁedlegacyap-plicationsislikelytobedisruptive.Thus,apossiblepol-icy(perhapssubjecttoauserpreferencesetting)forsuchapplicationsistointernallymodifyallActivitylaunchestousethenewﬂag,neverallowingtheseapplicationstobreakoutoftheirembeddedwindows.Embeddingarbitraryapplicationsthatwerenotin-tendedbytheirdeveloperstobeembeddedalsoraisesthequestionofembeddingpermissions.SomeActivi-tiesmaywishnevertobeembedded,ortobeembeddedonlybyauthorizedparents.FuturemodiﬁcationstoLay-erCakeshouldsupportsuchpermissions.7PerformanceEvaluationWeevaluatetheperformanceimpactofourchangestoAndroidbymeasuringthetimeittakestostartanappli-cation,i.e.,thedelaybetweenastartActivity()systemcallandtheonCreate()callforthelastem-beddedActivity(ortheparentActivity,ifnoneareem-bedded).AsshowninthetopofFigure11,applicationswithembeddedActivitiestakelongertofullystart.ThereasonforthisisthattheparentActivity’slayoutmustbecreated(initsonCreate())beforechildActivi-tiescanbeidentiﬁed.Thus,anapplicationwithmultiplenestedActivities(e.g.,RestaurantReviewer)requireslin-earlymoretimethananapplicationwithonlyonelevelFigure10:EmbeddedPandoraandAmazonApps.Legacyapplicationscanalsobeembedded,raisingpolicyquestionsregardingtop-levelintentsandembeddingpermissions.ofnesting(e.g.,FacebookDemoorListen&Shop).WenotethattheparentActivity’sownloadtimeisunaf-fectedbythepresenceofembeddedcontent(e.g.,theFacebookDemoActivitystartsin160ms,eventhoughtheembeddedFacebookcomponentsrequire300ms).Priorwork[15]hasarguedthatthetimetodisplayﬁrstcontentismoreimportantthanfullloadtime.Wealsomeasureinputeventdispatchtime(e.g.,thetimeittakesforAndroidtodeliveratoucheventtoanapplication).Speciﬁcally,weevaluatetheimpactofdis-patchinginputeventsﬁrsttotheWindowManager,al-lowingittoredirectfocusifappropriate(Section5.4).ThebottomofFigure11showsthatinvolvingtheWin-dowManagerindispatchhasanegligibleperformanceimpactoverstockAndroid;changingfocushasagreaterimpact,butitisnotnoticeablebytheuser,andfocuschangeeventsarelikelyrare.Wecanalsoreportanecdotallythattheeffectofem-beddingontheperformanceofourcasestudyapplica-tionswasunnoticeable,exceptthatthepanningofem-beddedwindows(forthesoftwarekeyboard)appearstolagslightly.Thiscasecouldlikelybeoptimizedbybatchingcross-processrelayoutmessages.Finally,supportingembeddedActivitiesmayresultinmoreapplicationsrunningonadeviceatonce,poten-tiallyimpactingmemoryusageandbatterylife.Thepracticalimpactofthisissuedependsontheembed-dingbehaviorofrealapplications—forexample,per-hapsmostapplicationswillincludeadsfromasmallsetofadlibraries,limitingthenumberofapplicationsruninpractice.8DiscussionWhereasexistingsystems—particularlybrowsers—haveevolvedsecuritymeasuresforembeddeduserin-terfacesovertime,thispaperhastakenaprincipledap-12Application

Load time (10 trial average)

No Embedding With Embedding

RestaurantReviewer
FacebookDemo
Listen&Shop

163.1 ms
157.5 ms
159.6 ms

532.6 ms
304.9 ms
303.3 ms

Scenario

Event Dispatch Time (10 trial average)

Stock Android
No focus change
Focus change

1.9 ms
2.1 ms
3.6 ms

Figure 11: Performance. The top table shows the time it takes
for the onCreate() method of all included Activities to be
called. We note that the time to load the parent Activity remains
the same whether or not it uses embedding, so the time for the
parent to begin displaying native content is unaffected. The
bottom table shows that the effect of intercepting input events
in the WindowManager for possible focus changes is minor.

proach to deﬁning a set of necessary security properties
and building a system with full-ﬂedged support for em-
bedding interfaces based on these properties.
8.1 Lessons for Embedded Interfaces
From this process, we provide a set of techniques for
systems that wish to support secure cross-application UI
embedding. Figure 2 outlines the security properties pro-
vided by LayerCake and summarizes the implementation
techniques used to achieve each property. While prior
works [18, 19] have stated the need for many (though not
all) of these properties, they have not provided detailed
guidelines for implementation. We hope this work, in
which we bring techniques from prior work together into
a practical implementation, will serve that purpose.

Our implementation experience challenges several
previous assumptions or choices. These lessons include:
User-driven ancestor redirection. Embedded applica-
tions should not be able to redirect an ancestor applica-
tion/page without user consent. We argue that a reason-
able tradeoff between security and usability is to prompt
users only if the redirection attempt does not follow a
user click (indicating the user’s intent to interact with the
embedded content). While newer browsers prevent em-
bedded iframes from redirecting the top-level page pro-
grammatically, they do not allow user actions (e.g., click-
ing on a link with target top) or other mechanisms to
override this restriction. In our case studies, we saw that
this type of click-enabled redirection can be useful and
expected (e.g., when a user clicks on an embedded ad, he
or she likely expects to see full-screen content about the
advertised product or service). In our system, we were
able to apply ACGs in a novel way to capture a user’s
redirection intent (Section 6.2).
Size manipulation as a subset of clickjacking. We ini-

tially considered size manipulation (by the parent of an
embedded interface element) to be a stand-alone threat.
A solution that we considered is to treat elements that
are trusted or untrusted by the system differently (e.g.,
an access control gadget is trusted while an advertise-
ment is not), letting the system enforce the minimum
requested size for trusted elements. However, this so-
lution provides no additional security, since a malicious
parent can use other techniques to obscure the sensitive
element (e.g., partially covering it or scrolling it partly
off-screen). Thus, we consider size manipulation as a
subset of clickjacking. We suggest that sufﬁcient size be
considered an additional criterion (in addition to tradi-
tional clickjacking prevention criteria like complete visi-
bility [11, 19]) for the enabling of a sensitive UI element.
Simpliﬁcation of secure UI layout tree. Prior work [18]
proposes invariants for the interface layout tree that en-
sure a trusted path to every node and describes how to
transform an invalid layout tree into a valid one. Our im-
plementation experience shows this solution to be overly
general. Embedded elements need not be attached to the
layout tree in arbitrary locations; rather, they can always
attach to the (system-controlled) root node and overlaid
appropriately by the WindowManager (or equivalent).
That is, the layout trees of separate principals need never
be interleaved, but rather visually overlaid on top of each
other, requiring no complex tree manipulations. Simpli-
fying this approach is likely to make it easier and less
error-prone for system developers to support secure em-
bedded UI.

8.2 New Capabilities
We step back and consider the capabilities enabled by
our implementation.
In particular, the following sce-
narios were fundamentally impossible to support before
our modiﬁcations to Android; LayerCake provides ad-
ditional security properties and capabilities even beyond
the Web, as we detail here.
Isolated Embedded UI. Most fundamentally, LayerCake
allows Android applications to securely embed UI run-
ning in another process. Conceptually, this aligns the An-
droid application model with the Web model, in which
embedded cross-principal content is common. Espe-
cially as Android expands to larger devices like tablets,
users and application developers will beneﬁt from the
ability to securely view and show content from multiple
sources in one view.
Secure WebViews. It is particularly important that Web-
Views containing sensitive content run in their own pro-
cess. While an Android WebView seems at ﬁrst glance
to be similar to an iframe, it does not provide the se-
curity properties to which developers are accustomed on
the Web (as discussed in this paper and identiﬁed in prior

USENIX Association  

22nd USENIX Security Symposium  109

13

work [12, 13]). LayerCake matches and indeed exceeds
the security of iframes — in particular, a SecureWebView
can request that the system not deliver user input to it
when it is not fully visible or sufﬁciently large, thereby
preventing clickjacking attacks that persist on the Web.
Access Control Gadgets. Prior work [19] introduced
ACGs for user-driven access control of sensitive re-
sources like the camera or location, but that work does
not provide concrete guidelines for how the necessary
UI-level security properties should be implemented. This
paper provides these details, and we hope that they will
guide system developers to include ACGs in their sys-
tems. We particularly recommend that browser vendors
consider ACGs in their discussions of how to allow users
to grant websites access to sensitive resources [28].
8.3 Additional Issues
Finally, we discuss several issues unaddressed by Layer-
Cake that must be considered in future work.

First is the issue of application dependencies, that
is, how to handle the case when an application em-
beds an Activity from another application that is not in-
stalled. Possibilities include automatically bundling and
installing dependencies (as also proposed by the authors
of AdSplit [23]), giving the user the option of installing
the missing application, or simply failing silently. This
issue led the authors of AdDroid [17] to decide against
running ads in their own process, but we argue that the
security concerns of not doing so outweigh this issue.
The concern that users might uninstall or replace ad ap-
plications to avoid seeing ads could be addressed by giv-
ing parent applications feedback when a requested em-
bedded Activity cannot be displayed; applications rely-
ing on ads could then display an error message if the
required ad library is not available. Updates and dif-
ferences in library versions required by apps could be
handled by Android by supporting multiple installed ver-
sions or simply by the ad libraries themselves.

Second is the issue of principal identiﬁcation: a user
cannot easily determine the source of an embedded inter-
face (or even whether anything is embedded). This con-
cern mirrors the Web today, where an iframe’s presence
or source cannot be easily determined, and we consider
this to be an important orthogonal problem.
9 Related Work
Finally, we consider additional related work not dis-
cussed inline.

In Section 4 and Figure 1, we explored existing im-
plementations of embedded cross-application user inter-
faces [5, 17, 18, 23]. These systems have differing goals
and employ a variety of techniques, but none fully meets
the security requirements deﬁned in [18] and expanded
here. In particular, none of these approaches can, without

modiﬁcation, support security-sensitive embedded user
interfaces like ACGs [19]. The original ACG imple-
mentation built on interface-level security properties pro-
vided by the Gazelle browser operating system [29].

Others have explored the problem of clickjacking in
more depth. One study [20] found that most framebust-
ing techniques are circumventable, making them ineffec-
tive for preventing clickjacking. Other work [11] pro-
vides a comprehensive study of clickjacking attacks and
defenses, presenting a solution (InContext) that relies on
the browser to verify the visual context of sensitive UI
elements. LayerCake could be extended to support In-
Context for additional clickjacking protection.

Our implementation relies on security properties pro-
vided by the Android WindowManager. Window system
security has been explored previously by projects such
as Trusted X [4] (an implementation of the X Window
System [9] based on the Compartmented Mode Worksta-
tion requirements [30]) and the EROS Trusted Window
System [22]. We extend this work by leveraging a se-
cure window system to support secure cross-application
UI embedding.
10 Conclusion
We have systematically considered the security require-
ments for embedded user interfaces, analyzing exist-
ing systems — including browsers, smartphones, and re-
search systems — with respect to these requirements.
While browsers have evolved to address many (though
not all) of these requirements over time, Android-based
implementations have not supported secure embedded
interfaces. We thus created LayerCake, a modiﬁed
version of the Android framework that supports cross-
principal embedded interfaces in a way that meets our
security goals. The resulting capabilities enable several
important scenarios, including advertisement libraries,
Facebook social plugins, and access control gadgets.
Based on our exploration and implementation experi-
ence, we provide a concrete set of criteria and techniques
that has to date been missing for system developers wish-
ing to support secure interface embedding.

This paper, along with any updates, will be available

at https://layercake.cs.washington.edu/.
11 Acknowledgements
We thank Roxana Geambasu, Alex Moshchuk, Bryan
Parno, Helen Wang, and the anonymous reviewers for
their valuable feedback on earlier versions. This work
is supported in part by the National Science Founda-
tion (Grant CNS-0846065 and a Graduate Research Fel-
lowship under Grant DGE-0718124), by the Defense
Advanced Research Projects Agency (under contract
FA8750-12-2-0107), and by a Microsoft Research PhD
Fellowship.

110  22nd USENIX Security Symposium 

USENIX Association

14

[18] ROESNER, F., FOGARTY, J., AND KOHNO, T. User Interface-
Toolkit Mechanisms for Securing Interface Elements.
In 25th
ACM Symposium on User Interface Software and Technology
(2012).

[19] ROESNER, F., KOHNO, T., MOSHCHUK, A., PARNO, B.,
WANG, H. J., AND COWAN, C. User-Driven Access Control:
Rethinking Permission Granting in Modern Operating Systems.
In IEEE Symposium on Security and Privacy (2012).

[20] RYDSTEDT, G., BURSZTEIN, E., BONEH, D., AND JACKSON,
C. Busting Frame Busting: A Study of Clickjacking Vulnerabili-
ties on Popular Sites. In IEEE Workshop on Web 2.0 Security and
Privacy (2010).

[21] SCHECHTER, S., DHAMIJA, R., OZMENT, A., AND FISCHER,
I. The Emperor’s New Security Indicators. In IEEE Symposium
on Security and Privacy (2007).

[22] SHAPIRO, J. S., VANDERBURGH, J., NORTHUP, E., AND CHIZ-
MADIA, D. Design of the EROS Trusted Window System. In 13th
USENIX Security Symposium (2004).

[23] SHEKHAR, S., DIETZ, M., AND WALLACH, D. S. AdSplit:
Separating Smartphone Advertising from Applications. In 21st
USENIX Security Symposium (2012).

[24] SOPHOS LABS.

Facebook Worm:

Likejacking, 2010.

http://nakedsecurity.sophos.com/2010/05/
31/facebook-likejacking-worm/.

[25] TANG, S., MAI, H., AND KING, S. T. Trust and Protection in
the Illinois Browser Operating System. In USENIX Symposium
on Operating Systems Design and Implementation (2010).

[26] TEMPLEMAN, R., RAHMAN, Z., CRANDALL, D. J., AND KA-
PADIA, A. Placeraider: Virtual theft in physical spaces with
smartphones. CoRR abs/1209.5982 (2012).

[27] W3C.

Same Origin Policy.

http://www.w3.org/

Security/wiki/Same_Origin_Policy.

[28] W3C. Device API Working Group, 2011. http://www.w3.

org/2009/dap/.

[29] WANG, H. J., GRIER, C., MOSHCHUK, A., KING, S. T.,
CHOUDHURY, P., AND VENTER, H. The Multi-Principal OS
Construction of the Gazelle Web Browser. In 18th USENIX Se-
curity Symposium (2009).

[30] WOODWARD, J. P. L. Security Requirements for System High
and Compartmented Mode Workstations. Tech. Rep. MTR 9992,
Revision 1 (also published by the Defense Intelligence Agency as
DDS-2600-5502-87), The MITRE Corporation, Nov. 1987.

[31] YEE, K.-P. Aligning Security and Usability. IEEE Security and

Privacy 2(5) (Sept. 2004), 48–55.

References
[1] BARTH, A.

Security in Depth:

HTML5’s @sand-
http://blog.chromium.org/2010/05/

box, 2010.
security-in-depth-html5s-sandbox.html.

[2] BEGEMANN, O. Remote View Controllers in iOS 6, Oct.
2012. http://oleb.net/blog/2012/02/what-ios-
should-learn-from-android-and-windows-8/.

[3] DIETZ, M., SHEKHAR, S., PISETSKY, Y., SHU, A., AND WAL-
LACH, D. S. Quire: Lightweight Provenance for Smart Phone
Operating Systems. In 20th USENIX Security Symposium (2011).

[4] EPSTEIN, J., MCHUGH, J., AND PASCALE, R. Evolution of a
Trusted B3 Window System Prototype. In IEEE Symposium on
Security and Privacy (1992).

[5] ETTRICH, M., AND TAYLOR, O. XEmbed Protocol Speciﬁ-
cation, 2002. http://standards.freedesktop.org/
xembed-spec/xembed-spec-latest.html.

[6] FACEBOOK.

Social Plugins.

https://developers.

facebook.com/docs/plugins/.

[7] FACEBOOK.

Like button requires conﬁrm step, 2012.

https://developers.facebook.com/bugs/
412902132095994/.

[8] FELT, A. P., HA, E., EGELMAN, S., HANEY, A., CHIN, E.,
AND WAGNER, D. Android permissions: user attention, com-
prehension, and behavior. In 8th Symposium on Usable Privacy
and Security (2012).

[9] GETTYS, J., AND PACKARD, K. The X Window System. ACM

Transactions on Graphics 5 (1986), 79–109.

[10] GOOGLE. AdMob Ads SDK.

https://developers.

google.com/mobile-ads-sdk/.

[11] HUANG, L.-S., MOSHCHUK, A., WANG, H. J., SCHECHTER,
S., AND JACKSON, C. Clickjacking: Attacks and Defenses. In
21st USENIX Security Symposium (2012).

[12] LUO, T., HAO, H., DU, W., WANG, Y., AND YIN, H. Attacks
on WebView in the Android system. In 27th Annual Computer
Security Applications Conference (2011).

[13] LUO, T., JIN, X., ANANTHANARAYANAN, A., AND DU, W.
Touchjacking Attacks on Web in Android, iOS, and Windows
Phone.
In 5th International Symposium on Foundations and
Practice of Security (2012).

[14] MICROSOFT. User Account Control. microsoft.com/en-

us/library/windows/desktop/aa511445.aspx.

[15] MOSHCHUK, A., BRAGIN, T., DEVILLE, D., GRIBBLE, S. D.,
AND LEVY, H. M. SpyProxy: Execution-Based Detection of
Malicious Web Content.
In 16th USENIX Security Symposium
(2007).

[16] MOTIEE, S., HAWKEY, K., AND BEZNOSOV, K. Do Windows
Users Follow the Principle of Least Privilege?: Investigating User
Account Control Practices. In Symposium on Usable Privacy and
Security (2010).

[17] PEARCE, P., FELT, A. P., NUNEZ, G., AND WAGNER, D. Ad-
Droid: Privilege Separation for Applications and Advertisers in
Android.
In ACM Symposium on Information, Computer and
Communications Security (AsiaCCS) (2012).

USENIX Association  

22nd USENIX Security Symposium  111

15

