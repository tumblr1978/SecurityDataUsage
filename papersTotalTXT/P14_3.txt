Identifying and Analyzing Pointer Misuses 

for Sophisticated 

Memory-corruption Exploit Diagnosis 

Mingwei Zhang (†) 
Aravind Prakash (§) 
Xiaolei Li (†) 
Zhenkai Liang (†) 
Heng Yin (§) 

(†) School of Computing, National University of Singapore 
(§) Department of Electrical Engineering and Computer 
Science, Syracuse University 

Simple Stack Buffer Overflow 

  An attacker overwrites vulnerable function return 

address, which points to shellcode on stack. 

shellcode 

return address 

buffer 

Only one step 

  These single step attacks don’t work anymore thanks to: 

  ASLR, DEP, NX, etc. 

2 

Exploiting SEH Mechanism 

TIB 

step 2 

SEH Record  

exception handler 

prev 

t

S
a
c
k
 
g
r
o
w
h

t

 

arguments prepared by OS 
for exception handler 

return address of exception 

handler function 

return address 
security cookie 

buffer 

DispatcherContext 

ContextRecord 
EstablisherFrame 
ExceptionRecord 
return address 

pop 
pop 
ret 

step 1 

step 3 

3 

Insights 
  Recent attacks employ multiple steps. 
  Pointer misuse is very prominent in 

sophisticated attacks. 

  Key steps constitute pointer misuses. 

Our Goal: 
Diagnosing pointer misuses in a multi-step attack. 

4 

Pointerscope – Attack 
Diagnosis Engine 
  Type System tailored to diagnose pointer 

misuse. 

  Eager type inference system to detect 

pointer misuses. 

  Provide big picture of the misuse through 

key steps graph. 

5 

Overview 

Guest	  OS	  

Vulnerable	  
Program	  
(Browser)	  

Exploit 
(Malicious 
Server) 

Type	  Inference	  

Engine	  

Execu6on	  Monitor	  

(TEMU)	  

Execu6on	  

Trace	  

Diagnosis	  Engine	  

Diagnosis	  
Report	  

6 

Variable And Variable Type 
  A variable is a memory location or a register. 
  Simple primitive variable types: 

  Integer 
  Control Pointer (or code pointer) 
  Data Pointer 
  Other. (The rest of the types) 

7 

Type Lattice 

8 

Eager Dynamic Type Inference 
  Type Propagation: 
  mov %eax, %ebx 

  Inference: eax and ebx have same type 

  Type Constraints: 

  call %eax  

  Inference: %eax contains Control Pointer 

9 

Example – Type Inference 

{eax, ebx} : ANY 
{eax, ebx, ecx} : ANY 
ecx is an INT 
{eax, ebx, ecx}: Integer 

{eax, ebx, ecx, edx} :  Integer 

Used as a pointer. Conflict 

Harder than it seems! 

mov %eax, %ebx 
mov %ebx, %ecx 

imul $0x05, %ecx, %ecx 

mov %ecx, %edx 
call *%ecx 

10 

Challenges 

  X86 supports base-index with displacement – 

Problem: Compilers don’t follow convention. 

movl	  $0x8(	  	  	  	  ,	  	  	  	  ),	  %ecx	  

%eax	  %edx	  

address	   =	  

displacement	  

+	  

base	  register	  

+	  

index	  register	  

Solution: Register closest to result is the base. 

11 

Challenges… contd. 
  Individual instructions not always lead to 

accurate type inferences. 
  Eg: 

not	  %ebp	  
or	  	  $0x3,%ebp	  
not	  %ebp	  

and	  $0xfffffffc,%ebp	  

  Solution: recognizing the common patterns and 

treat them as special cases 

12 

Challenges… contd. 

  LEA designed to load effective address, but 

often used in arithmetic.

  

lea $0x8(%eax,%edx,4), %ecx	  

%ecx(cid:290)%eax(cid:272)%edx×4(cid:272)$0x8	  

Solution: Treat lea as an arithmetic operation. 

13 

Challenges… 
  More challenges discussed in the paper! 

14 

Key Steps Graph – Example 

Infer: Top of stack, 
(0xbfff0000)	  
is	  an	  INT 

0x42050000:	  	  	  pushfd	  

Type Origin (INT) 

Where the variable was  
initialized 

Mem:	  0xbfff0000	  [4]	  

Type Usage (CTR) 

0x08048000:	  	  	  ret	  

Returning to 
0xbfff0000	  

Where the variable was 
misused 

15 

Evaluation 
  Implementation 

  Execution monitor on TEMU. 
  3.6K lines of C code. 

  Experimental setup 

  Evaluated against real world exploits from Metasploit framework. 

16 

Summary of Effectiveness 

CVE 

Attack Technique 

Runtime* 

CVE-2010-0249 

CVE-2009-3672 

CVE-2009-0075 

CVE-2006-0295 

CVE-2006-1016 

CVE-2006-4777 

CVE-2006-1359 

CVE-2010-3333 

CVE-2010-3962 

Uninitialized memory; 

heap spray 

Incorrect variable 

initialization; heap-spray 
Uninitialized memory; 

heap spray 

18m23s, 
8m30s 
3m10s, 

31s 
25m, 

21m16s 

Heap overflow; heap 

spray 

Stack overflow; SEH 

exploit 

Integer overflow; heap 

spray 

Incorrect variable 

initialization; heap spray 

Stack overflow 

vulnerability; SEH exploit 

Incorrect variable 

initialization; heap spray 

3m5s, 1s 

4m59s, 
1m33s 
1m45s, 

40s 

11m58s, 

13s 

18m53s, 
7m24s 
10m36, 

15s 

Pointer 
Misuses 

Trace Size 

Slice Size 

11 

307,987,560 

48,404,242 

2 

6 

3 

3 

3 

2 

1 

2 

22,759,299 

955,325 

411,323,083 

44,792,770 

808,392 

34,883 

64,355,691 

1,334,253 

2,632,241 

1,669,751 

8,336,193 

29,520 

236,331,307 

814,305 

9,281,019 

78,704 

*Time taken to generate trace, time taken to generate key steps 

17 

Case Study: CVE-2009-3672 
  This is a real world exploit for vulnerable 

version of IE Browser 

  This attack is caused by a vulnerability in the 

class CDispNode’s member function 
SetExpandedClipRect 

18 

The First Type Conflict 

0x749120f2:          or $0x2, %eax 
I@0x00000000[1](R) R@eax[4](RW) 

0x102098@mshtml.dll@CLayout::SizeDispNode 

Infer: Integer 

Type Origin (INT) 

or $0x2, %eax 

eax (4 bytes) 

Type Usage (CTR) 

0x7490e854:          call *0x2c(%eax) 

       M@0x74831546[4]  M@0x0013e0d4[4]  

0xfe838@mshtml.dll@CLayout::GetFirstContentDispNode 

Used as Control Ptr 
Violation 

19 

The Second Type Conflict 

0x74912000:         call *0x2c(%eax) 

       M@0x74000004[4]  M@0x0013e068[4]   
0x102098@mshtml.dll@CLayout::SizeDispNode 

0x74943a14:         call *0x30(%eax) 

       M@0x74000008[4]  M@0x0013dde4[4] 

0x13393f@mshtml.dll@CDispNode::GetNodeClipTransform 

Type Origin (CTR) 

Type Origin (CTR) 

M@0x74000004[4] 

M@0x74000008[4] 

Type Usage (CTR) 

Type Usage (CTR) 

[16940584] 0x7490e854 call *0x2c(%eax) 
       M@0x74000006[4]  M@0x0013e0d4[4]  

0xfe838@mshtml.dll@CLayout::GetFirstContentDispNode 

20 

Final Result 

21 

Reducing False Positives 
  What makes it hard? 
  Compiler optimizations 
  Code obfuscation – even by proprietary code. 

  Note: Our goal is NOT to eliminate False 

Positives. 

22 

Related Work 
  Attack Diagnosis Techniques 

  BackTracker [King, et. al, SOSP’03], Dynamic 

Taint Analysis [Newsome, et. al, NDSS’05] 
  Type and Data Structure recovery from 

binary 
  Rewards [Zin, et.al, NDSS’10], Howard 

[Slowinska, NDSS’11], Tie [Lee, et.al, NDSS’11] 

  Defense and evasion techniques 

  CFI [Abadi, et.al, CCS’05], DFI [Castro, et.al, 
OSDI’06], WIT [Akritidis, et.al, IEEE S&P’08] 

23 

Conclusion 
  We define a pointer centric type system to 

track pointers. 

  We design a type inference system to 

detect pointer misuses. 

  We generate the key steps graph to identify 

key steps. 

  We evaluate our work by testing our system 

on real-world exploits from metasploit. 

24 

Questions? 

25 

Challenges… contd. 

  Handling memory copy operations 

  Memory copy operations may break the integrity of 

variables 

inherit	  type	  information	  

rep	  movsb	  
depend	  on	  

Variable	  A	  

Variable	  B,C,D,E	  

Variable	  F	  

Solution: Aggregation. 

26 

Case Study: SEH Attack  

